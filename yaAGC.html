<!DOCTYPE doctype PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
  <head>
    <title>Virtual AGC yaAGC Page</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="Author" content="Ronald Burkey">
    <link rel="icon" type="image/png" href="favicon.png">
    <meta name="author" content="Ronald S. Burkey">
    <script type="text/javascript" src="Header.js"></script>
  </head>
  <body style="background-image: url(gray3.jpg);">
    <script type="text/javascript">
document.write(headerTemplate.replace("@TITLE@","yaAGC").replace("@SUBTITLE@","The AGC Simulation Software"))
</script>
    <h1><small>What is yaAGC?<br>
      </small></h1>
    <span style="font-weight: bold;">yaAGC</span> is a computer program
    which emulates the behavior of the "Block 2" Apollo Guidance
    Computer (AGC).&nbsp; (There was also an earlier <a
      href="Block1.html">"Block 1" AGC</a> that never flew in any manned
    missions.) &nbsp; It is a virtual computer (existing within, for
    example, a desktop PC) which is capable of running software written
    for the original AGCs used in the Apollo project.&nbsp; <span
      style="font-weight: bold;">yaAGC</span> emulates only the computer
    itself, and not the peripheral devices used by the AGC.&nbsp; For
    example, the display/keyboard (DSKY) used by the AGC is a peripheral
    device and is emulated by a completely different computer program
    called <span style="font-weight: bold;">yaDSKY</span>.&nbsp; Just
    as the true AGC and DSKY communicated between themselves by mean of
    wiring, the virtual yaAGC and yaDSKY communicate between themselves
    using communication channels (sockets) that act like virtual
    wires.&nbsp;<br>
    <br>
    Similarly, as a "computer", <span style="font-weight: bold;">yaAGC</span>
    by itself provided little or no functionality.&nbsp; To be useful,
    it needs to be "loaded" with appropriate flight software—in other
    words, with the Command Module (CM) or Lunar Module (LM)
    flight-software written for the original Apollo
    missions.&nbsp;&nbsp; The CM and LM software are called <span
      style="font-weight: bold;">Colossus</span> and <span
      style="font-weight: bold;">Luminary</span>, respectively.<br>
    <br>
    <h2>What, Exactly, is Being Simulated?</h2>
    <div style="text-align: center;"> <img src="ArchitectureGN.gif"
        alt="Guidance&amp;Navigation block architecture" style="width:
        517px; height: 542px;" width="517" height="542"><br>
    </div>
    <br>
    <ul>
      <li>The <span style="font-weight: bold;">yaAGC</span> and <span
          style="font-weight: bold;">yaDSKY</span> programs simulate the
        center two blocks in the figure above.&nbsp; The actual Block II
        AGC measured 24.250"×12.433"×5.974" (61.595×31.580×15.174 cm),
        weighed 70.1 pounds (31.8 kg), and drew 2.5A of current at 28V
        DC.&nbsp; The DSKY measured 8.124"×8.000×6.91"
        (21.635×20.320×17.551 cm) and weighed 17.8 pounds (8.1
        kg).&nbsp; (Since you may see slightly-different approximate
        figures floating around elsewhere, I'll just note that the
        dimensions quoted here are from the Apollo 11 Lunar Module
        original engineering drawings <a moz-do-not-send="true"
href="https://archive.org/details/AgcApertureCardsBatch2Images/page/n281/mode/1up?view=theater">for
          the AGC</a> and <a moz-do-not-send="true"
href="https://archive.org/details/apertureCardBox459NARASW_images/apertureCardBox459NARASW/page/n566/mode/1up?view=theater">for
          the DSKY</a>, while the weights are from <a
          moz-do-not-send="true" href="Documents/E1142-59.pdf#page=8">the
          so-called weight &amp; balance report</a>.)&nbsp; <br>
      </li>
      <li>The CPU had a&nbsp; memory cycling time (MCT) of 11.7
        microseconds. The modern reader, reading this, probably imagines
        that by "CPU" we are referring to a single integrated circuit
        (or "chip").&nbsp; In fact, integrated circuits were too new and
        too risky (as well as too expensive) at that time to be
        used.&nbsp; At some point, a few integrated circuits were added
        to act as "flip-flops" for some of the CPU registers; but the
        CPU itself was not, by any stretch of the imagination, an
        integrated circuit.&nbsp; The instruction timing varies from 1
        MCT up to 6 MCT, but most instructions execute in 2 MCT. The
        11.7&nbsp; microsecond cycle is subdivided at the hardware level
        into 12 shorter time-periods derived from a 1024 KHz clock.
        However, for the purpose of the <span style="font-weight:
          bold;">yaAGC</span> simulation, only the basic 11.7
        microsecond cycle-time is of interest.The instruction set of the
        AGC is apparently implemented as a kind of microcode, and the
        microcode instructions are executed in the 12 subdivisions of
        the clock cycle. Since the microcode and the hidden register set
        it uses are not accessible to programmers, I've not bothered to
        carry the simulation down to the microcode level. However,
        examining the microcode is useful in understanding the detailed
        workings of some of the assembly-language operations.</li>
      <li>Memory and registers are 16 bits, consisting of 15 bits of
        data, plus one bit of odd parity (used for detection of memory
        errors). The parity bit is not simulated by <span
          style="font-weight: bold;">yaAGC</span>.<br>
      </li>
      <li>Fixed memory—i.e., memory which cannot be modified at runtime,
        for program code, constants, and so forth. There are 38912
        15-bit words of ROM at addresses 4000-117777 (octal). This ROM
        was implemented not in integrated circuits, but in "core"
        memory—consisting of many small doughnuts of Permalloy wire threaded
        into a braid of extremely fine wires. This made the cost of
        program changes very high, since changes could only be
        incorporated by having Raytheon Corp. rebuild the core-memory
        assembly.&nbsp; Each of the cores could encode as many as 64
        bits of memory, since 64 wires could be threaded through each
        core, so that even though over 600,000 bits needed to be coded,
        less than 10,000 cores were used.&nbsp; A small portion of the
        core rope is seen below.</li>
      <li>Erasable memory—i.e., memory which can be modified at runtime.
        There are 2048&nbsp; 15-bit words of erasable memory at
        addresses 0-3777 (octal). Locations 0-17 (octal)&nbsp;
        correspond to what might be thought of as CPU registers, while
        20-57 (octal)&nbsp; are "counters", and 60-3777 (octal)&nbsp;
        are general-purpose RAM.&nbsp; The erasable memory was
        implemented by means of ferromagnetic cores, but not the same as
        the core-rope seen at the right.<br>
      </li>
      <li>Memory banks. It is important to note that while erasable and
        fixed memory formed a space of continous memory, logically
        addressed from 0-117777 (octal), that 16 addressing bits are
        needed but that no register in the AGC (including the
        program-counter) is 16-bits wide. To get around this problem,
        extra addressing bits are taken from special bank-selection
        registers and combined with the program counter or with
        addresses embedded within program instructions to provide full
        16-bit addresses.</li>
      <li>I/O channels. There were potentially 512 i/o ports with
        "channel numbers" from 0-777 (octal). Some few of the i/o
        channels correspond to erasable-memory locations.&nbsp; The
        others were used to address peripheral devices (such as the
        DSKY) for telemetry uplink/downlink, and so on.</li>
    </ul>
    <table summary="" style="text-align: left; margin-left: auto;
      margin-right: auto;" cellspacing="2" cellpadding="2" border="0">
      <tbody>
        <tr>
          <td style="vertical-align: top; text-align: center;"> <a
              href="yaAGC-core-big.jpg"><img src="yaAGC-core.jpg"
                title="Photograph of core-rope. Click to enlarge."
                alt="Photograph of core-rope" style="border: 2px solid ;
                width: 200px; height: 160px;" width="200" vspace="5"
                hspace="10" height="160"></a><br>
            <div style="text-align: left;"> <span style="font-style:
                italic;">A small section of the cores in the
                "core rope" non-volatile memory of the AGC.&nbsp; (The
                photo was taken from the web; it was credited to
                Raytheon Corp.)</span><br>
            </div>
          </td>
          <td style="vertical-align: top; text-align: center;"> <a
              href="AgcModuleCompartment.jpg"><img style="border: 2px
                solid ; width: 246px; height: 155px;" alt="Click to
                enlarge." src="thumbnail-AgcModuleCompartment.jpg"
                width="246" height="155"></a><br>
            <div style="text-align: left;"> <span style="font-style:
                italic;">Logic modules, plugged into a backplane.&nbsp;
                Though you cannot tell it from this photo, if the
                modules were disassembled, you would see that they are
                of "welded cordwood" construction.&nbsp; What that means
                is that the modules are full of cylindrical holes, like
                swiss cheese; the electrical components, such a
                resistors, slide into these holes, and their leads
                protrude from either side of the module.&nbsp; Wires are
                welded</span>—<span style="font-style: italic;">not
                soldered</span>—<span style="font-style: italic;">onto
                the leads to interconnect the components.&nbsp; (Photo
                by Stephan Hotto, taken at the Computer History Museum
                in Mountain View, California.)</span> </div>
          </td>
          <td style="vertical-align: top; text-align: center;"> <a
              href="AgcWirewrappedBackplane.jpg"><img style="border: 2px
                solid ; width: 268px; height: 143px;" alt="Click to
                enlarge" src="thumb-AgcWirewrappedBackplane.jpg"
                width="268" height="143"></a><br>
            <div style="text-align: left;"> <span style="font-style:
                italic;">The backplane the logic and memory
                modules&nbsp; which the logic and memory modules plug
                into.&nbsp; Notice that it is wire-wrapped.&nbsp; Even
                the production models were wire-wrapped, and not just
                the engineering models.&nbsp; </span><span
                style="font-style: italic;">(Photo by Stephan Hotto,
                taken at the Computer History Museum in Mountain View,
                California.)</span> </div>
          </td>
        </tr>
      </tbody>
    </table>
    <h2>Invoking yaAGC</h2>
    <span style="font-weight: bold;">yaAGC</span> is a command-line
    program that requires no user interaction once started.&nbsp; The
    syntax is<br>
    <br>
    <div style="text-align: center;"> <span style="font-family:
        monospace;">yaAGC [OPTIONS] --core=</span><span
        style="font-style: italic; font-family: monospace;">BinaryExecutable</span><br>
    </div>
    <br>
    The <span style="font-style: italic;">BinaryExecutable</span> will
    be the name of a file containing an AGC core-rope binary image,
    either <a href="download.html">downloaded</a> or else assembled
    from <a href="Luminary.html">Luminary</a> or <a
      href="Colossus.html">Colossus</a> source code using <a
      href="yaYUL.html">yaYUL</a>.&nbsp; If a complete pathname for <span
      style="font-style: italic;">BinaryExecutable</span> is not
    specified, then <span style="font-weight: bold;">yaAGC</span> will
    look first in the current directory, and then (for software versions
    05/06/2004 or later) in the installation directory (which is
    /usr/local/bin by default, but which may be changed when <span
      style="font-weight: bold;">yaAGC</span> is built).&nbsp; <br>
    <br>
    I'm not certain the debugging options described below are up-to-date
    (<a href="#Debugging">see the debugging section</a> instead), but
    the other currently-defined options are:<br>
    <br>
    --help<br>
    <div style="margin-left: 40px;"> Displays a list of options (such as
      this one) and then quits.<br>
      <br>
    </div>
    --port=<span style="font-style: italic;">Portnum</span><br>
    <div style="margin-left: 40px;"> The <span style="font-weight:
        bold;">yaAGC</span> program and programs simulating peripheral
      devices (such as <span style="font-weight: bold;">yaDSKY)</span>
      have a server/client relationship.&nbsp; <span
        style="font-weight: bold;">yaAGC</span> listens on a set of
      ports (by default, 19697 through 19706) for client
      connection-requests.&nbsp; The base (lowest) port number can be
      changed using the "--port" command-line switch.&nbsp; (The number
      of ports scanned remains 10, however.&nbsp; To change the number
      of scanned ports requires changing <span style="font-weight:
        bold;">yaAGC</span>'s source code and recompiling the
      program.)&nbsp; One might wish to change the base port if, for
      example, simultaneously running an instance of <span
        style="font-weight: bold;">yaAGC</span> for the CM and another
      instance of <span style="font-weight: bold;">yaAGC</span> for the
      LM.&nbsp; The port ranges of the two instances of <span
        style="font-weight: bold;">yaAGC</span> shouldn't overlap, so
      one instance could be run (for example) with the command-line
      switch "--port=19707".<br>
      <br>
    </div>
    --debug-dsky<br>
    <div style="margin-left: 40px;"> This setting is useful for
      debugging a DSKY simulation (such as <span style="font-weight:
        bold;">yaDSKY</span>).&nbsp; This switch causes the "--core"
      setting to be ignored (in fact, the "--core" switch can be
      omitted).&nbsp; Instead of running an AGC executable, <span
        style="font-weight: bold;">yaAGC</span> simply echoes command
      sequences back to the DSKY upon receiving keystrokes from the
      DSKY.&nbsp; These command sequences are defined in the
      configuration file (see "--cfg" below), and can actually relate to
      any peripheral devices (not just the DSKY).<br>
      <br>
    </div>
    --debug-deda<br>
    <div style="margin-left: 40px;"> This setting is useful for
      debugging a DEDA simulation (such as <span style="font-weight:
        bold;">yaDEDA</span>).&nbsp; Unlike --debug-dsky, <span
        style="font-weight: bold;">yaAGC</span> runs the AGC simulation
      as normal.&nbsp; But in addition, it interprets communications
      from <span style="font-weight: bold;">yaDEDA</span>.&nbsp; (In
      normal operation, of course, it completely ignores data
      originating from <span style="font-weight: bold;">yaDEDA</span>,
      or indeed any other messages in <span style="font-weight: bold;">yaAGS</span>
      format.)&nbsp; For each communication received from <span
        style="font-weight: bold;">yaDEDA</span> (for key sequences such
      as CLR-<span style="font-style: italic;">OctalDigit-OctalDigit-OctalDigit</span>-READOUT)
it


      prints out a message indicating what was received.&nbsp; For the
      specific key sequence just mentioned, it goes further and acts
      similarly to the AEA software, in that it interprets the 3 octal
      digits as an address in erasable memory, and outputs the value
      found at that address (in octal) every 1/2 second to <span
        style="font-weight: bold;">yaDEDA</span>.&nbsp; The addresses
      most meaningfully observed in this fashion are timer registers
      like 25 (octal) which increment at 10 ms. intervals, and therefore
      increments by about 50 (62 octal) every 1/2 second.<br>
    </div>
    <br>
    --deda-quiet<br>
    <div style="margin-left: 40px;"> This setting is used in conjunction
      with --debug-deda to eliminate the outputs from <span
        style="font-weight: bold;">yaAGC</span> to <span
        style="font-weight: bold;">yaDEDA</span> which --debug-deda
      normally creates.&nbsp; In other words, lets <span
        style="font-weight: bold;">yaAGC</span> parse the messages being
      received from <span style="font-weight: bold;">yaDEDA</span>, but
      never to send any itself.<br>
    </div>
    <br>
    --cfg=<span style="font-style: italic;">Filename</span><br>
    <div style="margin-left: 40px;"> This presently has no effect unless
      used with "--debug-dsky".&nbsp; It causes a configuration file to
      be loaded which defines the command sequences used in --debug-dsky
      mode.&nbsp; The same directory assumptions are used in searching
      for the file as are used with the --core switch (see above).&nbsp;
      Full instructions can be found within the provided sample
      files&nbsp; (presently LM.ini, CM.ini, LM1.ini, and
      CM0.ini).&nbsp; The configuration files are really provided for
      use with the <span style="font-weight: bold;">yaDSKY</span>
      program, and the same file should be selected for <span
        style="font-weight: bold;">yaAGC</span> as is selected for <span
        style="font-weight: bold;">yaDSKY</span> (if --debug-dsky is
      going to be used).&nbsp;&nbsp; Only the "DEBUG" lines within the
      configuration files are relevant to <span style="font-weight:
        bold;">yaAGC</span>.&nbsp; If no configuration file is selected,
      or if no DEBUG lines appear within the configuration file, then
      --debug-dsky will be non-functional.<br>
    </div>
    <br>
    --debug<br>
    <div style="margin-left: 40px;"> Causes the AGC program to halt
      prior to executing its first instruction, and activates a
      debugging mode (very primitive) in which you can do things like
      examine AGC registers, single-step through the AGC program,
      etc.&nbsp; This mode is described further <a href="#Debugging">below</a>.&nbsp;&nbsp;
In


      Linux (though not necessarily in *BSD, MacOS X, or Win32), you can
      put <span style="font-weight: bold;">yaAGC</span> into debug mode
      without the --debug switch, simply by hitting the carriage-return
      key any time after starting the program; the AGC program will
      simply be halted wherever it is, and you can begin debugging at
      that point.<br>
      <br>
    </div>
    --symtab=<span style="font-style: italic;">Filename</span><br>
    <div style="margin-left: 40px;"> For versions 20050728 and later, <span
        style="font-weight: bold;">yaYUL</span> outputs symbol-table
      information that <span style="font-weight: bold;">yaAGC</span>
      can use in "--debug" mode to aid symbolic debugging.&nbsp; In
      other words, if you load a symbol table into <span
        style="font-weight: bold;">yaAGC</span>, then in debug-mode you
      can sometimes use program labels and variable names rather than
      having to know the absolute numerical addresses for
      everything.&nbsp; The --symtab switch is used to specify the name
      of the symbol-table file.&nbsp; The same search path is used as
      for --core and --cfg.&nbsp; Since the symbol tables for
      Luminary131 and Colossus249 (namely, Luminary131.symtab and
      Colossus249.symtab) are "installed" along with the executables,
      you can simply say "--symtab=Luminary131.symtab" or
      "--symtab=Colossus249.symtab".&nbsp; However, if you want to
      assemble your own AGC source code, the symbol table output by <span
        style="font-weight: bold;">yaYUL</span> will be named the same
      as your source file, but with ".symtab" suffixed to it.&nbsp; For
      example, if you assemble "MyFile.s", then the symbol table will be
      "MyFile.s.symtab".&nbsp; In this case, you'll want to use the
      complete pathname for the symbol-table as the filename for
      --symtab.&nbsp; This feature, and all of the debugging commands
      associated with it are courtesy of Jordan Slott.&nbsp; (Thanks,
      Jordan.)<br>
    </div>
    <br>
    <a name="Resume" id="Resume"></a>--resume=<span style="font-style:
      italic;">Filename</span><br>
    <div style="margin-left: 40px;"> Normally when the emulator runs an
      AGC program it sets all i/o channels, erasable memory, and hidden
      CPU state variables to what it considers reasonable power-up
      defaults.&nbsp; (But see "--dump-time", below.)&nbsp; The --resume
      option instead allows these items to be loaded from a
      previously-created file.&nbsp; (The file itself is created from
      --debug mode using the COREDUMP command as explained below.)&nbsp;
      In effect, this allows execution to continue from the exact point
      in the AGC program at which the COREDUMP was made, rather than
      forcing the AGC program to its reset condition.&nbsp; The file
      must be either in the current directory, or else a full pathname
      must be given for it.<br>
      <br>
    </div>
    --dump-time=<span style="font-style: italic;">N</span><br>
    <div style="margin-left: 40px;"> For versions 20050705 and later, <span
        style="font-weight: bold;">yaAGC</span> attempts to save the
      contents of erasable memory, and to restore them automatically at
      startup (but not i/o channels and hidden CPU state
      variables).&nbsp; This means that things like pad loads are
      preserved even when the AGC is "powered down", just as they would
      have been in the true AGC's core memory.&nbsp; In an
      effort to keep this from increasing system overhead too much, the
      saving is actually done only every <span style="font-style:
        italic;">N</span> seconds (10, by default).&nbsp; The data is
      saved either in a file called LM.core or CM.core, and is
      compatible with the "core dumps" described above for the
      "--resume" switch.&nbsp; You can start with a clean system by
      erasing LM.core or CM.core.&nbsp; Or, you can use
      "--resume=LM.core" or "--resume=CM.core" if you'd like to restore
      more than just the erasable memory.&nbsp; Because separate files
      are used for the LM and CM, you can run both simulations at once
      without any conflict.&nbsp; However, if you want to run more than
      one LM simulation (or more than one CM simulation), you'd better
      start them from different directories, to make sure that the .core
      files are stored in different directories.<br>
    </div>
    <div style="margin-left: 40px;"> <br>
    </div>
    --interlace=<span style="font-style: italic;">N</span><br>
    <div style="margin-left: 40px;"> On some PC's the act of checking
      the socket connections (i.e., the mechanism used by <span
        style="font-weight: bold;">yaAGC</span> to communicate with <span
        style="font-weight: bold;">yaDSKY</span> and/or other peripheral
      devices) can make the simulation very sluggish.&nbsp; Therefore <span
        style="font-weight: bold;">yaAGC</span> only performs this check
      every <span style="font-style: italic;">N</span>-th CPU
      instruction, where by default <span style="font-style: italic;">N</span>=50.&nbsp;
Changing


      the value of <span style="font-style: italic;">N</span> does not
      affect the reliability of the communication (i.e., no data is
      lost).&nbsp; Making <span style="font-style: italic;">N</span>
      smaller theoretically improves the responsiveness of the system,
      except on slow PC's where the overhead from checking the sockets
      may exceed the computing time taken by the simulation.&nbsp; For
      example, a value of <span style="font-style: italic;">N</span>=1
      works fine on my ~2.5 GHz P4 Linux and Windows XP systems, but
      results in about a 10-to-1 slowdown of the simulation on my 450
      MHz P2 Windows 98 system.&nbsp; On the latter system, a value of <span
        style="font-style: italic;">N</span>=10 seems to work
      perfectly.&nbsp; Conversely, increasing <span style="font-style:
        italic;">N</span> reduces the overhead, but results in a larger
      time-jitter in signalling, and (in theory) for large enough values
      a steadily-increasing backlog of data waiting to be
      delivered.&nbsp; As far as time-jitter is concerned, it's
      important to realize that <span style="font-weight: bold;">yaAGC</span>
      does not actually execute a machine cycle every 11.7 microseconds,
      but merely keeps up appearances of doing so in a way not
      detectable by the user.&nbsp; Therefore, there is a pretty large
      time-jitter anyway, and the amount of jitter is dependent on both
      the speed of the PC and on the operating system used by the
      PC.&nbsp; The value <span style="font-style: italic;">N</span>=50
      has been chosen in the belief that it will work well for most
      PC's, and does work well on all of the example systems mentioned
      above.&nbsp; (On my 150 MHz P1, on the other hand, the simulation
      runs about 50% slow no matter what the setting of
      --interlace.)&nbsp; Nevertheless, the --interlace switch may be of
      value when fine-tuning of the timing is required.<br>
    </div>
    <br>
    --cdu-log<br>
    <div style="margin-left: 40px;"> Used only for debugging.&nbsp;
      Causes a file called yaAGC.cdulog to be created, containing data
      related to the bandwidth-limiting of CDU inputs PCDU and MCDU.<br>
    </div>
    <h2>Verification of yaAGC Correctness<br>
    </h2>
    We're very lucky in this regard, in that I can provide pretty
    confident assurance that <b>yaAGC</b> does execute AGC code
    correctly.<br>
    <br>
    How can I make such a bold statement?&nbsp; Well, for the first 10
    years of the Virtual AGC project, I couldn't really have done so
    with any confidence ... and would have been overreaching if I had
    done so.&nbsp; Some things worked, and some didn't.&nbsp; Although
    to be fair, many things that "didn't work" actually worked well
    enough and couldn't have produced any errors, and were usually very
    obscure anyway.&nbsp; But I couldn't guarantee it.&nbsp; The problem
    was basically that there was no way to compare the behavior of <b>yaAGC</b>
    vs a real AGC, plus the fact that while the original AGC software
    had contained self-test code, almost all of that self-test code had
    been removed by the time of <b>Luminary</b> and <b>Colossus</b> in
    order to save precious memory.&nbsp; In other words, we didn't <i>have</i>
    any of the test code.<br>
    <br>
    However, there was a textual description of the test code in one of
    the original Apollo documents, "Block II AGC Self-Check and
    Show-Banksum" by Edwin Smally.&nbsp; Smally's described tests give
    the CPU a pretty rigorous (if not 100% complete) going-over.&nbsp;
    So I went through Smally's document in detail, and wrote an AGC
    program myself that performed each of his tests, as well as other
    tests that seemed reasonable to me from other available
    documents.&nbsp; I called this the <b>Validation</b> test suite and
    corrected yaAGC until it could pass the <b>Validation</b> testing.<br>
    <br>
    But however helpful, that falls far short of a 100% guarantee of
    completely correct operation, even though I had to content myself
    with having done as much as I could.<br>
    <br>
    That's all changed now.<br>
    <br>
    What has changed?&nbsp; Two things.&nbsp; First, we eventually
    acquired an early AGC program called <b>AURORA</b> from the
    collection of the original AGC developer Don Eyles.&nbsp; <b>AURORA</b>
    is old enough that it actually still contains the full built-in test
    software.&nbsp; In fact, it is the last such software to contain the
    full self-test, and was itself used back during the original Project
    Apollo to perform acceptance tests on AGCs.&nbsp; Second, the
    electrical schematics of the Block II AGC, or at least a large
    enough subset of those schematics, had eventually become available,
    and people began to be interested in building cloned AGC hardware
    from those schematics.&nbsp; One such person was developer Mike
    Stewart.&nbsp; Mike transcribed those schematics into CAD form, and
    from there transformed the electrical design into the Verilog
    programming language with two aims: a) to simulate the AGC
    electrical design using a Verilog simulator; and b) once the design
    was fully debugged, to create his own hardware AGC by creating FPGAs
    from the Verilog description.&nbsp; The Verilog simulation is very
    complete, and able to run actual AGC source code ... which of
    course, we had!&nbsp;&nbsp; Mike compared the Verilog simulation of
    the vs the behavior of <b>yaAGC</b> and found discrepancies ...
    i.e., bugs.&nbsp; Then he fixed those bugs, either in his CAD
    transcription or else in <b>yaAGC</b>, depending on where the
    discrepancies came from.&nbsp; <br>
    <br>
    In case you wonder just how much detail we're talking about,
    consider the case of the AGC's <tt>DV</tt> (divide)
    instruction.&nbsp; <tt>DV</tt> operates on two numbers which it
    interprets as being between 0.0 and 1.0.&nbsp; It <i>requires</i>
    that the divisor be greater than or equal to the dividend in
    absolute value, and we are told by one document that if the divisor
    is actually greater than the dividend then "we get total
    nonsense".&nbsp; Mike didn't mind the result being "total nonsense",
    but he wanted yaAGC and the Verilog simulation to give exactly the <i>same</i>
    bit patterns of "total nonsense".&nbsp; Now in practice, it simply
    doesn't matter, since the AGC code was written in such a way that
    the conditions were always met, so no nonsense could occur
    anyway.&nbsp; But Mike worked hard, and eventually the total
    nonsense matched.&nbsp; And he did that with everything, not just
    with <tt>DV</tt>.&nbsp; Great work, Mike!<br>
    <br>
    The end result of Mike's efforts is thus that we have two
    independently-developed implementations of the AGC, namely <b>yaAGC</b>
    and the Verilog description of the AGC's electrical schematics,
    which not only agree with each other, but which can pass the full
    built-in-test suite in <b>AURORA</b>.&nbsp; I'm happy to interpret
    that as meaning that <b>yaAGC</b> works correctly now.<br>
    <h2><a name="Debugging" id="Debugging"></a>Debugging Mode</h2>
    The debugging capabilities of <b>yaAGC</b> have completely changed
    over time.&nbsp; My original debugging features are no longer
    supported, as of mid-2009.&nbsp; The best place to read about the
    debugging features now is in the wiki for our GitHub
    repository:&nbsp; <br>
    <ul>
      <li><a
href="https://github.com/virtualagc/virtualagc/wiki/DevelopmentWithCodeBlocks">Development


          with Code::Blocks</a><br>
      </li>
      <li><a
          href="https://github.com/virtualagc/virtualagc/wiki/VisualDebugging">Visual


          Debugging</a><br>
      </li>
    </ul>
    <br>
    <hr style="width: 100%; height: 2px;">
    <center> <br>
      <span style="color: rgb(84, 89, 93); font-family: sans-serif;
        font-size: 11.05px; font-style: normal; font-variant: normal;
        font-weight: normal; letter-spacing: normal; line-height:
        16.575px; orphans: auto; text-align: center; text-indent: 0px;
        text-transform: none; white-space: normal; widows: 1;
        word-spacing: 0px; -webkit-text-stroke-width: 0px; display:
        inline !important; float: none; background-color: rgb(255, 255,
        255);"> This page is available under the <a
          href="https://creativecommons.org/publicdomain/zero/1.0/">Creative
Commons


          No Rights Reserved License</a></span><br>
      <i><font size="-1">Last modified by <a
            href="mailto:info@sandroid.org">Ronald Burkey</a> on
          2022-10-27.<br>
          <br>
          <a href="http://www.ibiblio.org"><img style="border: 0px solid
              ; width: 300px; height: 100px;" alt="Virtual AGC is hosted
              by ibiblio.org" src="hosted.png" width="300" height="100"></a><br>
        </font></i> </center>
    <br>
  </body>
</html>
