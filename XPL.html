<!DOCTYPE doctype PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
    
<title>Virtual AGC Document Library Page</title>


    
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">


    
<meta name="Author" content="Ronald Burkey">


    
<link rel="icon" type="image/png" href="favicon.png">


    
<meta name="author" content="Ronald S. Burkey">


    
<script type="text/javascript" src="Header.js"></script>
  </head>
  <body style="background-image: url(gray3.jpg);">
    
<script type="text/javascript">
document.write(headerTemplate.replace("@TITLE@","Space Shuttle").replace("@SUBTITLE@","XPL/I Compiler XCOM-I"))
</script><br>


    
<div align="center"><i>(This page is under construction.)</i><br>
    </div>


    
<h1>Table of Contents </h1>


    
<ul>


      <li><a moz-do-not-send="true" href="#Introduction">Introduction to XPL/I</a></li>
<li><a moz-do-not-send="true" href="#compiling">Processing a Program Written in XPL, Using <b>XCOM-I</b>
</a></li>
<ul>
  <li><a moz-do-not-send="true" href="#installation">Installation of <b>XCOM-I</b></a></li>
  <li><a moz-do-not-send="true" href="#xpl">Compiling and Running XPL Programs</a></li>
<li><a moz-do-not-send="true" href="halsfc">Compiling and Running HAL/S-FC</a><br></li>
</ul>
<li><a moz-do-not-send="true" href="#xpli">A Primer for Standard XPL and Intermetrics XPL/I</a></li>
<li><a moz-do-not-send="true" href="#debugging">Debugging XPL Programs </a><br></li>

<ul>

  
</ul>

<li><a moz-do-not-send="true" href="#hooks">Patches for Basic Assembly Language Code</a>
</li>
</ul>


    
<h1><a name="Introduction"></a>Introduction to XPL/I<br>
</h1>XPL used to be a computer language (<a moz-do-not-send="true" href="https://en.wikipedia.org/wiki/XPL">see the Wikipedia article</a>) in the 1960's and 1970's that was defined by a book called <i>A Compiler Generator</i>,
 by William M. McKeeman, James J. Horning, and David B. Wortman.&nbsp; 
Today, the language is deader than ancient Sumerian.&nbsp; The 
internals of the language relied heavily on the fact that the compiled 
XPL 
programs would run on IBM System/360 mainframes.&nbsp; Indeed, the 
preface to the book explicitly states that they were creating a language
 specifically for the IBM 360.&nbsp; While you can 
write an XPL compiler that will run on a different type of computer 
system, or that would cross-compile program programs that will run on a 
different kind of 
computer system, doing so in a way that such programs, as-is, would 
produce the same results as they would have on an IBM 360 is 
problematic. Perhaps worse, the book <i>remains</i> the sole documentation for the standard
 XPL language, and is available neither for free, nor in digital form 
online.&nbsp; For brevity, I'll refer to that book from now on simply as
 <i>McKeeman</i>.<br>
<br>
Keep in mind that the Virtual AGC Project is devoted to onboard guidance
 
software used aboard space vehicles such as those of the Apollo and 
Space Shuttle projects, thus most of what I have to say on the topic of 
XPL is from that point of view.&nbsp; But that doesn't mean it isn't 
applicable more generally as well.&nbsp; For the purpose of thinking 
about XPL, 
what you need to know to follow the discussion herein is this:<br>
<ul>
  <li>Flight software for the Space Shuttle was primarily written in a computer language called <i>HAL/S</i>, created by Intermetrics, Inc.&nbsp; That flight software was called <i>PASS</i>, and that's what I'll refer to it as from now on.<br></li>
  <li>To compile PASS source code, you therefore need a compiler for 
HAL/S, and more-specifically for Intermetrics's specific variation of 
HAL/S.&nbsp; Intermetrics's HAL/S compiler, called <b>HAL/S-FC</b>, was primarily written in a language that the Intermetrics team <i>called</i> "XPL".</li>
  <li>Thus to compile the original compiler for PASS, you first need a compiler for what Intermetric referred to as XPL.<br></li>
</ul>
Well, that's certainly a mouthful of words!&nbsp; On takeaway is that 
having an XPL compiler is just one item — though an important one! —  in
 a 
chain of things that are helpful in the process of 
resurrecting PASS for modern audiences. <br>
<br>
Alas, it's even a bit more complicated than what I just said.&nbsp; For 
one thing, as you may have gathered from my wording above, Intermetrics did not write its HAL/S compiler in <i>standard</i>
 XPL as defined by McKeeman.&nbsp; Rather, they extended the language 
with new features, occasionally changing the existing features in an 
incompatible way.&nbsp; From now on, I'll
 refer to Intermetrics's variant of XPL as <i>XPL/I</i> to distinguish it from the standard.&nbsp; <br>
<blockquote><b><font size="-1">Aside:</font></b><font size="-1">&nbsp; 
And in case you're wondering, there is no known surviving copy of 
Intermetrics's own XPL/I compiler.&nbsp; In fact, there is reason to 
believe that it was intentionally destroyed.&nbsp; (Prove me wrong, 
please!)&nbsp; If it had survived, however, it would presumably have 
been written in standard XPL and itself compiled by McKeeman's XPL 
compiler (which was called <b>XCOM</b>).</font><br>
</blockquote>


Even if you actually had a perfect compiler for standard XPL that you 
could
 use on (say) a Windows, Mac OS, or Linux computer, it would most likely
 neither 
compile most XPL/I programs, nor would most of those compiled programs 
run correctly afterwards if you were able to do so.&nbsp; But frankly, 
even having such a hypothetical perfect compiler for standard XPL is 
somewhat of a trick, due to the dependence on the underlying IBM 360 
that's non-existent in Windows, Mac OS, and Linux.<br>
<br>
Consider the 
following brief example of a program:<br>
<blockquote>
  <pre><font color="#663333">declare x fixed, y fixed, z fixed;<br>x(0) = 1;<br>x(1) = 2;<br>x(2) = 3;<br>output = x(0) || ' ' || x(1) || ' ' || x(2);<br></font><font color="#663333">output = x || ' ' || y || ' ' || z;</font><br></pre>
</blockquote>
What is this little example supposed to do?&nbsp; First, it declares 3 variables of the <font color="#663333"><code>fixed</code></font> datatype; <font color="#663333"><code>fixed</code></font> means that <font color="#663333"><code>x</code></font>, <font color="#663333"><code>y</code></font>, and <font color="#663333"><code>z</code></font> are 32-bit signed integers.&nbsp; It then proceeds to use <font color="#663333"><code>x</code></font>
 <i>as if</i> it were a three-element array, though <font color="#663333"><code>x</code></font> wasn't declared that 
way, assigning values to each of its elements.&nbsp; The program simply assumes that <font color="#663333"><code>x(0)</code></font> corresponds to <font color="#663333"><code>x</code></font>, <font color="#663333"><code>x(1)</code></font> corresponds to <font color="#663333"><code>y</code></font>, and <font color="#663333"><code>x(2)</code></font> corresponds to <font color="#663333"><code>z</code></font>.&nbsp; Finally, the program "prints out" both the elements of <font color="#663333"><code>x</code></font> (as an array) and the values of <font color="#663333"><code>x</code></font> (as a non-array), <font color="#663333"><code>y</code></font>, and <font color="#663333"><code>z</code></font>.&nbsp; Naturally, those two lines of printout are identical.&nbsp; In case you're wondering, we <i>could</i> have used <font color="#663300"><code>z(-1)</code></font> as an equivalent to <font color="#663300"><code>y</code></font>, or <font color="#663300"><code>z(-2)</code></font> as <font color="#663300"><code>x</code></font>.&nbsp; For that matter, we could have used this feature to read or write areas of memory in which no 
variables at all had been declared.&nbsp; Or to a certain extent, if we had declared 
variables of some other datatype than <font color="#663333"><code>FIXED</code></font>, we could have used this same trick to access them as if they were <font color="#663333"><code>FIXED</code></font>.<br>
<br>
I call this particular "feature" of XPL <i>subscripting sloppiness</i>.&nbsp;
 It's one of the many features of XPL that is simply undocumented and 
which you are left to deduce by examining actual XPL code or by trying 
to figure out why your apparently-perfectly-formed XPL code produces 
entirely unexpected results when executed.<br>

<blockquote>
  <font size="-1"><b>Aside:</b> I say that subcripting sloppiness is 
"undocumented", but you could find passing hints to it in McKeenan if 
you already knew in advance about this feature by other means.&nbsp; 
True, McKeeman does say that array bounds are respected, which is false,
 but it does also say on p. 137 of McKeeman:&nbsp; "Assignments to 
subscripted variables are not checked against the array bounds; thus 
every memory location is accessible through subscripting."&nbsp; And if 
you pore through every line of XPL source code in the book, you'll 
certainly come across examples of subscripting sloppiness.&nbsp; Is that
 "documentation" of such a major feature?&nbsp; You be the judge.</font><br>

</blockquote>
<blockquote><font size="-1"><b>Aside:</b>&nbsp; <a moz-do-not-send="true" href="https://sourceforge.net/projects/xpl-compiler/">Daniel 
Weaver has written an XPL-to-C translator</a>.&nbsp; 
The first thing anyone suggests to me when this topic is discussed is 
"Why don't you just use it?"&nbsp; The subscripting sloppiness inherent 
in 
actual usage of XPL is one good reason.&nbsp; As you might expect, 
since there's no reasonable way to deduce from the documentation that 
subscripting sloppiness exists, there's reason to doubt that an XPL 
compiler relying on the accuracy of McKeeman might not support it. 
Here's a fun printout of the very-sensible error messages you get by 
running the sample code above through Dan's translator :<br>
  </font>
  <blockquote>
    <pre><font size="-1">XPL to C language translator -- version 1.1<br>2    |x(0) = 1;                                                                       |<br>           |<br>*** Error, Identifier is not an array (detected at line 5741 in xcom). ***<br>3    |x(1) = 2;                                                                       |<br>           |<br>*** Error, Identifier is not an array (detected at line 5741 in xcom). ***<br>*** Last previous error was detected on line 2. ***<br>4    |x(2) = 3;                                                                       |<br>           |<br>*** Error, Identifier is not an array (detected at line 5741 in xcom). ***<br>*** Last previous error was detected on line 3. ***<br>5    |output = x(0) || ' ' || x(1) || ' ' || x(2);                                    |<br>                    |<br>*** Error, Identifier is not an array (detected at line 5741 in xcom). ***<br>*** Last previous error was detected on line 4. ***<br>5    |output = x(0) || ' ' || x(1) || ' ' || x(2);                                    |<br>                                   |<br>*** Error, Identifier is not an array (detected at line 5741 in xcom). ***<br>*** Last previous error was detected on line 5. ***<br>5    |output = x(0) || ' ' || x(1) || ' ' || x(2);                                    |<br>                                                 |<br>*** Error, Identifier is not an array (detected at line 5741 in xcom). ***<br>*** Last previous error was detected on line 5. ***<br>6 cards containing 7 statements were compiled.<br>6 errors (0 severe) were detected.<br>The last detected error was on line 5.</font><br></pre>
  </blockquote>
</blockquote>
<blockquote><font size="-1"><b>Aside:</b>&nbsp; Daniel has also pointed out that aside from his own compiler, <a moz-do-not-send="true" href="https://sourceforge.net/projects/intel-486-xpl-compiler/">Dave Bodenstab wrote an XPL compiler for FreeBSD, which Daniel himself has ported to Linux</a>.&nbsp; I have not tried it as of this writing.<br>
    <br>
    <b>Aside:</b>&nbsp; The other suggestion I receive with a fair 
degree of regularity is, "Why not just run all of this IBM 360 software 
in a simulator like <a moz-do-not-send="true" href="http://www.hercules-390.org/">Hercules</a>, and be done with it?&nbsp; Problem solved!"&nbsp; Well, for one thing, we don't have Intermetrics's XPL/I compiler, so we <i>can't</i>
 run it on an IBM 360 simulation.&nbsp; Lacking that, we can't build 
Intermetrics's HAL/S compiler in such a way that it could be run on an 
IBM 360 simulation.&nbsp; But if we had the HAL/S compiler and it could 
compile the PASS flight software to IBM 360 object code, why don't we 
just run <i>that</i> on an IBM 360 simulator?&nbsp; Well ... tell me how
 to integrate Hercules into a spacecraft simulator like Orbiter?&nbsp; 
And tell me how to motivate any of <i>you</i> to learn how to use 
Hercules in addition to the already very steep learning curve you face 
with the flight software?&nbsp; If you can answer those questions for 
me, I'll admit you've got a pretty good idea!&nbsp; With that said, 
there's definitely merit in emulating an IBM 360, if not necessarily 
emulating a full IBM 360 system.&nbsp;&nbsp; I'll come back to this 
point later<br>
  </font></blockquote>
From my whining above about the quality (from a user's point of view) of
 the documentation of the XPL language, you'll probably recognize that  
it's 
hard to make a full list of all the difficulties of XPL or all of the 
differences between XPL and XPL/I.&nbsp; And just as McKeeman is not a 
full and accurate description of XPL, neither is 
the surviving Intermetrics documentation a full description of 
XPL/I.&nbsp; And confusingly for the present discussion, Intermetrics 
did not use an explicit term (like "XPL/I") to refer to their 
language.&nbsp; Instead they continued to refer to it simply as "XPL", 
making it hard to be entirely sure what's supposed to be different 
between the two languages and what's not.&nbsp; <br>
<br>Taking all of this stuff into consideration, my conclusion is that if you want to compile
 Intermetrics's HAL/S compiler, you're not going to be able to rely on any <i>existing</i>
 XPL compiler.&nbsp; You're going to have to rely on a 
newly-written XPL compiler having support for the true (as opposed to 
documented) properties of XPL and XPL/I baked into it from the 
ground up.&nbsp; I call this new XPL+XPL/I compiler <b>XCOM-I</b>.&nbsp; (<b>XCOM</b>
 was the name of McKeeman's original XPL compiler, and I suspect of 
Intermetrics's compiler as well, while the "I" is for "Intermetrics".)<br>
<br>
Like Daniel Weaver's XPL translator, <b>XCOM-I</b> is actually an XPL/I-to-C translator, though it is entirely new and is 
not based on Daniel's work nor on any of the original XPL 
compilers. In most cases, <b>XCOM-I</b> should work for standard XPL programs too.<br>
<blockquote><font size="-1"><b>Aside:</b> In case you're wondering, <b>XCOM-I</b>
 does translate the sample XPL/I program given above to C without error;
 the C program it creates also compiles without errors; and if you run the compiled C 
program you get what you might expect:<br>
  </font>
  
<blockquote>
  <pre><font size="-1">PAGE 1<br><br><br>1 2 3<br>1 2 3</font><br></pre>
</blockquote>

</blockquote>
There's one final complication:&nbsp; In legacy XPL or XPL/I source 
code, it was typical to intersperse the XPL or XPL/I (thankfully, 
sparingly!) with code written in IBM 
System/360 Basic Assembly
 Language (BAL).&nbsp; Alas, <b>XCOM-I</b> cannot translate BAL into 
anything meaningful.&nbsp; But <b>XCOM-I</b> does provide hooks so that you can 
patch in replacement code, written in C, for the embedded BAL 
code.&nbsp; 
Those hooks will be discussed later on.<br>
<h1><a name="compiling"></a>Processing a Program Written in XPL, Using XCOM-I<br>
</h1>
<p>Despite the title of this section, there's actually little difference
 between how to build and run XPL/I programs than XPL programs.&nbsp; 
Once you know how to build and run an XPL program, you'll automatically 
know how to build and run an XPL/I program ... mostly.  There's an extra
 command-line switch you can use to specify that you really, truly want 
XPL rather than XPL/I, namely <font color="#663300"><code>--xpl</code></font>, but it usually doesn't matter much if you leave it out.<br></p>
<p>With that said, the XPL/I source code available to us dwarfs the XPL 
source code we have for any standard XPL programs we have.&nbsp; 
Moreover, those XPL/I programs are much larger and more complex than the
 XPL programs.&nbsp; This means that there are differences in how the 
source code for the two is organized and maintained.&nbsp; In that sense
 we find differences in how to deal with the two.&nbsp; That's why I 
concentrate at first on compiling standard XPL programs, and defer some 
discussion of XPL/I compilation until later.
</p>

<h2><a name="installation"></a>Installation of XCOM-I<br>
</h2><b>XCOM-I</b> is written in the Python 3 language.&nbsp; To install <b>XCOM-I</b> on your system, you simply need to copy <a moz-do-not-send="true" href="https://github.com/virtualagc/virtualagc/tree/master/XCOM-I">the folder called "XCOM-I" from the Virtual AGC software repository</a>
 onto your computer, and presumably add that directory to your PATH if it's not already there.&nbsp; Running <b>XCOM-I</b> requires Python 3.7 or later, but I don't think it requires additional 
installation of any Python modules not present in a normal Python 
distribution.&nbsp; <br>
<br>
Compiling the C programs created by running <b>XCOM-I</b> using the 
simplest variation of the instructions given below assumes that the GNU <b>gcc</b> C compiler and the GNU <b>make</b>
 program are also installed on your computer.&nbsp; Alternatives 
to those is possible, probably easily, and alternatives such as <b>clang</b> will be briefly discussed, 
but I 
have no way to personally survey every possible combination of 
development tools.&nbsp; If that's a problem, sorry!<br>
<h2><a name="xpl"></a>Compiling and Running XPL Programs<br>
</h2>
There are several standard XPL programs present in the folder 
XCOM-I/Tests/.&nbsp; It would be a mistake to think any of them are 
user-friendly.&nbsp; But they do illustrate the principles involved.<br>
<blockquote><font size="-1"><b>Aside:</b> You'd also be very mistaken to
 imagine that <b>XCOM-I</b> itself is user-friendly.&nbsp; I fear that there will be a
 lot of work involved — work which I may not even have the energy to perform —  before the error messages <b>XCOM-I</b> spits out upon 
occasion can be mistaken for anything <i>other</i> than mere spit.&nbsp; Until then, try not to make any errors in your XPL programming.</font><br>
</blockquote>

<blockquote><font size="-1"><b>Aside:</b>&nbsp; Throughout this 
discussion, I use the Linux/Mac convention that the symbol '/' is used 
to separate the components of a filename and the path to the folder 
containing it.&nbsp; Windows uses the separator '\' instead, so in some 
places you may find that you need to replace '/' by '\'.</font><br>

</blockquote>
<ul></ul>
<p>For the sake of discussion, suppose we wish to compile and run the 
sample program called Example-6.18.6.xpl.&nbsp; The first step is to use
 <b>XCOM-I</b> to translate Example-6.18.6.xpl into C source code:
</p>

<blockquote>
  <pre><font color="#663300">cd XCOM-I<br>XCOM-I.py Tests/Example-6.18.6.xpl<br></font></pre><font color="#663300">
</font></blockquote><font color="#663300">
</font>This will create a sub-folder called Example-6.18.6/ of the current
 working folder, and put all of the files of the C translation into that
 folder.&nbsp; <br>
<blockquote><font size="-1"><b>Aside:</b>&nbsp; XCOM-I.py has various 
allowable command-line options, though none were needed in the 
invocation shown above.&nbsp; You can see a list of XCOM-I.py's 
command-line options with
 the command "</font><code><font size="-1" color="#663300">XCOM-I.py --help</font></code><font size="-1">".</font><br>

</blockquote>
<blockquote>
</blockquote>
I won't bore you with a lengthy description of the C files output by <b>XCOM-I</b>, 
but it might be mildly instructive to glance briefly at a couple of 
them.&nbsp; For this example, the principal outputs are the files 
RANDOM.c and main.c, and here you can see a comparison of the original 
XPL file (left) to the C translation of them (right):<br>
<table align="center" cellspacing="40" cellpadding="2" border="1">
  <tbody>
    <tr>
      <td valign="middle">
        <pre><font color="#663300">/* This is example XPL program 6.18.6 from McKeeman p. 157.<br>   The book only provides PROCEDURE RANDOM, which is transcribed as-is.<br>   The top-level code that exercises RANDOM is new. */<br>   <br>RANDOM:<br>  procedure(range) fixed;<br>    /*  Returns a random integer in the range 0 to range - 1  */<br>    <br>    declare range fixed, rbase fixed initial(1),<br>      rmult literally '671297325';<br>      <br>    rbase = rbase * rmult;<br>    <br>    return shr(shr(rbase, 16) * range, 16);<br>    <br>  end RANDOM;<br><br>declare i;<br><br>do i = 1 to 100;<br>  output = RANDOM(100000);<br>end;<br><br>eof</font><br></pre>
      </td>
      <td valign="top">
        <pre><font color="#663300">/*<br>  File RANDOM.c generated by XCOM-I, 2024-04-16 08:46:47.<br>*/<br><br>#include "runtimeC.h"<br>#include "procedures.h"<br><br>int32_t<br>RANDOM(void)<br>{<br><br>  // rbase = rbase * rmult; (2)<br>  {<br>    int32_t numberRHS = xmultiply(getFIXED(8), 671297325);<br>    putFIXED(8, numberRHS);<br>  }<br>  // return shr(shr(rbase, 16) * range, 16); (3)<br>  return SHR(xmultiply(SHR(getFIXED(8), 16), getFIXED(4)), 16);<br>}<br><br>/*<br>  File main.c generated by XCOM-I, 2024-04-16 08:46:47.<br>  XPL/I source-code file used: Example-6.18.6.xpl.<br>  To build the program from the command line, using defaults:<br>          cd Example-6.18.6/<br>          make<br>  View the Makefile to see different options for the `make`<br>  command above.  To run the program:<br>          Example-6.18.6 [OPTIONS]<br>  Use `Example-6.18.6 --help` to see the available OPTIONS.<br>*/<br><br>#include "runtimeC.h"<br>#include "procedures.h"<br><br>/*<br>  Memory Map:<br>           Address (Hex)        Data Type        Variable<br>           -------------        ---------        --------<br>              0 (000000)        FIXED            I<br>              4 (000004)        FIXED            RANDOMxRANGE<br>              8 (000008)        FIXED            RANDOMxRBASE<br>*/<br><br>int<br>main(int argc, char *argv[])<br>{<br><br>  if (parseCommandLine(argc, argv)) exit(0);<br><br>  // do i = 1 to 100; (0)<br>  {<br>    int32_t from0, to0, by0;<br>    from0 = 1;<br>    to0 = 100;<br>    by0 = 1;<br>    for (putFIXED(0, from0);<br>         getFIXED(0) &lt;= to0;<br>         putFIXED(0, getFIXED(0) + by0)) {<br>      // output = RANDOM(100000); (1)<br>      {<br>        int32_t numberRHS = ( putFIXED(4, 100000), RANDOM() );<br>        string_t stringRHS;<br>        strcpy(stringRHS, fixedToCharacter(numberRHS));<br>        OUTPUT(0, stringRHS);<br>      }<br>    }<br>  } // End of DO for-loop block<br><br>  if (LINE_COUNT)<br>    printf("\n"); // Flush buffer for OUTPUT(0) and OUTPUT(1).<br>  return 0; // Just in case ...<br>}<br></font><br></pre>
      </td>
    </tr>
  </tbody>
</table>
The comparison, I think, is both tantalizing and mysterious.&nbsp; Tantalizing, because you can <i>almost</i> see how it works.&nbsp; And mysterious, because you can't <i>quite</i> see it.&nbsp; But I digress!<br>
<br>
The next step, of course, is to compile the C programs.&nbsp; If your 
setup is like mine, namely a Linux system with <b>gcc</b> as the default C 
compiler, then compilation can be accomplished like this, assuming that you're still in the XCOM-I/ working directory:<font color="#663300"><code></code></font><br>
<font color="#663300"><code></code></font><blockquote><font color="#663300"><code>
make -C Example-6.18.6</code><br>


</font></blockquote><font color="#663300">
</font>This produces an executable program within the Example-6.18.6/ folder that's also called <b>Example-6.18.6</b>.<br>
<br>
But the world being what it is, you most likely <i>don't</i> have a 
setup like mine, so some alterations in the instructions above may be 
needed in your situation.&nbsp; For one thing, your C compiler may not 
be <b>gcc</b>.&nbsp; 
Actually, the default assumption isn't that the compiler is <b>gcc</b>, but 
rather that the shell's environment variable <font color="#663300"><code>CC</code></font> holds the 
name of the compiler.&nbsp; But if that's not true, or if you're not using <b>gcc</b>, then the command for <font color="#663300"><code>make</code></font> will differ a little. <br>
<blockquote><font size="-1"><b>Note:</b> I've tried to make <b>XCOM-I</b>
 use C that's pretty generic, in order to avoid the very problem of 
being limited in the choice of C compilers.&nbsp; But there are some C 
features used, such as "designated initializers", which I believe aren't
 quite as commonly supported.</font> <br>
</blockquote>
For example, suppose you use <b>clang</b> instead of <b>gcc</b>.&nbsp; Just change the build commands to read:<br>
<blockquote><font color="#663300"><code>cd XCOM-I</code><br>

  <code>
make -C Example-6.18.6 CC=clang</code></font><br>
</blockquote>


Or if you're on Windows — and other than myself who isn't, really? — then you'd want to 
add the filename extension ".exe" to your executable.&nbsp; That could be done 
like so:<br>
<blockquote><font color="#663300"><code>cd XCOM-I</code><br>

  <code>
make -C Example-6.18.6 TARGET=Example-6.18.6.exe</code></font><br>
</blockquote>
<blockquote>
  <font size="-1"><b>Aside:</b>&nbsp; The Makefile itself lists other 
possible alterations, any or all of which can be used in combination 
with the others.&nbsp; For example, one thing you may encounter if using
 a compiler other than <b>gcc</b>, or even a different version of <b>gcc</b>,
 is an increased likelihood of seeing compile-time warnings that I don't
 see myself.&nbsp; Even if such warnings don't affect your ability to 
compile and run the software, they may be annoying and hence you might 
like to use compiler switches to turn them off.&nbsp; For example, with <b>clang</b>
 15, I see irritating (and incidentally, incorrect!) warnings about 
"dangling elses".&nbsp; Those warning messages are supposedly (though 
not actually) disabled with:<br>
  </font>
  <blockquote>
    <pre><font size="-1" color="#663300">make -C Example-6.18.6 CC=clang EXTRA="-Wdangling-else"</font></pre>
  </blockquote>
</blockquote>

Finally, you can now run the now-fully-compiled program:<br>
<blockquote>
  <pre><font color="#663300">Example-6.18.6/Example-6.18.6</font></pre>
</blockquote>What this particular sample program does is just to print 
100 random numbers, so that's what should happen.&nbsp; (I say they're 
"random", but the seed for the random-number generator is hard-coded and
 always the same as 1, so you'll get the same 100 numbers every time you
 run the program.)<br>
<blockquote><font size="-1"><b>Aside:</b> Just like <b>XCOM-I</b>, the compiled
 application also has a variety of command-line options that may affect 
how it runs.&nbsp; None of them are really applicable to this particular
 sample program, but you could see them with the command "</font><code></code><code><font size="-1" color="#663300">Example-6.18.6/Example-6.18.6 --help</font></code><font size="-1">".</font><br>
</blockquote>If you want to see a much meatier standard XPL example, you 
can look instead at McKeeman's <b>ANALYZER</b> program.&nbsp; <br>
<blockquote><font size="-1"><b>Aside:</b>&nbsp; I originally found the source code presented for <b>ANALYZER</b>
 online, and don't actually know if it's precisely the same source code 
as given in McKeeman.&nbsp; At least, not without much more-detailed 
checking than I have any desire to do.&nbsp; I have definitely seen <i>some</i>
 differences from the book, but suspect that the book may have errors 
(gasp!) due to typesetting process.&nbsp; Whether there are differences 
not accounted for by typesetting, I cannot say.</font><br>
</blockquote>
If you have a copy of <i>A Compiler Generator</i> (see Section 7.1, Chapter 10, and Appendix 
6), it provides reasonably-detailed operating instructions and theory of 
operation for <b>ANALYZER</b>.&nbsp; Basically, <b>ANALYZER</b> is used for 
analyzing a given BNF grammar and printing a report about it.&nbsp; Thus McKeeman recommends <b>ANALYZER</b>
 for 
developing BNF grammars and debugging them.&nbsp; There's an associated 
data file as well, SKELETON.bnf, which contains the BNF description for a
 very simple language (called "SKELETON", of course) that's the basis 
for some of the discussion in the book.&nbsp; The steps for compiling 
and running <b>ANALYZER</b> with SKELETON.bnf as input are just what you'd expect from the discussion earlier:<br>
<blockquote>
  <pre><font color="#663300">cd XCOM-I<br>XCOM-I.py --xpl Tests/ANALYZER.xpl
make -C ANALYZER
ANALYZER/ANALYZER &lt;Tests/SKELETON.bnf<br></font></pre></blockquote>
<blockquote>
</blockquote>
If you're interested, you can compare <a moz-do-not-send="true" href="SKELETON-XCOM-I.pdf">the report on the SKELETON grammar produced by the steps above,</a> versus <a moz-do-not-send="true" href="SKELETON-McKeeman.pdf">the report printed in Figure 7.1.6 of McKeeman</a><a moz-do-not-send="true" href="file:///home/rburkey/git/virtualagc-web/SKELETON-McKeeman.pdf"> in 1969</a>.&nbsp;
 You will notice slight differences between the two, but not (I think) 
anything substantive.&nbsp; Remember that the report printed in the book
 would have been <i>manually</i> typeset, always with the possibility of
 human error, and with editorial decisions having been made to affect 
the aesthetics and publishing cost, possibly to the detriment of literal
 100% accuracy.<br>
<blockquote><font size="-1"><b>Aside:</b> Reducing discussion of <b>ANALYZER</b> to just whether or not it works the same today as it did back in 1970 is doing it a injustice, because <b>ANALYZER</b>
 has interesting capabilities in its own right.&nbsp; If you look at the
 reports I mentioned above, you'll notice that one thing <b>ANALYZER</b> includes in these reports is a large section consisting of XPL <font color="#663300"><code>DECLARE</code></font> statements.&nbsp; These </font><font size="-1"><font size="-1"><font color="#663300"><code>DECLARE</code></font></font>
 statements, if plugged into the template XPL code provided elsewhere in
 McKeeman, are what's needed to create a compiler (written in XPL, of 
course) for the grammar being analyzed.&nbsp; In other words, the title 
of the book (<i>A Compiler Generator</i>) isn't a misnomer.&nbsp;&nbsp; 
This XPL code in the report isn't incredibly useful as-is, because it's 
formatted in a manner that's not immediately compilable.&nbsp; However, 
ANALYZER also allows you to "punch" separate punch-cards that do contain
 immediately-compilable XPL.&nbsp; More on that in a moment.&nbsp; </font><br>
</blockquote>
One of the legacy XPL programs provided for demonstration purposes is 
actually a compiler for the SKELETON language, though calling it a 
"compiler" is a bit of a stretch, since all it does is analyze 
statements in the SKELETON language for correctness, and doesn't produce
 any object code.&nbsp; The idea behind the <b>SKELETON</b> program was 
that since it's such a small program (~300 lines of XPL), it would be 
easy to experiment with.&nbsp; The SKELETON language itself is very 
bare-bones, in that it only has assignment statements in it, and those 
assignment statements have the form <code><font color="#663300">IDENTIFIER</font></code><font color="#663300"><code> = EXPRESSION;</code></font>.&nbsp;
 Identifiers follow the same rules as they in XPL, except that lower-case 
letters aren't supported.&nbsp; There are no declarations, no arrays, no
 strings, and "expressions" are basically whatever normal arithmetical 
expressions you can form from just identifiers, literal decimal numbers,
 and the tokens <font color="#663300"><code>+</code></font> <font color="#663300"><code>-</code></font> <font color="#663300"><code>*</code></font> <font color="#663300"><code>/</code></font> <font color="#663300"><code>(</code></font> and <font color="#663300"><code>)</code></font>.&nbsp; Anyway, you can compile and run it like so:<br>
<blockquote>
  <pre><font color="#663300">cd XCOM-I<br>XCOM-I.py --xpl Tests/SKELETON.xpl
make -C SKELETON
</font><font color="#663300"><font color="#663300">SKELETON</font>/</font><font color="#663300"><font color="#663300">SKELETON</font></font></pre>
</blockquote>
SKELETON being relatively uninteresting, the Tests/ folder also contains
 a similar but more-complex BNF grammar for XPL itself.&nbsp; Analyzing 
the XPL grammar with <b>ANALYZER</b> is very slightly more complex than analyzing the SKELETON grammar was. That's because the XPL grammar file used as input for <b>ANALYZER</b> contains a directive which the SKELETON grammar did not.&nbsp; The culprit is <font color="#663300"><code>$PUNCH</code></font>, which directs <b>ANALYZER</b>
 to output the XPL code it generates to a "punch device".&nbsp; 
Technically, that means a file has to be "attached" to the punch device,
 or else the data has nowhere to go.&nbsp; But by default <b>ANALYZER</b>
 doesn't attach any file to the punch device.&nbsp; On an IBM 
System/360, this would have been handled by means of separately-provided
 Job Control Language (JCL), and in particular by <font color="#663300"><code>DD</code></font> statements in the JCL.&nbsp; Naturally, we have no JCL in our <b>XCOM-I</b> based system, but the equivalent to JCL would be <b>ANALYZER</b>'s command-line switches. The command-line switches for simulating <font color="#663300"><code>DD</code></font> statements are <font color="#663300"><code>--ddi</code></font> and <font color="#663300"><code>--ddo</code></font>.&nbsp;
 Putting that all together, we can analyze the XPL grammar, with the 
punch device attached to a file called PUNCH.txt, using the following 
command:<br>
<blockquote>
  <pre><font color="#663300">ANALYZER/ANALYZER --ddo=2,PUNCH.txt &lt;Tests/XPL.bnf</font></pre>
</blockquote>
Or since ANALYZER accepts the input grammar it analyzes on "device 0" (attached by default to <font color="#663300"><code>stdin</code></font>, which is why we usually pipe in the input via <font color="#663300"><code>&lt;</code></font>), we could even run it instead as:<br>
<blockquote>
  <pre><font color="#663300">ANALYZER/ANALYZER --ddi=0,Tests/XPL.bnf --ddo=2,PUNCH.txt &lt;Tests/XPL.bnf</font></pre>
</blockquote>

We'll come to <a moz-do-not-send="true" href="stillMeatier">a still meatier example</a> in a moment, but before doing that, the next section will be a necessary digression.<br>
<h2>
  <a name="sim360"></a>Emulating the IBM 360 CPU</h2>

<p>XPL or XPL/I programs compiled by <b>XCOM-I</b> are native to your own local computer system, and if <b>XCOM-I</b> has done its job properly, there should be no lingering dependencies on the IBM 360 in the compiled program.<br></p>
<p>Nevertheless ... XPL was <i>designed</i> to be a program for 
generating compilers, so a lot of legacy XPL or XPL/I code is actually 
the source code of a compiler for one or another computer language.  
Suppose for example that we had an XPL program called <b>X</b> that was a compiler for a programming language called "X".  It's true that if we compile the source code for <b>X</b> with <b>XCOM-I</b> that we'll get executable code for <b>X</b>
 that runs on our native Linux/Mac/Windows computer (rather than, say, 
an IBM 360).  But it's also true that if we use that native version of <b>X</b> to compile source-code in the X language, say for a program called <b>Y</b>, then the output of the compiler will still be an object file for the IBM 360.  So we still wouldn't be able to run <b>Y</b> on our native computer, and would still need an IBM 360 to run <b>Y</b>.<br></p>
<p>Which means that even with <b>XCOM-I</b> in hand, it's still very useful to have an IBM 360 emulator in which to run not the programs <i>produced</i> by <b>XCOM-I</b>, but the programs produced by the compilers produced by <b>XCOM-I</b>.<br></p>
<p>If you're already an IBM 360 expert or a wannabe IBM 360 user, then perhaps a full-scale IBM System/360 emulator such as <a moz-do-not-send="true" href="http://www.hercules-390.org/">Hercules</a>
 might work well for you.  As for myself, having tried to figure out 
Hercules, I have to concede that I'm neither a 360 expert nor 
wannabe, and have no desire to confront that learning curve.  I'd much 
prefer a <i>lightweight</i> IBM 360 emulator, with essentially no 
learning curve at all.  (And a lightweight emulator is far more in line 
with Virtual AGC's goal of integrating Space Shuttle computing support 
into spaceflight simulation programs than a full-blown mainframe 
emulator would be.)<br></p>

<p>As it happens, there is an available candidate for such lightweight IBM 360 emulator.  This emulator, called <b>sim360</b>,
 was written by Daniel Weaver, who I've mentioned earlier as also being 
the author of an XPL-to-C translator for standard XPL.  You can find the
 source code for <b>sim360</b> archived as <a moz-do-not-send="true" href="https://github.com/virtualagc/virtualagc/tree/master/XCOM-I/sim360">the XCOM-I/sim360-source/ folder</a> in the Virtual AGC software repository, but <a moz-do-not-send="true" href="https://sourceforge.net/projects/suny-pascal/">the official place to get the most up-to-date version is Dan's own site</a>.  It's disguised on Dan's site as a Pascal compiler, but don't be confused:  There's an IBM 360 emulator in there as well!<br>
</p>
<blockquote><b><font size="-1">Aside:</font></b><font size="-1">&nbsp; 
There is a limit, of course, to how "lightweight" an IBM 360 emulator 
can be while still remaining useful.&nbsp; To run programs originally 
written in XPL or XPL/I, for example, just emulating the CPU's 
instruction set is not enough.&nbsp; Such XPL or XPL/I programs depend 
on there being an operating system in place to allow operations like 
inputting data (from a files or keyboards) or outputting data (to a 
displays, printers, or files) to occur.&nbsp; But an XPL program doesn't
 actually interact directly with the operating system.&nbsp; Instead, an
 XPL program expects that there's a separate program called the <i>submonitor</i>
 running along side of it, and the XPL program makes its low-level 
requests for input, output, allocation of memory, and so on, to this 
submonitor program.&nbsp; In fact, there will be <a moz-do-not-send="true" href="#builtin">a whole section later on</a> that describes XPL's built-in functions, some of which rely on the submonitor, as well as <a moz-do-not-send="true" href="#monitor">another section covering the <font color="#663300"><code>MONITOR</code></font> procedure</a>, <i>all</i> of whose functionality comes from the submonitor.&nbsp; But the point is that to be useful to us, a lightweight emulator like <b>sim360</b>
 must provide enough submonitor capability to respond correctly when the
 XPL program makes these requests of the submonitor even though the IBM 
360 operating system is entirely absent.</font><font size="-1">&nbsp; Fortunately, although at the present writing it's a work in progress, <b>sim360</b> does so.&nbsp; Thanks, Dan!<br>
    <br>
By the way, if in place of <b>sim360</b> you were to use a full-scale IBM 360 simulator such as <a moz-do-not-send="true" href="http://www.hercules-390.org/">Hercules</a>, an emulation of the XPL or XPL/I submonitor would <i>not</i>
 be built into it.&nbsp; Rather, you would have to assemble the IBM 360 
Basic Assembly Language (BAL) source code for the submonitor, and 
presumably contrive the JCL needed to run the submonitor program 
along-side your compiled XPL program on the emulator.&nbsp; Fortunately,
 although we don't need it if we are using <b>sim360</b>, we <i>do</i> have source code for the submonitor:&nbsp; <br>
  </font>
  <ul>
    <li><font size="-1">For McKeeman's <b>XCOM</b>, it's <a moz-do-not-send="true" href="https://github.com/virtualagc/virtualagc/blob/master/yaShuttle/Source%20Code/XPL-TWS-1969-03/XMON.bal">XMON.bal</a>.</font></li>
    <li><font size="-1">For SUNY's <b>XCOM</b> 4.5, which we've not discussed yet but which we'll get to in the next section, it's the slightly-different <a moz-do-not-send="true" href="https://github.com/virtualagc/virtualagc/blob/master/XCOM-I/sim360-source/port/XPLSM4.5.bal">XPLSM.bal</a>.</font></li>
    
    <li><font size="-1">For Intermetrics's unavailable <b>XCOM</b>, it's the collection of BAL source-code files known as <a moz-do-not-send="true" href="https://github.com/virtualagc/virtualagc/tree/master/yaShuttle/Source%20Code/PASS.REL32V0/MONITOR.ASM">MONITOR.ASM</a>.&nbsp; You may wonder why that matters, given that the source code for the Intermetrics version of <b>XCOM</b> has not survided, and thus we couldn't run it anyway?&nbsp; (After all, the whole point of <b>XCOM-I</b> in the first place is to fill in for the missing Intermetrics <b>XCOM</b>, and <b>XCOM-I</b> needs no submonitor!)&nbsp; Well presumably, if we compile HAL/S source code (like PFS or BFS) using <b>HAL/S-FC</b>, we'd expect PFS or BFS to need the same submonitor as the Intermetrics <b>XCOM</b> would have.&nbsp; Probably.&nbsp; Or at least, maybe!<br>
      </font></li>
  </ul>
  <p><font size="-1">What we <i>don't</i> have in this scenario is a BAL
 assembler, nor an IBM 360 linker program, so in spite of this wealth of
 source code for submonitors, in the end we still have no way to build 
the submonitor programs that I'm aware of.</font><br>
  </p>
</blockquote>


<p>Assuming you're working from Virtual AGC's archived copy, the first thing you have to do is to build <b>sim360</b> itself as follows: <br></p>

<blockquote>
  <pre><font color="#663300">cd XCOM-I/sim360-source/simulate<br>make clean all</font><br></pre>
</blockquote>

<p>This will result in the executable, <b>sim360</b> itself, being 
created in the XCOM-I/sim360/simulate/ folder.  But you'll probably want
 it to be in your PATH.  You can just copy <b>sim360</b> itself into XCOM-I/ if you like, if you've added XCOM-I/ into your PATH as I recommended earlier. <br></p>

<p>To actually run an IBM 360 program in <b>sim360</b>, you'll need an IBM 360 <i>load file</i> for it.  In the context of our present discussion, there are two ways to get such a load file:<br></p>

<ul>
<li>You could compile an XPL program using McKeeman's <b>XCOM</b> program. <br>
</li><li>You could compile a HAL/S program using Intermetrics's <b>HAL/S-FC</b> program. </li>
</ul>

<blockquote>
  <p><b><font size="-1">Aside:</font></b><font size="-1">&nbsp; Traditionally, you'd expect a compiler to produce <i>object files</i> which aren't directly executable.&nbsp; Instead, traditionally, you'd expect to have a <i>linker program</i> whose function is to combine ("link") object files, thus creating an executable <i>load file</i>.&nbsp; The versions of <b>XCOM</b>
 we have access to all bypass this traditional process, directly 
producing executable load files that don't need to be linked to be 
executable.&nbsp; Fortunately for us!&nbsp; But it means that I've been 
using sloppy language all along, and probably will continue to do so, in
 which I use the terms "object file" and "load file" 
interchangeably.&nbsp; On that glorious day when we're able to compile a
 working version of <b>HAL/S-FC</b> (and stop thinking about XPL altogether <img moz-do-not-send="true" src="smiley.png" alt="" width="16" height="16">) that will abruptly change, since I think that <b>HAL/S-FC</b> really does produce object files rather than load files, and really does need a linker, called <b>HALLINK</b>.&nbsp; But that's a problem for a different day and a different web page!</font><br>
  </p>
</blockquote>
<p>At this point in the discussion, of course, we have executable copies of neither <b>XCOM</b> nor <b>HAL/S-FC</b>; we'll address that problem in the next couple of sections.<br></p>

<p>So for now I'll just say that if you have an IBM 360 load file as 
produced by one of these methods — let's call this hypothetical load 
file <i>Program</i>.obj — then a typical way to run it in the <b>sim360</b> would be:<br></p>


<blockquote>
  <pre><font color="#663300">sim360 -o0ET stdout -i0AT stdin <i>Program</i>.obj</font><br></pre>
</blockquote>
The command-line switches for <b>sim360</b> probably look mysterious, but they're not so bad.  You can see a full list of command-line options with the command "<font color="#663300"><code>sim360 --help</code></font>", but what the mysterious switches in the example above mean is this:<br>


<ul>
<li><font color="#663300"><code>-o0ET stdout</code></font>:  Causes <font color="#663300"><code>OUTPUT(0)</code></font> to send data to <font color="#663300"><code>stdout</code></font> and automatically translate it from EBCDIC to ASCII.<br></li><li><code><font color="#663300">-i0AT stdin</font></code>:  Causes <font color="#663300"><code>INPUT(0)</code></font> to receive data from <font color="#663300"><code>stdin</code></font> and automatically translate it from ASCII to EBCDIC.<br></li>
</ul>
<h2><a name="compilingXCOM"></a>Insane Bootstrapping!</h2>
For the still meatier example that I promised (threatened?) earlier, here it is with a vengeance!&nbsp; We're going try <i>bootstrapping</i>
 some XPL compilers.&nbsp; Although up to now I've only spoken of one 
pure-XPL compiler, we happen to have XPL source code for two related 
but different XPL compilers:<br>
<ul>
  <li>McKeeman <i>et al.</i>'s XCOM, from the book <i>A Compiler Generator</i>, from 1969 or 1970, is what I've spoken of so often above.&nbsp; In our software repository, the source code consists of <a moz-do-not-send="true" href="https://github.com/virtualagc/virtualagc/blob/master/XCOM-I/Tests/XCOM.xpl">XCOM.xpl</a>, which contains the source code for XCOM proper, and the file <a moz-do-not-send="true" href="https://github.com/virtualagc/virtualagc/blob/master/XCOM-I/XPL.LIBRARY.xpl">XPL.LIBRARY.xpl</a>, which contains the source code for <a moz-do-not-send="true" href="#compactify">the <font color="#663300"><code>COMPACTIFY</code></font> procedure</a>.&nbsp;
 The program comments actually identify this program as "XCOM III", 
implying that there were earlier major versions as well, to which we're 
not privy.&nbsp; For clarity in this discussion, I'll start referring to it as <u><b>XCOM3</b></u>.</li>
  <li>SUNY's (State University of New York, Stonybrook) XCOM version 4.5 has been taken from <a moz-do-not-send="true" href="https://sourceforge.net/projects/suny-pascal/">Daniel Weaver's website</a>; in the Virtual AGC software repository, the source code consists of the files <a moz-do-not-send="true" href="https://github.com/virtualagc/virtualagc/blob/master/XCOM-I/sim360-source/port/xcom4.xpl">XCOM4.5.xpl</a> (for XCOM proper) and <a moz-do-not-send="true" href="https://github.com/virtualagc/virtualagc/blob/master/XCOM-I/sim360-source/port/XPLIB4.5.xpl">XPLIB4.5.xpl</a> (for <font color="#663300"><code>COMPACTIFY</code></font>).&nbsp; The materials we have
 are from 1976 or 1977.&nbsp; The original source code has a block of embedded IBM 360 assembly-language code, which <b>XCOM-I</b> cannot handle without assistance, so the additional C-language "patch" file <a moz-do-not-send="true" href="https://github.com/virtualagc/virtualagc/blob/master/XCOM-I/sim360-source/port/patch0.c">patch0.c</a> is needed as well; <a moz-do-not-send="true" href="#hooks"><b>XCOM-I</b>'s "patch" system is discussed later</a>, using this very example.&nbsp; Interestingly, the SUNY distribution contains an 
IBM 360 executable load file as well, which I call <a moz-do-not-send="true" href="https://github.com/virtualagc/virtualagc/blob/master/XCOM-I/sim360-source/XCOM4-1976.obj">XCOM45-19760719.obj</a>, that can be run in <b>sim360</b> (see the preceding section).&nbsp; For clarity, I'll refer to this version of the compiler as <u><b>XCOM45</b></u>
 from now on.&nbsp; (Don't be confused by a different XCOM version with 
the source-code file xcom4.xpl on Dan's site; it's not a legacy program,
 but one which has modern modifications to XCOM45 source code that we 
needn't concern ourselves with.)<br>
  </li>
  
</ul>
Also from now on, if I'm speaking generically about any of these old compilers, I'll simply refer to <b>XCOM<i>x</i></b>.<br>
<br>
"Bootstrapping" is a process employed by folks who feel compelled to 
write computer-language compilers that can "self-compile".&nbsp; For 
example, you'll find that the source code for the C compiler <b>gcc</b> is itself written in C, and intended to be compiled by <b>gcc</b> as well.&nbsp; Which is fine nowadays, since <b>gcc</b> exists and is very capable.&nbsp; But how could it have possibly worked the very first time, when you had <b>gcc</b> source code but no <b>gcc</b> to compile it with?&nbsp; Well, obviously the initial versions of <b>gcc</b> must have been compiled with a C compiler other than <b>gcc</b>, and through successive iterations of this process <b>gcc</b>
 became more and more capable, until eventually it was able to compile 
itself.&nbsp; That process is called "bootstrapping", as in "hauling 
yourself up by your own bootstraps".&nbsp; We're now going to try doing 
that with <b>XCOM<i>x</i></b>.<br>
<br>
To be clear, the use case for <b>XCOM-I</b> I'm personally interested in is building <b>HAL/S-FC</b> and then forgetting that <b>XCOM-I</b> even exists.&nbsp;&nbsp;<img moz-do-not-send="true" src="smiley.png" alt="" width="16" height="16">&nbsp; And we don't need <i>a single one</i> of these <b>XCOM<i>x</i></b> programs to do that.&nbsp; But still, it's going to go much more smoothly if <b>XCOM-I</b> is believed to work properly in the first place.&nbsp; And if we can use <b>XCOM-I</b> for bootstrapping <b>XCOM<i>x</i></b>, that will give us a certain degree of confidence that <b>XCOM-I</b> does in fact work as intended.<br>
<br>
Here's the bootstrapping game-plan as it applies to any/all of the <b>XCOM<i>x</i></b> compilers:<br>
<ol>
  <li>We'll use <b>XCOM-I</b> to compile the XPL source code for <b>XCOM<i>x</i></b>.  That will give us an executable which I'll call <b><b>XCOM<i>x</i></b>-native</b> that runs natively on our Linux, Windows, or Mac computers. <br>
</li>
  <li>We'll then use <b>XCOM<i>x</i></b><b>-native</b> to compile the XPL source code for <b>XCOM<i>x</i></b> <i>again</i>.  That will give us an executable which I'll call&nbsp;<b><b>XCOM<i>x</i></b>-360</b> that's native to the IBM 360. I.e., it only runs on an IBM 360 or a simulation thereof.<br></li>
  <li>Finally, we'll run&nbsp;<b><b>XCOM<i>x</i></b>-360</b> under <b>sim360</b> to compile the source code for <b>XCOM<i>x</i></b> one last time.  That will give us an executable which I'll call&nbsp;<b><b>XCOM<i>x</i></b>-360A</b>.&nbsp; If everything worked perfectly, <b><b>XCOM<i>x</i></b>-360A</b> should be byte-for-byte identical to <b><b>XCOM<i>x</i></b>-360</b>.<br></li>
</ol>
<blockquote><font size="-1"><b>Aside:</b>&nbsp; The final statement above isn't precisely correct.&nbsp;  All of the <b>XCOM<i>x</i></b> executables, whether <b>-native</b>, <b>-360</b>, or <b>-360A</b>,
 like to include the date and time on which they were compiled in the 
reports they print out.That requires those dates and times to be 
embedded within the executable load file.&nbsp; So a straightforward 
automated test that load files are byte-for-byte identical will always 
fail, since the embedded timestamps will always differ.&nbsp; Don't worry about that at the moment.<br>
  </font></blockquote>
That's a <i>lot</i> of XPL compilers floating around to keep straight.&nbsp; Here's a synopsis of the <b>XCOM</b> variants relevant to the discussion:<br>
<br>
<table align="center" cellspacing="2" cellpadding="2" border="1">
  <tbody>
    <tr>
      <th valign="bottom" align="center">Compiler Variant<br>
      </th>
      <th valign="bottom" align="center">Compiler's Own<br>
Source-Code Files<br>
      </th>
      <th valign="bottom" align="center">Compiler<br>
Compiled With<br>
      </th>
      <th valign="bottom" align="center">Compiler<br>
Runs on IBM 360?<br>
      </th>
      <th valign="bottom" align="center">Compiler<br>
Runs on Linux/Mac/Windows<br>
      </th>
      <th valign="bottom" align="center">Source-Code Language<br>
&nbsp;and Encoding Accepted<br>
By Compiler<br>
      </th>
      <th valign="bottom" align="center">Object Files Directly <br>
Output By Compiler<br>
      </th>
      <th valign="bottom" align="center">Encoding of <br>
Textual I/O When<br>
Running the <br>
Output<br>
Object Files <br>
      </th>
    </tr>
    <tr>
      <td valign="middle" align="center"><b>XCOM-I</b><b>.py<br>
        </b></td>
      <td valign="middle" align="center">XCOM-I.py <i>et al.</i><br>
      </td>
      <td valign="middle" align="center">n/a<br>
      </td>
      <td valign="middle" align="center">No<br>
      </td>
      <td valign="middle" align="center">Yes<br>
      </td>
      <td valign="middle" align="center">XPL or XPL/I, ASCII coding<br>
      </td>
      <td valign="middle" align="center">C-language files<br>
      </td>
      <td valign="middle" align="center">ASCII<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#009900"><b>XCOM3-native</b><b><br>
          </b></font></td>
      <td valign="middle" align="center"><font color="#009900">XCOM.xpl, XPL.LIBRARY.xpl<br>
        </font></td>
      <td valign="middle" align="center"><font color="#009900"><b>XCOM-I.py</b><b><br>
          </b></font></td>
      <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#009900">No</font><font color="#009900"><br>
        </font></td>
      <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#009900">Yes</font><font color="#009900"><br>
        </font></td>
      <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#009900">XPL, ASCII coding</font></td>
      <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#009900">IBM 360 load file</font></td>
      <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#009900">EBCDIC</font></td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#009900"><b>XCOM45-native</b></font></td>
      <td valign="middle" align="center"><font color="#009900">XCOM4.5.xpl, XPLIB4.5.xpl<br>
        </font></td>
      <td valign="middle" align="center"><font color="#009900"><b>XCOM-I</b><b>.py<br>
          </b></font></td>
    </tr>
    
    <tr>
      <td valign="middle" align="center"><font color="#cc9933"><b>XCOM3-360</b><b>.obj<br>
          </b></font></td>
      <td valign="middle" align="center"><font color="#cc9933">XCOM.xpl, XPL.LIBRARY.xpl</font></td>
      <td valign="middle" align="center"><font color="#cc9933"><b>XCOM3-native</b><b><br>
          </b></font></td>
      <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#cc9933">Yes</font><font color="#cc9933"><br>
        </font></td>
      <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#cc9933">Only under <b>sim360</b> or similar</font></td>
      <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#cc9933">XPL, EBCDIC coding</font></td>
      <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#cc9933">IBM 360 load file</font></td>
      <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#cc9933">EBCDIC</font></td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#cc9933"><b>XCOM45-360.obj</b></font></td>
      <td valign="middle" align="center"><font color="#cc9933">XCOM4.5.xpl, XPLIB4.5.xpl</font></td>
      <td valign="middle" align="center"><font color="#cc9933"><b>XCOM45-native</b></font></td>
    </tr>
    
    <tr>
      <td valign="middle" align="center"><font color="#000099"><b>XCOM3-360A</b><b>.obj</b><br>
        </font></td>
      <td valign="middle" align="center"><font color="#000099">XCOM.xpl, XPL.LIBRARY.xpl</font></td>
      <td valign="middle" align="center"><font color="#000099"><b>XCOM3-360</b><b>.obj<br>
          </b></font></td>
      <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#000099">Yes<br>
        </font></td>
      <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#000099">Only under <b>sim360</b> or similar</font></td>
      <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#000099">XPL, EBCDIC coding</font></td>
      <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#000099">IBM 360 load file</font></td>
      <td rowspan="2" colspan="1" valign="middle" align="center"><font color="#000099">EBCDIC</font></td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#000099"><b>XCOM45-360A.obj</b></font></td>
      <td valign="middle" align="center"><font color="#000099">XCOM4.5.xpl, XPLIB4.5.xpl</font></td>
      <td valign="middle" align="center"><font color="#000099"><b>XCOM45-360.obj</b></font></td>
    </tr>
    
  </tbody>
</table>
<br>
There are other possibilities, such as compiling one of the <b>XCOM<i>x</i></b> compiler's source code with another of the <b>XCOM<i>x</i></b> compiler's <b>-native</b> or <b>-360</b> executables.&nbsp; Those are left as an exercise for the reader.<br>
<blockquote><b><font size="-1">Note:</font></b><font size="-1">&nbsp; All of the instructions in the succeeding subsections assume that your current working directory is a local copy of <a moz-do-not-send="true" href="https://github.com/virtualagc/virtualagc/tree/master/XCOM-I">the XCOM-I/ folder within the Virtual AGC source-code hierarchy</a>.<br>
</font></blockquote>In the next three subsections, I'm going to make a 
detailed examination of the steps needed to actually carry out the 
bootstrapping manipulations and to show that the bootstrapping was 
successful.&nbsp; Or not!&nbsp; (But it was successful for me.)<br>
<blockquote><b><font size="-1">Aside:</font></b><font size="-1">&nbsp; 
If you don't have the patience for that, the provided makefile will 
perform the entire bootstrapping process for you, if you like.&nbsp; At 
least if you're on Linux and have the right helper software 
installed.&nbsp; And maybe in Mac OS.&nbsp; I'm sure it won't work in 
Windows as-is, but that it could be made to work; but I'm not going to 
personally research it, and you can personally look at the makefile to 
see what has to be done.&nbsp; If you figure it out, drop me a line and 
tell me about it.&nbsp; At any rate, the commands to bootstrap <b>XCOM3</b> and <b>XCOM4</b>
 are as follows, and simply print a messages at the end that the process
 either succeeded or failed, after which the various compilers listed in
 the table above will be present:<br>
  </font>
  <blockquote>
    <pre><font size="-1"><font color="#663300">make bootstrap3<br>make bootstrap45</font><br></font></pre>
  </blockquote>
</blockquote>
<blockquote>
</blockquote>




<h3>Step 1:&nbsp; Compiling XCOM<i>x</i> source code with XCOM-I to produce XCOM<i>x</i>-native</h3>

<blockquote>
  </blockquote>For <b>XCOM3</b>:<br>
<blockquote><pre><font color="#663300">XCOM-I.py --xpl --output=XCOM3-native Tests/XCOM.xpl
make -C XCOM3-native
</font></pre>

</blockquote>
For <b>XCOM45</b>:<br>

<blockquote>
  <pre><font color="#663300">XCOM-I.py --xpl --lib-file=sim360-source/port/XPLIB4.5.xpl --output=XCOM45-native sim360-source/port/XCOM4.5.xpl
make -C XCOM45-native
</font></pre>

</blockquote><blockquote>

</blockquote>


This is very much as described earlier, so I won't duplicate that discussion here.<br>
<br>
Of course, the proof-of-the-pudding for a new compiler like <b>XCOM<i>x</i>-native</b> is whether or not the programs you compile with it produce the same 
results as the programs compiled by the contemporary <b>XCOM</b><i><b>x</b></i> did, back in the day. &nbsp; As it happens, McKeeman provides two sample XPL programs, <b>Example-6.18.1</b> and <b>Example-6.18.2</b>, with which we can test just that.&nbsp; The former demonstrates 
IBM 360 object-code production, while the latter demonstrates error 
handling.&nbsp; The complete <b>XCOM</b><b>3</b>
 reports for these programs are given in the book, so it's
 possible to compare the original reports from <b>XCOM3</b>, 
including the interspersed IBM System/360 assembly language produced by 
the compiler, versus the corresponding reports created now by <b>XCOM3-native</b>:<br>
<table align="center" cellspacing="2" cellpadding="2" border="1">


  <tbody>
    <tr>
      <th valign="bottom" align="center">XPL Source-Code File<br>
      </th>
      <th valign="bottom">Compiled by XCOM3 for the book <br>
        <i>A Compiler Generator</i> (1970)<br>
      </th>
      <th valign="bottom">Compiled by XCOM3-native for <br>
The Virtual AGC Project (2024)<br>
      </th>
    </tr>
    <tr>
      <td valign="top">Tests/Example-6.18.1.xpl<br>
      </td>
      <td valign="top" align="center"><a moz-do-not-send="true" href="Example-6.18.1-McKeeman.pdf">Report</a><br>
      </td>
      <td valign="top" align="center"><a moz-do-not-send="true" href="Example-6.18.1-XCOM-I.pdf">Report</a><br>
      </td>
    </tr>
    <tr>
      <td valign="top">Tests/Example-6.18.2.xpl<br>
      </td>
      <td valign="top" align="center"><a moz-do-not-send="true" href="Example-6.18.2-McKeeman.pdf">Report</a><br>
      </td>
      <td valign="top" align="center"><a moz-do-not-send="true" href="Example-6.18.2-XCOM-I.pdf">Report</a><br>
      </td>
    </tr>
  </tbody>
</table>
<br>
As for a similar check of <b>XCOM45-native</b>, there is a possible way, and we'll get to in a minute.&nbsp; <br>


<h3>Step 2:&nbsp; Compiling XCOM<i>x</i> source code with XCOM<i>x</i>-native to produce XCOM<i>x</i>-360</h3>
For <b>XCOM3</b>:<br>
<blockquote>
  <pre><font color="#663300">XCOM3-native/XCOM3-native --ddi=0,Tests/XCOM.xpl</font><font color="#663300"> --ddi=2,XPL.LIBRARY.xpl --raf=B,3600</font><font color="#663300"><font color="#663300">,1</font>,XCOM3-360.obj --raf=B,3600</font><font color="#663300"><font color="#663300">,2</font>,</font><font color="#663300">XCOM3-360</font><font color="#663300">.dat --raf=B,3600</font><font color="#663300"><font color="#663300">,3</font>,</font><font color="#663300"><font color="#663300">XCOM3-360</font>.str &gt;XCOM3-360.rpt</font></pre>

</blockquote>


For <b>XCOM45</b>:<br>

<blockquote>
  <pre><font color="#663300">XCOM45-native/XCOM45-native --ddi=0,sim360-source/port/XCOM4.5.xpl</font><font color="#663300"> --ddi=2,sim360-source/port/XPLIB4.5.xpl --raf=B,7200</font><font color="#663300"><font color="#663300">,1</font>,XCOM45-360.obj --raf=B,7200</font><font color="#663300"><font color="#663300">,2</font>,</font><font color="#663300">XCOM45-360</font><font color="#663300">.dat --raf=B,7200</font><font color="#663300"><font color="#663300">,3</font>,</font><font color="#663300"><font color="#663300">XCOM45-360</font>.str &gt;XCOM45-360.rpt</font></pre>

</blockquote>As you can see, this involves a bit of command-line complexity that step
 1 did not.&nbsp; The command-line options are all there to compensate 
for the lack of Job Control Language (JCL), and in particular to provide
 replacements for missing <font color="#663300"><code>DD</code></font> statements.&nbsp; For one thing, there's an extra file which 
needs to be attached as an input, because <b>XCOM</b> always needs to include the library file containing <a moz-do-not-send="true" href="#compactify"><font color="#663300"><code>COMPACTIFY</code></font></a>.&nbsp; Also, <b>XCOM</b> wants to use several "random-access
 files" for storing object code and what not, and we have to attach 
those files.&nbsp; (Refer to <a moz-do-not-send="true" href="#file">the <font color="#663300"><code>FILE</code></font> entry in the section on XPL's built-in library functions</a>.)&nbsp; Those random-access files are as follows:<br>
<ul>
  <li><font color="#663300"><code>FILE(1)</code></font> — The compiled object code.</li>
  <li><font color="#663300"><code>FILE(2)</code></font> — A scratch file (i.e., temporary working space) for data.</li>
  <li><font color="#663300"><code>FILE(3)</code></font> — A scratch file for strings.</li>
</ul>
As far as the numbers 3600 or 7200 appearing in the command line, <b>XCOM<i>x</i></b> uses a hard-coded constant to determine the record sizes for
 these random-access files, which happens to have the default value of <font color="#663300"><code>DISKBYTES=3600</code></font> for <b>XCOM3</b>, but <font color="#663300"><code>DISKBYTES=7200</code></font> for <b>XCOM45</b>.<br>
<blockquote>
  <font size="-1"><b>Aside:</b>&nbsp; Incidentally, McKeeman's <b>XCOM3</b>
 has plenty of quirks specific to it, quite aside from any quirks XPL 
more-generally may have as a computer language.&nbsp; <b>XCOM3-native</b> and <b>XCOM3-360</b> inherit these quirks.&nbsp; I mention this 
just in case you become excited about using <b>XCOM3-native</b> and start writing new XPL programs for it!&nbsp; Here are a few quirks I've noticed:</font><br>
  <font size="-1">
  </font>
  
  <ul><li><font size="-1">It only accepts upper-case for identifiers and keywords ... in spite of the fact that every speck of XPL source code in <i>A Compiler Generator</i> is printed in lower case! But I've provided a trick to work around that in <b>XCOM3-native</b>:  In <b>XCOM3-native</b>'s <font color="#663300"><code>--ddi</code></font> command-line switches that attach the XPL source-code files, you can optionally suffix them with "<font color="#663300"><code>,U</code></font>".  This tells <b>XCOM3-native</b> to automatically translate the associated files to upper case.  </font><font size="-1" color="#663300"><font color="#663300"><font color="#000000">It's
 not a perfect workaround, since it translates comments and quoted 
strings to upper case too, but that's life!  We didn't actually need to 
do that for these source-code files, though, because they're already 
completely upper-case.</font></font></font></li><li><font size="-1">It requires an <font color="#663300"><code>EOF</code></font>
 token at the end of the source code.&nbsp; Other than correcting some 
EBCDIC-to-ASCII translation bugs that were present before I got some of 
the files, addition of </font><font size="-1"><font size="-1"><font color="#663300"><code>EOF</code></font></font> at the ends was my sole code change.<br>
  </font></li><li><font size="-1">It won't allow you to have two division operations (including <font color="#663300"><code>MOD</code></font> as a division) in the same statement, instead emitting an error message saying that it requires a "busy register".</font></li><li><font size="-1">... and who knows what else?</font></li></ul></blockquote>
<p>The *.rpt files produced by these compilations are worth looking at, 
if only to verify that somewhere in each of them is a line reading "NO 
ERRORS WERE DETECTED".<br>
</p>
<p>Now, I promised in the succeeding section that there might be a way to check the functionality of <b>XCOM45-native</b>
 vs contemporary (1976) materials.&nbsp; The way I had in mind, but have
 delayed explaining until now, was this:&nbsp; The XCOM45-360.obj we've 
just created might (knock wood!) be byte-for-byte identical to the 
XCOM45-19760719.obj which has survived from 1976 to the present 
day.&nbsp; Unfortunately, my hopes have been dashed, and it is <i>not</i>
 identical.&nbsp; Huge swaths of it are indeed the same, but there are 
differences that to me seem indicative that a large chunk has simply 
been displaced by 160 bytes, a fact for which I have no ready 
explanation.&nbsp; <i>Perhaps</i> it's an <b>XCOM-I</b> bug, but perhaps it's just that the object file XCOM45-19760719.obj was really compiled by (say) <b>XCOM</b> 4.4 rather than by <b>XCOM</b> 4.5.&nbsp; After all, we know <i>when</i> XCOM45-19760719.obj was compiled — hint: it's July 19, 1976 at 9:05:40.16 p.m. — but not <i>which compiler</i>
 was used to compile it.&nbsp; In short, while it would have been great 
if the files match, it doesn't really say much one way or the other if 
there's a mismatch instead.<br>
</p>
<blockquote>
</blockquote>



<h3>Step 3:&nbsp; Compiling XCOM<i>x</i> source code with XCOM<i>x</i>-360 under sim360 to produce XCOM<i>x</i>-360A</h3>First, as usual, the build instructions.<br>
<br>
For <b>XCOM3</b>:


<blockquote>
  <pre><font color="#663300">sim360 --size=3600</font><font color="#663300"><font color="#663300"> -o0ET stdout </font>-i0AT Tests/XCOM.xpl -i2AT XPL.LIBRARY.xpl -f1wb+ XCOM3-360A.obj -f2wb+ XCOM3-360A.dat -f3wb+ XCOM3-360A.str XCOM3-360.obj</font><br></pre>
</blockquote>For <b>XCOM45</b>:<br>
<blockquote>
  <pre><font color="#663300">sim360 --size=7200</font><font color="#663300"><font color="#663300"> -o0ET stdout </font>-i0AT sim360-source/port/XCOM4.5.xpl -i2AT </font><font color="#663300"><font color="#663300">sim360-source/port/</font>XPLIB4.5.xpl -f1wb+ XCOM45-360A.obj -f2wb+ XCOM45-360A.dat -f3wb+ XCOM45-360A.str XCOM45-360.obj</font></pre>
</blockquote>These command-line switches differ in detail from the ones we had to with <b>XCOM<i>x</i>-native</b>, but I think you can see that they're just the same old replacements for JCL <font color="#663300"><code>DD</code></font> commands in a different syntax.<br>
<br>
For this denouement of the bootstrapping progress, what are the results?&nbsp; They're the same with both <b>XCOM3</b> and <b>XCOM45</b>, so I'll just explain what we see with <b>XCOM45</b>.<br>
<br>Firstly, th build of <b>XCOM45-360A.obj</b> succeeds with no errors.&nbsp; If <b>XCOM45</b>
 has successfully built itself, we <i>should</i> find that <b>XCOM45-360.obj</b> and 
<b>XCOM45-360A.obj</b> are byte-for-byte identical, except that the embedded 
timestamps for the compile-times will differ.&nbsp; (And of course, if we
 built them on different days, then the embedded datestamp would differ 
as well.)&nbsp; To perform this comparison, I made hexadecimal dumps of 
the two object files, and then used a file-comparison utility to compare
 the hex dumps.&nbsp; Here's a screenshot of the <i>only</i> difference found between the two files, with <b>XCOM45-360.obj</b> on the left and <b>XCOM45-360A.obj</b> on the right:<br>
<br>
<img moz-do-not-send="true" src="XCOM45-360-meld.png" alt="" width="1580" height="89"><br>
<br>
What are the 3 bytes that are different?&nbsp; Well, <b>XCOM45-360.obj</b> was 
built (according to the report it prints out) at time 19:53.37.27, while
<b> XCOM45-360A.obj</b> was built at 17:5:6.24.&nbsp; Now, XCOM gets the 
compile time using <a moz-do-not-send="true" href="#builtin">the built-in function <font color="#663300"><code>TIME_OF_GENERATION</code></font></a>,
 which returns the number of centiseconds since midnight.&nbsp; For 
<b>XCOM45-360.obj</b>, that computes to 
100*(19*3600+60*53+37.27)=7161727=0x6D477F.&nbsp; Similarly, for 
<b>XCOM45-360A.obj</b>, 100*(17*3600+5*60+6.24)=6150624=0x5DD9E0, which 
(surprise!) matches the screenshot above.&nbsp; (Recall that these IBM 
360 programs all store their integer data in <i>big-endian</i> form, so that the most-significant bytes come first in memory.)&nbsp; In short, <b>XCOM45</b><b>-360.obj</b> can indeed accurately build itself, and bootstrapping <b>XCOM45</b> has been 100% successful!<br>
<br>
Or in short, it works!&nbsp; <b>XCOMx</b> can be bootstrapped and accurately builds itself.<br>
<blockquote>
</blockquote>
<h2><a name="halsfc"></a>Compiling and Running HAL/S-FC</h2>
<i>(Most of what's described in this section is not yet functional, but 
I'm writing it while working it out so that my memory is fresh.)</i><br>
<br>
The examples in the preceding section are all very well and good, but the Holy Grail is compilation via <b>XCOM-I</b> of <b>HAL/S-FC</b> itself, and subsequently being able to successfully run <b>HAL/S-FC</b>.&nbsp; Just as there was a big leap in complexity from being able to compile <b>ANALYZER</b> (~1500 lines of XPL) to being able to compile <b>XCOM</b> (~4200 lines of XPL), there's a much larger leap to being able to compile <b>HAL/S-FC</b> (&gt;30,000 lines of XPL).&nbsp; The steps for doing so are also somewhat more complex.<br>
<br>
To compile <b>HAL/S-FC</b>, I'd suggest switching over to the working directory where the <b>HAL/S-FC</b> source code actually is stored, and compiling it there, which looks like this:<br>
<blockquote>
  <pre><font color="#663300">cd .../virtualagc/yaShuttle/"Source Code"/PASS.REL32V0/PASS1.PROCS<br>make<br></font></pre>
</blockquote>
The reason that looks so simple is that I took the trouble to hide the 
complexity the additional complexity I mentioned above by creating a 
Makefile in that folder. &nbsp; HAL/S-FC actually consists of 7 passes, 
each with its own, standalone executable, and the instructions above (if
 they succeed), will thus create 7 new programs in that folder:&nbsp; 
PASS1, FLO, OPT, AUX, PASS2, PASS3, and PASS4. You may or may not want 
to move these into your PATH.&nbsp; The reason you might not want to 
move them into your PATH is that a number of applications written in XPL
 use this kind of naming pattern, and have program names like PASS1, 
PASS2, and PASS3.<br>
<br>
Actually running <b>HAL/S-FC</b> to compile some XPL/I source code is 
also tricky, because the 7 passes are run in succession, with each pass 
passing data into the next pass either explicitly via files, or else via
 <font color="#663300"><code>COMMON</code></font> memory.&nbsp; It's 
thus necessary not merely to run the passes in the correct order, but to
 use all of the command-line settings that attach files with the 
expected names.<br>
<br>
TBD<br>
<h1><a name="xpli"></a>A Primer for Standard XPL and Intermetrics XPL/I</h1>


<p>It is a truth universally acknowledged that there is no satisfactory 
introductory information available concerning programming in XPL.&nbsp; 
Or at least, it <i>would</i> be universally acknowledged if anybody had ever heard of XPL and wanted to use it for anything.&nbsp; <br></p>
<p>The best you can do, generally speaking, is to purchase a used copy of McKeeman (i.e., <i>A Compiler Generator</i>).&nbsp;
 If you do, you'll find a book that's densely packed with information, 
but that information is the source code for an XPL compiler (written in 
XPL), lots of BNF descriptions of the language, lots of theory on how to
 write a compiler-generator program, and very little of direct interest 
to a programmer who wants to come up to speed quickly on how to write or
 understand a program written in XPL.  Not to mention the fact — though I
 <i>am</i> mentioning it! — that some of the most-critical 
counter-intuitive information is buried in easy-to-miss, 
easy-to-misunderstand comments made in passing, rather than as big, 
bold-face warnings. &nbsp; And as a bonus, the book provides an index of
 almost no use at all to a newby XPL programmer.&nbsp; Besides which, 
most <i>online</i> information about XPL, in my experience, is a simple abridgement or other rehashing of <i>A Compiler Generator</i>,
 and adds little extra of value in a tutorial sense, since it's almost 
never written by anybody actually working with XPL.&nbsp; With that 
said, you may find some useful online information in a couple of places:<br></p>

<ul>
  <li>&nbsp;<a moz-do-not-send="true" href="https://sourceforge.net/projects/xpl-compiler/">Daniel Weaver provides some documentation (in particular, his xpl.pdf) with his XPL-to-C translator program</a>.</li>
  <li>The <a moz-do-not-send="true" href="https://www.cs.toronto.edu/XPL/ldindex.html">University of Toronto XPL website has a page</a> with a small but useful transcription of some material from <i>A Compiler Generator</i> — albeit with unfortunate HTML formatting that make some of it almost unreadable.</li>
</ul>
<p>And as for Intermetrics XPL/I ... well, from a tutorial perspective, 
it's orders of magnitude worse.  Perhaps later, non-surviving 
documentation did a better job.&nbsp; Enough said!
</p>

<p>Taking all of that into account, it might be reasonable to provide a 
full tutorial here how to write XPL or XPL/I programs.&nbsp; Perhaps 
I'll do that sometime.&nbsp; It turns out that that's easier said than 
done, since as you may have noticed, simplification for beginners is not
 really my personal strong suit.  Which is ironic, considering my strong
 criticism of <i>A Compiler Generator above</i>!  For now, I'll just 
cover some of the basics and quirks of the language(s).  Send in 
suggestions for improvement, if you like; I'm sure I can use them 
somehow to make the discussion even worse.
</p>
<h2><a name="basics"></a>The Basics</h2>
<h3>Character Set</h3>
<p>The most basic characteristic of a language is the character set in 
which the language is expressed.&nbsp; Neither McKeeman nor Intermetrics
 specifies the character set.&nbsp; I've given it a lot of thought, and 
my conclusion is that the originally-supported character set was:
</p>
<p align="center">&lt;space&gt;<br>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z<br>a b c d e f g h i j k l m n o p q r s t u v w x y z<br>0 1 2 3 4 5 6 7 8 9<br>_ % + - * . / | &amp; = &lt; &gt; # @ $ , ; : ( ) ' " ! ? <br>¢ ¬</p>
<p>You'll notice that several characters common today were not originally supported, including:</p>
<p align="center">` ~ ^ [ ] { }</p>

<p>Contrariwise, there are two characters (¢ and ¬) that don't exist at 
all in the 7-bit ASCII character set that's the common core for the 
character sets typically used today when writing software source 
code.&nbsp; Therefore, when working with <b>XCOM-I</b>, we use the 
characters ~ and ^ interchangeably with ¬ (but prefer ~).&nbsp; 
Similarly, we use ` in preference to ¢.&nbsp; These substitutions allow 
us to completely translate the original XPL or XPL/I source code 
back-and-forth between the original EBCDIC and ACII without any loss of 
information, and without insisting that you adopt any specific "locale" 
like ISO-8859-15 or UTF-8 for your computer that's not optimal for your 
other (non-XPL'ing) activities.&nbsp; With that said, I <i>hope</i> that you could use ¢ and ¬ in your XPL/I source code, if you insist on doing so, but I do not guarantee it.<br></p>
<blockquote>
  <p><font size="-1"><b>Aside:</b> All previously-existing XPL or XPL/I 
source code I've found, or HAL/S source code for that matter, has 
already substituted ~ or ^ for ¬ anyway.  And indeed, some early HAL/S 
documentation suggests this very substitution.  I suspect that's because
 some IBM printers at the time printed ~ in place of </font><font size="-1"><font size="-1">¬</font>.  But whatever the explanation, the substitutions I'm suggesting are not exactly daring in their originality.  As far as the </font><font size="-1">¢
 symbol is concerned, it's not actually used in active XPL or XPL/I 
code, as such, but can be used in program comments to toggle various 
compiler options on and off, or in principle could appear within quoted 
strings.</font></p>
</blockquote>

<h3>Case Sensitivity</h3>
<p>XPL programs are <i>not</i> case-sensitive, except in so far as the 
contents of quoted strings are concerned.&nbsp; E.g., lower-case or 
mixed-case symbols are treated as being identical to their upper-case 
correspondents, but quoted strings are case-sensitive.<br></p>
<h3>Source-Code Formatting<br>
</h3>
<p>Input to an XPL or XPL/I program (via the <font color="#663300"><code>INPUT</code></font>
 built-in function) is expected to conform to computer punch-card-like 
conventions.  I.e., input lines are always exactly 80 characters long, 
and <b>XCOM-I</b> enforces this by truncating or right-padding input 
lines as necessary.  If the input lines are longer than 80 columns 
physically — say, because they have punch-card sequence numbers in 
columns 81-88 — the extra columns are stripped off.<br></p>
<p>As for the source-code proper, other than being confined to columns 
1-80, it is entirely free-form.  I.e., line breaks are ignored; several 
statements may exist on the same input card, or conversely, a single 
statement may be split across multiple cards.  Even though XPL <font color="#663300"><code>CHARACTER</code></font> strings are limited to 256 characters, there is seemingly no limit to the length of an XPL statement.<br></p>
<p>There are hints in the error messages of McKeeman's <b>XCOM</b> (and I believe, in <i>A Compiler Generator</i> text) that <i>some</i>
 contemporary computer systems may have treated column 1 specially, 
perhaps accepting some kind of non-blank control characters there.  If 
so, it was a issue outside <b>XCOM</b> proper and is irrelevant to <b>XCOM-I</b>.
  However, you do find that legacy XPL source code does often begin in 
column 2 rather than column 1, and I suspect that this hypothetical 
column-sensitivity is the reason for it.<br></p>
<p>Regarding this column-1 ambiguity, however, there is the practical 
question of what to do when a long quoted string is split across 
multiple cards.  Does column 1 belong to the string or not?  In <b>XCOM-I</b>, I take my cue from McKeeman's source code for <b>XCOM</b> in this matter:  In spite of the fact that <b>XCOM</b>'s source code generally avoids column 1 in all other cases, column 1 <i>does</i> belong to any multi-line quoted strings.<br></p>

<h3>Identifiers</h3>
<p>Identifiers cannot begin with a digit, but otherwise consist of any sequence of upper- or lower-case alphanumeric characters, <i>or</i> any of the characters @ _ # $.&nbsp; For example, @_26$8ab# is a legal name for a variable.
</p>
<p>Identifiers cannot exceed 256 characters in length.
</p>
<h3><a name="datatypes"></a>Datatypes, Declarations, and Literals<br>
</h3>
<p></p>
<h4>The Basic XPL Datatypes</h4>
<p>There are only three basic datatypes:<br></p>

<ul>

  <li><font color="#663333"><code>FIXED</code></font> is a 32-bit signed
 integer.&nbsp; (Stored as 2's-complement, in big-endian byte order, vs 
the little-endian byte order used in most personal computers today.)<br></li><li><font color="#663333"><code>CHARACTER</code></font>
 is a variable-width character string, with a string-length limited to 
256 or less.&nbsp; Strings are stored as a 32-bit unsigned integer known
 as a <i>descriptor</i>, paired with a separate area from 1 to 256 bytes
 containing the individual characters of the string, encoded in 
EBCDIC.&nbsp; The descriptor has 8 bits specifying the string length 
(minus 1) and 24-bits providing the starting memory-address of the 
character data.</li><li><font color="#663333"><code>BIT(n)</code></font>, where <font color="#663333"><code>n</code></font> is from 1 to 2048, is an <font color="#663333"><code>n</code></font>-bit object.&nbsp; The amount of storage varies by the precision:</li><ul><li><font color="#663333"><code>BIT(1)</code></font> through <font color="#663333"><code>B(8)</code></font> are stored in memory as single bytes.</li><li><font color="#663333"><code>BIT(9)</code></font> through <font color="#663333"><code>BIT(16)</code></font> are stored as 2-byte "half-words".</li><li><font color="#663333"><code>BIT(17)</code></font> through <font color="#663333"><code>BIT(32)</code></font> are stored as 32-bit words.</li>
  <li><font color="#663300"><code>BIT(33)</code></font> through <font color="#663300"><code>BIT(2048)</code></font> are stored similarly to <font color="#663300"><code>CHARACTER</code></font>
 variables: There's a 32-bit "descriptor", of which 8 bits is the number
 of bytes needed to store all of the bits, minus 1, and 24 bits area 
pointer to elsewhere in memory, where the bytes themselves are stored.  
Thus, a long <font color="#663300"><code>BIT(n)</code></font> like this uses up 4 bytes for the descriptor, plus ⌊(n+7)/8⌋ bytes (5 for n=33 through 256 for n=2048) for the data. </li>
</ul>
</ul>

<blockquote>
  <p><font size="-1"><b>Aside:</b> The method for storing </font><font size="-1"><font color="#663333"><code>CHARACTER</code></font> data described above leaves no room for 0-length "empty" strings.  But the XPL and XPL/I languages <i>do</i>
 allow for empty strings: p. 207 of McKeeman tells us that an 
empty-string is represented by a string-descriptor with the value 
0x00000000, with no extra memory allocation for the non-existent "data" 
of the string.  This isn't ambiguous, by the way.  While 0x00000000 <i>technically</i>
 appears to be a descriptor for a 1-byte string whose data is located at
 address 0x000000, in fact address 0x000000 would always have been 
outside of the block of memory dedicated for storage of EBCDIC string 
data, rendering a descriptor of 0x00000000 unusable under the normal 
interpretation.</font><br></p>
</blockquote>
<ul>

</ul>

<p>The storage formats in memory duplicate those that would have been 
expected on an IBM System/360 computer, within the limits of my ability 
to infer what those formats were.&nbsp; While the storage formats are 
not significant in abstract terms, they'll be seen to be <i>quite</i> significant in dealing with certain aspects of <b>HAL/S-FC</b>'s source code, such as its so-called "virtual memory" system, and indeed I think it would be impossible to run <b>HAL/S-FC</b> unless these underlying IBM 360 storage formats were used.<br></p>You'll notice that there is no floating-point datatype, a fact which will be discussed in some detail later. <br>
<br>

The three basic datatypes can also be incorporated into single-dimension arrays. 
Multi-dimensional arrays are not allowed.&nbsp; There is no maximum 
array length beyond the available memory.&nbsp; Array indices start at 
0.&nbsp; Indices (or "subscripts") are enclosed in parentheses, as in <font color="#663300"><code>A(3)</code></font> or <font color="#663300"><code>B(N)</code></font>.&nbsp; <br>
<blockquote><font size="-1"><b>Aside:</b> It's easy to become confused and to imagine (incorrectly!) that you can treat a <font color="#663333"><code>CHARACTER</code></font> variable (as opposed to an array of <font color="#663333"><code>CHARACTER</code></font>
 variables) as an array itself, in order to access its individual 
characters.&nbsp; You cannot!&nbsp; In fact, the XPL language does not 
provide <i>any</i> syntactical means to access individual characters of a
 string.&nbsp; For that, you must rely on built-in functions provided by
 the runtime library.&nbsp; The most-direct method is to use the <font color="#663300"><code>BYTE</code></font> function, which can either retrieve the EBCDIC numerical encoding of an individual character in a <font color="#663333"><code>CHARACTER</code></font> variable, or else to store a new EBCDIC numerical value at a given position in a <font color="#663333"><code>CHARACTER</code></font> variable.&nbsp; Thus if we had a <font color="#663333"><code>CHARACTER</code></font> variable <font color="#663300"><code>C</code></font> which held the value 'HELLO!', then <font color="#663300"><code>BYTE(C, 3)</code></font> would return 211 (the EBCDIC encoding for the letter 'L'), while the assignment statement "<font color="#663300"><code>BYTE(C, 3) = 198;</code></font>" would change the contents of <font color="#663300"><code>C</code></font>
 to 'HELFO' since 198 is the EBCDIC code for the letter 'F'.&nbsp; That 
sounds cumbersome, since very few of us have memorized the EBCDIC table,
 but it's really not.&nbsp; You generally don't have to look up the 
EBCDIC encoding for anything, because you would actually have programmed
 operations such as this as "<font color="#663300"><code>BYTE(C, 3) = BYTE('F');</code></font>".&nbsp; Another, less-generally-useful method would be to use the built-in <font color="#663300"><code>SUBSTR</code></font> function to retrieve a specific character position as a new <font color="#663300"><code>CHARACTER</code></font> object of length 1.<br></font></blockquote><font size="-1">
    </font>The <font color="#663333"><code>BIT(N)</code></font> datatype is actually quite problematic.&nbsp; It would be reasonable to assume that since <font color="#663333"><code>BIT(N)</code></font>
 seems to represent support for collections of bits, then XPL should 
provide some syntactical sugar for reading the values of these bits or 
modifying them.&nbsp; For <font color="#663333"><code>BIT(1)</code></font> through <font color="#663333"><code>BIT(32)</code></font>, you'd be somewhat correct, in that XPL largely treats these as being interchangeable with integers (i.e., <font color="#663333"><code>FIXED</code></font>), and automatically converts them back and forth between <font color="#663333"><code>FIXED</code></font>.&nbsp; The runtime library's built-in logical-shift-left and logical-shift-right functions (<font color="#663300"><code>SHL</code></font> and <font color="#663300"><code>SHR</code></font>) work just as easily with them as with the <font color="#663333"><code>FIXED</code></font>, as do the logical operators <font color="#663300"><code>&amp;</code></font>, <font color="#663300"><code>|</code></font>, and <font color="#663300"><code>¬</code></font> (<font color="#663300"><code>~</code></font>), and the relational operators <font color="#663300"><code>&lt;</code></font>, <font color="#663300"><code>&gt;</code></font>, <font color="#663300"><code>=</code></font>, <font color="#663300"><code>!=</code></font>, <font color="#663300"><code>&gt;=</code></font>, and <font color="#663300"><code>&lt;=</code></font>.&nbsp; Swell!<br>
<br>
But once you advance to <font color="#663333"><code>BIT(32)</code></font> through <font color="#663333"><code>BIT(2048)</code></font>, you are cruelly disappointed. &nbsp; XPL provides <i>no</i> built-in methods of working with this data, beyond the ability to initialize <font color="#663333"><code>BIT(N)</code></font>
 variables with data when they're declared.&nbsp; (More on that 
later.)&nbsp; As far as actually using this data for anything, there are
 no built-in means to do anything at all with that data.&nbsp; While you
 <i>can</i> manipulate the data by cobbling together various 
runtime-library memory-access functions, McKeeman gives none of the 
technical information about the storage format that would allow you to 
do so, in so far as I was able to discover.<b>&nbsp; </b>What do I mean about cobbling together memory-access functions?&nbsp; Well, suppose that you want to access bit 43 of a <font color="#663300"><code>BIT(86)</code></font> variable called <font color="#663300"><code>B</code></font>.&nbsp; First, you must know where the data for <font color="#663300"><code>B</code></font>
 is located in memory.&nbsp; There's a function that can tell you 
that.&nbsp; Then you must know which byte in that block contains bit 
43.&nbsp; There's no function that tells you that, but if you <i>do</i> 
know it somehow then there's a function that gives you the value of a 
byte at that address.&nbsp; Then you must know which bit in the byte 
corresponds to bit 43.&nbsp; Again, there's no function for that, but if
 you know it, then you can use library functions like <font color="#663300"><code>SHL</code></font> or <font color="#663300"><code>SHR</code></font>, probably in conjunction with a logical operator like <font color="#663300"><code>&amp;</code></font>,
 to isolate the value of that bit.&nbsp; If you wanted to change the 
value of that bit, different but similar awfulness is involved.<br>
<br>
But doing any of that requires that you have intimate knowledge of how such <font color="#663333"><code>BIT</code></font>
 data is packed into memory.&nbsp; It's hard to write unambiguously 
about these matters, but I'll try to do so using the following 
concepts:&nbsp; An <i>n</i>-bit value, when written out in human-readable form has a <i>leftmost</i> bit and a <i>rightmost</i> bit; meanwhile, a block of <i>m</i> bytes in memory has a byte that's at the <i>lowest</i> address, a byte at the <i>highest</i> address, and within each byte has a <i>most-significant</i> bit and a <i>least-significant</i> bit.&nbsp; With those ideas in mind, here's how XPL packs <font color="#663333"><code>BIT</code></font> data into memory:<br>
<ul>
  <li><font color="#663333"><code>BIT(1)</code></font> through <font color="#663333"><code>BIT(32)</code></font>:  The rightmost bit corresponds to the least-significant bit in the byte at the highest address.</li>
  <li><font color="#663333"><code>BIT(32)</code></font> through <font color="#663333"><code>BIT(2048)</code></font>:  The leftmost bit corresponds to the most-significant bit in the byte at the lowest address.</li>
</ul>
Or to put it concisely if ambiguously, short bit strings are right justified, while long bit strings are left justified.<br>
<blockquote><font size="-1"><b>Aside:</b>&nbsp; Since I say that the 
bit-packing is undocumented, what's my justification for claiming that 
what I said just above is true?&nbsp; The short answer is 
trial-and-error!&nbsp; The longer answer is that one of the intermediate
 milestones in trying to get <b>XCOM-I</b> to the point of being able to compile the original source code for <b>HAL/S-FC</b> was first to be able to compile McKeeman's original <b>XCOM</b>
 and run it with a verifiably correct result.&nbsp; But I couldn't get 
it to work!&nbsp; After messing with it for days on end, I eventually 
got the answer in a dream, and then experimented with a couple of 
different bit-packing schemes before finally getting <b>XCOM</b> to run properly.&nbsp; The packing scheme I describe above is the one that worked.</font><br>
</blockquote>
<font size="-1"></font>
<blockquote><font size="-1">
    <b>Aside:</b> If all that wasn't bad enough, there's also a trap waiting for you if you're already used to doing bit manipulations 
with logical operators and shifts in other computer languages.&nbsp; This trap is in the behavior of 
conditional tests in XPL's <font color="#663300"><code>IF</code></font> and <font color="#663300"><code>DO WHILE</code></font> statements.&nbsp; Conditional tests in these statements depend only on the <i>least significant</i> bit; i.e., it as if any conditional test involves an extra "<font color="#663300"><code>&amp; 1</code></font>" operation that you can't see.&nbsp; Thus if you wanted to detect (say) that bit 3 of the <font color="#663300"><code>BIT(5)</code></font> variable <font color="#663300"><code>A</code></font> was set, a statement like "<code><font color="#663300">IF A &amp; 8 THEN ...;</font></code>" wouldn't help you at all, since the implicit </font><font size="-1"> "<font color="#663300"><code>&amp; 1</code></font>" in the conditional would cause the test always to fail!&nbsp; You would instead need to use a shift-right operation, such as </font><font size="-1"><font size="-1">"<code><font color="#663300">IF SHR(A, 3) THEN ...;</font></code>". </font></font><font size="-1"><font size="-1"><br>
    </font></font></blockquote>


But enough of these measly <font color="#663333"><code>BIT</code></font>-based frustrations!<br>
<br>
Variables in general are <i>supposedly</i> strictly typed, and every variable used 
must have an associated declaration statement, though we've already seen
 examples of the casual way XPL/I treats XPL's strict typing with subscripting sloppiness.<br>
<br>
Here are a few examples of declarations of variables, both scalar and array:<br>
<blockquote>
  <pre><font color="#663300">DECLARE F FIXED, C CHARACTER, B BIT(5);<br>DECLARE FS(10) FIXED, CS(10) CHARACTER, BS(10) BIT(5);</font><br></pre>
</blockquote>

These are pretty self-explanatory in most ways, so I won't dissect them 
for you in detail.&nbsp; What's perhaps most confusing is that the three
 arrays declared here (<font color="#663300"><code>FS</code></font>, <font color="#663300"><code>CS</code></font>, and <font color="#663300"><code>BS</code></font>) each have <i>eleven</i>
 elements in them, because the number 10 in their declarations is not 
the number of elements, but rather the highest legal index.&nbsp; As 
mentioned above, indices start at 0, so the total number of elements in 
each is 11. <br>
<blockquote><font size="-1"><b>Aside:</b> Standard XPL, <i>à la</i> 
McKeenan, doesn't allow expressions when expressing array sizes, whereas
 XPL/I does allow them.&nbsp; For example, the following is fine in 
XPL/I but is a no-no in XPL:<br>
  </font>
  <blockquote>
    <pre><font size="-1">DECLARE BUFFER(3600-1) BIT(8);<br></font></pre>
  </blockquote>
  <font size="-1">This example will be continued in the next section, 
where it will make a little more sense, but this is actually the kind of
 thing you might want to do.</font><br>
</blockquote>

<br>
There are additional attributes which can be applied to such declarations, of which the most important is probably <code><font color="#663300">INITIAL</font></code>.&nbsp; This attribute allows you to supply an initial value for the variable, such as:<br>
<blockquote>
  <pre><font color="#663300">DECLARE F FIXED INITIAL(22), F2 FIXED INITIAL("22"), F3 FIXED INITIAL("(8) 22");<br>DECLARE C CHARACTER INITIAL('Hello!');<br>DECLARE B BIT(5) INITIAL("(1) 10100");<br>DECLARE FS(10) FIXED INITIAL(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11);</font><br></pre>
</blockquote>
It's important to understand that the initializer has its affect only at
 compile-time, and is not applied at run-time.&nbsp; That means that if 
you declare variables within <font color="#663300"><code>PROCEDURE</code></font>s, they're <i>not reinitialized</i> each time the <font color="#663300"><code>PROCEDURE</code></font> is executed.<br>
<br>
You may have been confused by the initializers shown above for the variables <font color="#663300"><code>F2</code></font>, <font color="#663300"><code>F3</code></font>, and <font color="#663300"><code>B</code></font>,
 since they naively appear to be strings instead of numbers; but the 
naive interpretation is wrong.&nbsp; Which brings up the nature of <i>literals</i> in XPL:<br>
<ul>
  <li><code><font color="#663300">CHARACTER</font></code> literals — 
i.e., text strings — are enclosed in single-quote (') characters.  If a 
single-quote itself must appear within the string, you use two 
single-quotes in succession.  For example: <font color="#663300"><code>'I am the ''king'' of the world!'</code></font>.</li>
  <li>Integer literals for <font color="#663300"><code>FIXED</code></font> or <font color="#663300"><code>BIT(N)</code></font> have one of several forms:</li>
  <ul>
    <li>A sequence of decimal digits is interpreted as a non-negative 
number in base-10 in the usual way.  Note that a leading minus sign (-) 
or plus sign (+) is <i>not</i> part of a numeric literal!  In XPL, minus signs are only <i>operators</i>, and thus something like <font color="#663300"><code>-10</code></font>
 is not a literal for the number -10, but is instead the minus operator 
followed by the literal for the number 10.  In most cases this is a 
distinction without significance, because <b>XCOM-I</b> (or the original <b>XCOM</b>)
 automatically tries to perform all computations that are possible at 
compile time.  Nevertheless, this distinction does cause some 
arithmetically-satisfactory expressions to be syntactically illegal in 
XPL.  For example, the expression <font color="#663300"><code>5 + -5</code></font> isn't legal in XPL.</li>
    <li>A sequence of hexadecimal digits enclosed in double-quote (") 
characters represents a hexadecimal number.  Spaces are ignored within 
literals like this, and hence can be added at will for improved human 
readability.</li>
    <li>If a double-quoted string is preceded (within the quotes) by a 
parenthesized decimal number, then that number indicates the number of 
bits represented by each digit.  <b>XCOM-I</b> supports only the following cases:</li>
    <ul>
      <li>"(1) ..." (with digits 0-1 and spaces) is a binary number.</li>
      <li>"(2) ..." (with digits 0-3 and spaces) is a base-4 number.</li>
      <li>"(3) ..." (with digits 0-7 and spaces) is an octal number.</li>
    </ul>
  </ul>
</ul>

These numeric literals are the only syntactical reason that the double-quote character (") appears in XPL source code.<br>
<br>
Another important attribute is <font color="#663300"><code>LITERALLY</code></font>. It's not strictly related to declaration of variables, even though appearing in <font color="#663300"><code>DECLARE</code></font> statements and so it's discussed in the next section instead.<br>
<h4>
<a name="basedManagement"></a>XPL/I ARRAY and BASED Data</h4>

XPL/I provides a separate kind of statement which can declare arrays, which syntactically differs only in that the keyword <font color="#663300"><code>ARRAY</code></font> is used in place of the keyword <font color="#663300"><code>DECLARE</code></font>, and in that it can only be used for arrays of <font color="#663300"><code>FIXED</code></font> or <font color="#663300"><code>BIT</code></font>, and not for <font color="#663300"><code>CHARACTER</code></font>.<br>
<blockquote><font size="-1"><b>Aside:</b> For the original XPL/I compiler, I believe there was a distinction in the way <font color="#663300"><code>ARRAY</code></font> variables were stored in memory vs <font color="#663300"><code>DECLARE</code></font> variables.&nbsp; At the present time, I don't see this distinction as being operationally significant, so <b>XCOM-I</b>
 treats the two keywords identically.&nbsp; This is subject to change, 
if I discover my thinking was in error.&nbsp; As, unfortunately, I often
 do. </font><br>
</blockquote>

More significantly, XPL/I adds an additional kind of datatype that it calls a <font color="#663300"><code>BASED</code></font> variable.&nbsp; These are basically <i>pointers</i> to arrays of <font color="#663300"><code>FIXED</code></font>, <font color="#663300"><code>BIT</code></font>, or <font color="#663300"><code>CHARACTER</code></font>.&nbsp; Note that I said "pointers to arrays" rather than "arrays of pointers".&nbsp; By changing the address stored in the <font color="#663300"><code>BASED</code></font>
 variable's pointer, you can instantly interpret an entirely different 
chunk of memory as the array.&nbsp; Moreover, besides the basic types 
just mentioned, the <font color="#663300"><code>BASED</code></font> variable can point to an array of "records", where each "record" is a collection of the basic 
datatypes.&nbsp; I.e., a record can hold any combination of <font color="#663300"><code>FIXED</code></font>, <font color="#663300"><code>BIT</code></font>, or <font color="#663300"><code>CHARACTER</code></font> fields, or arrays thereof.&nbsp; Using the <font color="#663300"><code>BASED</code></font>
 mechanism, XPL/I can thus mimic both pointers and primitive types of 
structures, neither of which is available in XPL proper.&nbsp; I say 
that the structures are "primitive", because <font color="#663300"><code>BASED</code></font> variables cannot themselves be fields of <font color="#663300"><code>BASED</code></font> variables, hence only structures that are a single-level deep are available.&nbsp; <br>
<br>
Here are a couple of examples of declarations of <font color="#663300"><code>BASED</code></font> variables:<br>
<blockquote>
  <pre><font color="#663300">BASED FB FIXED;<br>BASED RB RECORD:<br>    F FIXED,<br>    C CHARACTER,<br>    A(10) BIT(5),<br>END;</font><br></pre>
</blockquote>

Although <font color="#663300"><code>BASED</code></font> variables are always (or almost always) arrays, you'll note that the declarations of <font color="#663300"><code>FB</code></font> and <font color="#663300"><code>RB</code></font>
 don't indicate any dimensional information.&nbsp; That's because no 
memory for them, other than for the pointer, is allocated at 
compile-time.&nbsp; Space is instead explicitly allocated at runtime by 
user code.&nbsp; Thus <b>XCOM-I</b> has knowledge of the <i>size</i> of each array entry, but not of the <i>number of elements</i> in the array.&nbsp; <br>
<blockquote><i>(Some of the material covered in this inset discussion of "dope vectors" has not yet been implemented in </i><i><b>XCOM-I</b></i><i>.)</i><br>
  <br>
When I said that a <font color="#663300"><code>BASED</code></font> is a "pointer to an array", I was glossing over the fact that to be useful a <font color="#663300"><code>BASED</code></font> must track a lot more information about the <font color="#663300"><code>BASED</code></font> than just its data's location in memory.&nbsp; In fact, a <font color="#663300"><code>BASED</code></font> is stored as a 28-byte structure <i>plus</i>
 the separately-positioned data for the array.&nbsp; The 28-byte 
structure is referred to as a "dope vector". &nbsp; In other words, if 
you had a <font color="#663300"><code>BASED</code></font> called (say) <font color="#663300"><code>MYBASED</code></font> and you executed the built-in function <font color="#663300"><code>ADDR(MYBASED)</code></font>, it would return the address of the dope vector for <font color="#663300"><code>MYBASED</code></font>.&nbsp; As usual, the <b>HAL/S-FC</b>
 documentation and source code do not actually provide any useful facts 
about this setup, but various factoids can be inferred from <b>HAL/S-FC</b> source code, to a greater or lesser degree of confidence, and here are my feeble inferences about the fields of dope vectors:<br>
  <ol>
    <li><font color="#009900"><font color="#663300"><code>FIXED</code></font> pointer giving the address of the actual data.</font></li>
    <li><font color="#009900"><font color="#663300"><code>BIT(16)</code></font> giving the size in bytes of each array entry.</font></li>
    <li><font color="#009900"><font color="#663300"><code>BIT(16)</code></font></font> <font color="#009900">gives the number of <font color="#663300"><code>CHARACTER</code></font> or <font color="#663300"><code>BIT(≥32)</code></font> fields in each <font color="#663300"><code>BASED RECORD</code></font>, or 1 if it's a <font color="#663300"><code>BASED CHARACTER</code></font> or <font color="#663300"><code>BASED </code><code>BIT(≥32)</code></font>, or 0 otherwise.  The point is that it's the number of "string descriptors" associated with each element of the <font color="#663300"><code>BASED</code></font> array.  This information is used by </font><font color="#663300"><code>COMPACTIFY</code></font>.  (<a moz-do-not-send="true" href="#compactify">See below</a>.)  While I don't fully understand the calculations being performed, I'd venture the opinion that for <font color="#663300"><code>COMPACTIFY</code></font> to use this information efficiently, it's necessary for the XPL/I compiler to rearrange the fields of <font color="#009900"><font color="#663300"><code>BASED RECORD</code></font></font> from their declared order in such a way that all of string-descriptor fields come first in the record. </li>
    <li><font color="#009900"><font color="#009900"><font color="#663300"><code>FIXED</code></font></font> giving the total number of array entries for which space has been <i>allocated</i>.</font></li>
    <li><font color="#009900"><font color="#009900"><font color="#663300"><code>FIXED</code></font></font> giving the total number of array entries actually <i>used</i> so far.</font></li>
    <li><font color="#009900"><font color="#009900"><font color="#663300"><code>FIXED</code></font></font></font>.
  I think that perhaps all of the dope vectors form a linked list, and 
that this is the address of the next dope vector in the list, presumably
 in order of increasing pointers.  The list is terminated when a value 
of 0 is found.  Thus the process of finding usable holes in memory — or 
at least the portion of memory dedicated to <font color="#009900"><font color="#663300"><code>BASED</code></font></font> variables (vs character strings) — is just the process of searching this linked list.<br></li>
    <li><font color="#009900"><font color="#663300"><code>FIXED</code></font></font>.  It appears to me that this field supplies some properties of the <font color="#663300"><code>BASED</code></font> in the form of bit fields. It is laid out as follows:<br></li>
    <ul>
      <li>Bit 24 indicates the <font color="#663300"><code>BASED</code></font> is "constant", which appears to mean that you cannot incrementally grow it.  (The macro <font color="#663300"><code>NEXT_ELEMENT(<i>based</i>)</code></font> is used to increase the size of the specified <font color="#663300"><code><i>based</i></code></font> by 1 record, an operation which fails if the <font color="#663300"><code><i>based</i></code></font> is "constant".)</li>
      <li>Bit 25 indicates the <font color="#663300"><code>BASED</code></font> is "unmoveable".  If a <font color="#663300"><code><i>based</i></code></font> is "unmovable", it means that an operation like <font color="#663300"><code>NEXT_ELEMENT(<i>based</i>)</code></font>
 (see above) will succeed only if there is enough free space immediately
 following the allocated memory that can be "stolen".  Whereas if it's 
not unmovable, then the <font color="#663300"><code><i>based</i></code></font> may migrate in its entirety to a newly-allocated block elsewhere and the space it originally occupied may thus be freed.<br></li>
    </ul>
    <li><font color="#009900"><font color="#663300"><code>BIT(16)</code></font></font> of purpose TBD.  It is referred to as "global factor".</li>
    <li><font color="#009900"><font color="#663300"><code>BIT(16)</code></font></font> is referred to as "group factor".  As far as I can see, all uses of this are commented out in <b>HAL/S-FC</b>, so perhaps it ended up being unused.<br></li>
  </ol>

The <b>XCOM-I</b> implementation mimics this dope-vector structure, though only the fields I've highlighted in <font color="#009900">green</font> are significant in <b>XCOM-I</b> ... which is fortunate, since they're the only ones I imagine I understand somewhat.<br>
  <br>
With that discussion in mind, in understanding some of the things that need to happen with <font color="#663300"><code>BASED</code></font> variables in actual XPL/I source code (and in particular, in <b>HAL/S-FC</b>), let's consider various space-management macros and/or procedures used:<br>
  <ul>
    <li><font color="#663300"><code>RECORD_ALLOC(<i>based</i>)</code></font>, used in expressions, returns the number of records allocated in <font color="#663300"><code>BASED</code></font> variable <font color="#663300"><code><i>based</i></code></font>.</li>
    <li><font color="#663300"><code>RECORD_USED(<i>based</i>)</code></font>,
 normally used on the left-hand-side in assignments, sets the number of 
records used so far in based.  Its most-common usage is <font color="#663300"><code>RECORD_USED(<i>based</i>)=RECORD_ALLOC(<i>based</i>)</code></font>,
 but it can also be used with something other than that on the 
right-hand side to truncate the array or to skip past the lowest 
indexes.  And it can be used in expressions or conditionals, though that
 happens relatively seldom.</li>
    <li><font color="#663300"><code>RECORD_TOP(<i>based</i>)</code></font>, as you might expect, simply returns <font color="#663300"><code>RECORD_USED(<i>based</i>)-1</code></font>.</li>
    <li><font color="#663300"><code>ALLOCATE_SPACE(<i>based</i>, <i>top</i>)</code></font> allocates enough space for <i><font color="#663300"><code>based</code></font></i> to insure that it contains at least <font color="#663300"><code><i>top</i>+1</code></font> records in total.  It will fail if we already have <font color="#663300"><code>RECORD_ALLOC(<i>based</i>)&gt;0</code></font>.</li>
    <li><font color="#663300"><code>NEXT_ELEMENT(based)</code></font> increments <font color="#663300"><code>RECORD_USED(<i>based</i>)</code></font>
 by 1, stealing the space from adjacent free memory or else reallocating
 and moving the entire array if necessary to do so.  This can only be 
used if space for <font color="#663300"><code><i>based</i></code></font> had been allocated by <font color="#663300"><code>ALLOCATE_SPACE</code></font>, and will instead cause an abend if <font color="#663300"><code><i>based</i></code></font> had been allocated by <font color="#663300"><code>RECORD_CONSTANT</code></font> (see below).</li>
    <li><font color="#663300"><code>RECORD_FREE(based)</code></font> frees the data for <i><font color="#663300"><code>based</code></font></i>, returning the allocated space to the free pool.</li>
    <li><font color="#663300"><code>RECORD_SEAL(<i>based</i>)</code>, <code>RECORD_UNSEAL(<i>based</i>)</code></font>:  Enables or disables the "constant" attribute of the <i><font color="#663300"><code>based</code></font></i>.</li>
    <li><font color="#663300"><code>RECORD_CONSTANT(<i>based</i>, <i>top</i>, <i>moveable</i>)</code></font> Like <font color="#663300"><code>ALLOCATE_SPACE(<i>based</i>, <i>top</i>)</code></font>, but additionally enables the "constant" property, and optionally enables the "unmovable" property.</li>
    <li><font color="#663300"><code>RECORD_WIDTH(based)</code></font> returns the record width of the <i><font color="#663300"><code>based</code></font></i>.</li>
    <li><font color="#663300"><code>RECORD_LINK()</code></font> prepares the data for transferring <font color="#663300"><code>COMMON</code></font> memory to the next program loaded.</li>
  </ul>
  <p>I'd note that as long as effective versions of these macros are provided, along with a working <font color="#663300"><code>COMPACTIFY</code></font>, it doesn't really matter if the dope-vector properties are implemented or not.<br></p>
</blockquote>

User code that initially allocates free memory — let's say 25 records to start with —  for a <font color="#663300"><code>BASED</code></font> variable is <i>typically</i> a two-step process that looks something like this:<br>
<blockquote>
  <pre><font color="#663300">BASED MYVARIABLE FIXED;<br>...<br>RECORD_CONSTANT(MYVARIABLE, 25, MOVEABLE); /* OR UNMOVEABLE */<br>RECORD_USED(</font><font color="#663300"><font color="#663300">MYVARIABLE</font>) = RECORD_ALLOC(</font><font color="#663300"><font color="#663300">MYVARIABLE</font>);</font><br></pre>
</blockquote>
Or, if you knew that you were going to need more elements later, you might allocate a bit extra, for example:<br>
<blockquote>
  <pre><font color="#663300">BASED MYBASED FIXED;<br>...<br>ALLOCATE_SPACE(</font><font color="#663300"><font color="#663300">MYBASED</font>, 30);<br>RECORD_USED(</font><font color="#663300"><font color="#663300"><font color="#663300">MYBASED</font></font>) = 25;</font></pre>
</blockquote>

Having allocated the space for it, you can now use <font color="#663300"><code>MYBASED</code></font> just like any other array of <font color="#663300"><code>FIXED</code></font>, such as in assignments like "<font color="#663300"><code><font color="#663300"><code>MYBASED</code></font>(27) = 6;</code></font>" or "<font color="#663300"><code>X = </code></font><font color="#663300"><code><font color="#663300"><code>MYBASED</code></font>(N) + 12;</code></font>".&nbsp; <br>
<br>
To actually increase the number of elements later, you'd do something like this:<br>
<blockquote>
  <pre><font color="#663300">NEXT_RECORD(MYBASED);</font><br></pre>
</blockquote>
This will increment <font color="#663300"><code>RECORD_USED(MYBASED)</code></font> by 1 — if possible while still keeping it below <font color="#663300"><code>RECORD_ALLOC(MYBASED)</code></font> — or else will reallocate and possibly move <font color="#663300"><code>MYBASED</code></font> into a larger space, if possible.<br>
<br>
In a more-complex case, we might have a <font color="#663300"><code>BASED RECORD</code></font> variable:<br>
<blockquote>
  <pre><font color="#663300">BASED MYNEWBASED RECORD:<br>    F FIXED,<br>    C CHARACTER,<br>    A(9) FIXED,<br>END;<br>...<br>RECORD_CONSTANT(</font><font color="#663300"><font color="#663300">MYNEWBASED</font>, 30, MOVEABLE);<br>RECORD_USED(</font><font color="#663300"><font color="#663300"><font color="#663300">MYNEWBASED</font></font>) = 25;</font></pre>
</blockquote>

Accessing <font color="#663300"><code>MYNEWBASE</code></font> requires the dotted style often used these days for 
accessing fields of structures or classes.&nbsp; Some examples include:<br>
<blockquote>
  <pre><font color="#663300">MYNEWBASED(6).F = 12;<br>MYNEWBASED(10).C = 'XPL is where it is at!';<br>MYNEWBASED(20).A(6) = 15;<br>X = MYNEWBASED(6).F;</font><br></pre>
</blockquote>
and so on.<br>
<h3>LITERALLY and Macros</h3>Another attribute that can appear in <font color="#663300"><code>DECLARE</code></font> statements is the <font color="#663300"><code>LITERALLY</code></font> attribute.&nbsp; Here's an example:<br>
<blockquote>
  <pre><font color="#663300">DECLARE ARRAYTOP LITERALLY '255';<br>DECLARE MYARRAY(ARRAYTOP) FIXED;</font><br></pre>
</blockquote>
Notice that <font color="#663300"><code>ARRAYTOP</code></font> has no 
datatype assigned to it.&nbsp; That's because its declaration is not 
actually the declaration of a variable called "ARRAYTOP", but rather of a
 macro of that name.&nbsp; Wherever the identifier <font color="#663300"><code>ARRAYTOP</code></font> is encountered subsequently, it's simply replaced literally by the string <font color="#663300"><code>255</code></font>, now unquoted:<br>
<blockquote>
  <pre><font color="#663300">DECLARE MYARRAY(255) FIXED;</font><br></pre>
</blockquote>
This clarifies an example of a commonly-desirable declaration I gave in 
the preceding section, which in this section would be expressed as:<br>
<blockquote>
  <pre><font color="#663300">DECLARE RECSIZE LITERALLY '3600';<br>DECLARE BUFFER(RECSIZE-1) BIT(8);</font><br></pre>
</blockquote>

As noted in the preceding section, standard XPL's grammar wouldn't allow an expression (like <font color="#663300"><code>RECSIZE-1</code></font>) in that context, so this particular convenience in making declarations is only available in XPL/I.<br>
<br>
Macro expansions — not macro <i>declarations</i> (I hope!) — can be nested, so you can do things like this if you want:<br>
<blockquote>
  <pre><font color="#663300">DECLARE DEVICE LITERALLY '6', DECLARE OUT LITERALLY 'OUTPUT(DEVICE)';<br>OUT = 'My message';</font><br></pre>
</blockquote>
This expands to<br>
<blockquote>
  <pre><font color="#663300">OUTPUT(6) = 'My message';</font><br></pre>
</blockquote>
Macros can expand to portions of statements, as the ones above have, or to multiple statements, such as<br>
<blockquote>
  <pre><font color="#663300">DECLARE MYBLOCK LITERALLY 'DO; X=1; Y=X+3; END';<br>...<br>IF X=7 THEN;<br>    MYBLOCK;</font><br></pre>
</blockquote>
which expands to:<br>
<blockquote>
  <pre><font color="#663300">IF X=7 THEN;<br>    DO; X=1; Y=X+3; END;</font><br></pre>
</blockquote>
Macros can also have arguments.&nbsp; Consider the following:<br>
<blockquote>
  <pre><font color="#663300">DECLARE MYMAC(2) LITERALLY '%1% = %2%';</font><br></pre>
</blockquote>
This declaration means that <font color="#663300"><code>MYMAC</code></font> has 2 arguments, and that when the macro is expanded, the first argument will replace <font color="#663300"><code>%1%</code></font> and the second argument will replace <font color="#663300"><code>%2%</code></font>.&nbsp; Thus "<font color="#663300"><code>MYMAC(X, 3 * Y)</code></font>" expands to "<font color="#663300"><code>X = 3 * Y</code></font>".<br>
<blockquote><font size="-1"><b>Warning:</b>&nbsp; As with macros in any other computer language, this can quickly get out of hand.&nbsp; <b>XCOM-I</b>,
 for example, won't detect recursive, endlessly-expanding macros.&nbsp; 
There's also no guarantee when multiple macros are in play that <b>XCOM-I</b> will necessarily expand macros in the same order that <b>XCOM</b> would have.&nbsp; Neither McKeeman nor Intermetrics documentation makes any mention of what that ordering should be.<br>
    <br>
    <b>Warning:</b>&nbsp; The scope of macro definitions is also 
different in XPL vs XPL/I.&nbsp; In XPL, macro definitions don't respect
 any nested scopes they appear in; i.e., any macro definition will 
simply remain in effect until the end of the source code.&nbsp; In 
XPL/I, macro definitions remain in effect only until the end of the 
procedure in which they're defined, including embedded procedures.&nbsp;
 In neither case does a macro definition have any effect on source code 
prior to it.<br>
  </font></blockquote>
<h3>Logical Expressions</h3>
<p>XPL's logical operators are <font color="#663300"><code>&amp;</code></font>, |, and <font color="#663300"><code>~</code></font> (<font color="#663300"><code>¬</code></font>, <font color="#663300"><code>^</code></font>), for "and", "or", and "not", respectively.  The documentation in <i>A Compiler Generator</i>
 is maddeningly unclear as to what these operators do.  True, table 
6.8.1 calls them "logical and", "logical or", and "logical complement", 
but the word "logical" isn't defined ... just as my sloppy usage of the 
word "logical" at the beginning of this paragraph makes no distinction. 
Which leaves open a few loopholes that have to be closed up. The issues 
which we must understand are:<br></p>
<ul>
  <li>Are these operations bitwise or narrowly "logical".  I.e., do they
 operate in parallel on each bit position in a numerical value, or do 
they simply produce bipolar results of 1 (true) or 0 (false)?</li>
  <li>Do these operations short circuit?  E.g., if we have an expression of the form (say) <font color="#663300"><code><i>expression1</i>&amp;<i>expression2</i></code></font>, and <i><font color="#663300"><code>expression1</code></font></i> evaluates to 0, is <i><font color="#663300"><code>expression2</code></font></i> even evaluated?</li>
</ul>
<p>In case you're not in the mood for a technical discussion of the 
matter, I'll give you the short answer up front, and having read that, 
you can proceed to the long discussion if you want:<br></p>
<ul>
  <li>The logical operations are indeed bitwise.</li>
  <li>Under some limited circumstances, the original <b>XCOM</b> may 
have short-circuited evaluation of logical operations, even though 
there's no short-circuiting observed in the examples I've constructed.  <b>XCOM-I</b> does not at present attempt any short-circuiting.<br></li>
</ul>
<p>As for how I came up with this "information", there are several 
places we can look for guidance in guessing the answers.  For one thing,
 according to McKeeman's account, the XPL language was derived from the 
PL/I language, so we can look at PL/I documentation and hope that it 
applies to XPL.  Of course, we can look at the source code for 
McKeeman's XPL compiler (<b>XCOM</b>) as listed in the book, and see if there are any hints there.  Or we can even examine the IBM 360 object code that <b>XCOM</b>
 generates for these operators.   (All the while wondering how things 
came to this, that we have to resort to lame measures like consulting 
object code to figure out the basic features of the language?)<br></p>
<p>As far as PL/I is concerned, <a moz-do-not-send="true" href="https://www.ibm.com/docs/en/SSY2V3_5.1.0/com.ibm.ent.pl1.zos.doc/lrm.pdf">IBM's PL/I Language Reference</a> (2017) tells us on p. 66 that for the <font color="#663300"><code>&amp;</code></font>, <font color="#663300"><code>|</code></font>, and <font color="#663300"><code>¬</code></font> operators, "bit operations are performed on a bit-by-bit basis".  As far as object code produced by <b>XCOM</b> is concerned, McKeeman (p. 150) shows an example in which object code for the expression "<font color="#663300"><code>SHL(K,1) &amp; SHR(I,J)</code></font>" is produced, and we do find that it simply uses the IBM 360 <font color="#663300"><code>NR</code></font> ("And Logical") instruction:<br></p>
<blockquote>
  <p align="left"><img moz-do-not-send="true" src="shortCircuit.jpg" alt="" width="768" height="123"></p>
</blockquote>
<p>Although I had to consult more than one IBM assembly-language manual 
to find the answer to the seemingly-simple question of what <font color="#663300"><code>NR</code></font> does, <a moz-do-not-send="true" href="https://www.ibm.com/support/pages/sites/default/files/inline-files/SA22-7832-00.pdf">IBM's z/Architecture Principles of Operation</a> (p. A-8) does tell us that the <font color="#663300"><code>NR</code></font> (and its cousins <font color="#663300"><code>N</code></font>, <font color="#663300"><code>NC</code></font>, and <font color="#663300"><code>NI</code></font>) are indeed bitwise operations.<br></p>
<blockquote><font size="-1"><b>Aside:</b>  <a moz-do-not-send="true" href="https://www.ibm.com/support/pages/sites/default/files/inline-files/SA22-7832-00.pdf#page=940">Figure B-2, "Instructions Arranged by Mnemonic"</a> of the latter document is very helpful in trying to decipher such listings of IBM 360 object code.<br>
  </font></blockquote>
<p>Short-circuiting is a natural consideration for strictly bipolar 
operands and operators, but is a bit trickier to consider once we've 
concluded that the logical operators operate bitwise rather than in a 
bipolar fashion.  Certainly the object-code example from <i>A Compiler Generator</i> that was mentioned in the preceding paragraph shows no signs at all of short circuiting:  Both of the operands of the <font color="#663300"><code>&amp;</code></font>
 operator in that example are evaluated, with no attempt at checking the
 value of the first operation before proceeding to the second one.  On 
the other hand, that example of object-code generation by <b>XCOM</b> happens to be for an assignment statement rather than for the conditional expression of an <font color="#663300"><code>IF</code></font>, <font color="#663300"><code>DO WHILE</code></font>, or <font color="#663300"><code>DO UNTIL</code></font>.
   Perhaps the evaluation of a conditional expression might be very 
different in those contexts.  One reason to believe that it might be 
different is that the final result of a conditional expression is masked
 to just the least-significant bit, and thus (eventually) is indeed a 
bipolar value; i.e., even if all of the bits were involved in the 
computation, all but one of them is discarded in the end, so perhaps the
 extra bits are discarded at the beginning rather than at the end of the
 computation, even though it's more work to do so.  Moreover, the PL/I 
Language Reference document mentioned earlier does cover short-circuit 
evaluation (see p. 245), and it says that short-circuiting is <i>only</i> in the context of the conditional of an <font color="#663300"><code>IF</code></font>
 statement (versus assignment statements).  Plus, even then the 
short-circuiting occurs only in certain special circumstances, such as 
the leading operand being a <font color="#663300"><code>BIT(1)</code></font>
 literal or constant variable, which leads one to believe that the value
 of the leading operand has to be determined to be 0 or 1 at 
compile-time rather than at run-time for the short-circuiting to occur.<br></p>
<p>Unfortunately, the example of object-code generation in McKeeman doesn't show us how an <font color="#663300"><code>IF</code></font> statement would compile.  But <a moz-do-not-send="true" href="#compilingXCOM">as we saw earlier</a>, we have been able to use <b>XCOM-I</b> to create a working copy of McKeeman's <b>XCOM</b>, so we can make our own example of <font color="#663300"><code>IF</code></font>, compile it with <b>XCOM</b> and see!  Imagine we have the following ridiculous little XPL program:<br></p>
<blockquote>
  <pre><font color="#663300"> DECLARE I FIXED;<br> DO I = 1 TO 10;<br>     IF (I * I) &amp; (100 - I * I) THEN OUTPUT = 'hello';<br> END;<br> DO I = 1 TO 10;<br>     IF 0 &amp; (100 - I * I) THEN OUTPUT = 'hello';<br> END;<br>EOF<br></font></pre>
</blockquote>
<blockquote>
  <p><font size="-1"><b>Aside:</b> By the way, compiling an XPL program with McKeeman's <b>XCOM</b> is a bit more constrained than compiling a similar program with <b>XCOM-I</b>.  For one thing, to avoid an irritating if harmless warning message, the <font color="#663300"><code>EOF</code></font> token must be present at the end of the source code, whereas <b>XCOM-I</b>
 doesn't care.  For another, even though XPL is case-insensitive other 
than inside of quoted strings, and even though all of the XPL source 
code in <i>A Compiler Generator</i> is printed in lower case, <b>XCOM</b> will in fact choke on any XPL source code that isn't fully upper case.  Go figure!</font><br></p>
</blockquote>
Compiling this silly program with <b>XCOM</b>, and pulling just the relevant portion of the <b>XCOM</b>'s report gives us the following IBM 360 object code for the conditional expressions of the <font color="#663300"><code>IF</code></font> statements:<br>
<pre><font color="#663300">  20 |    IF (I * I) &amp; (100 - I * I) THEN OUTPUT = 'hello';                           |  1314 C7 = 10.<br>                                                                      1314: CODE = L    1,1340(0,11)<br>                                                                      1318: CODE = M    0,1340(0,11)<br>                                                                      1322: CODE = L    2,1340(0,11)<br>                                                                      1326: CODE = L    3,1340(0,11)<br>                                                                      1330: CODE = MR   2,2<br>                                                                      1332: CODE = LA   2,100(0,0)<br>                                                                      1336: CODE = SR   2,3<br>                                                                      1338: CODE = NR   1,2<br>                                                                      1340: CODE = N    1,164(0,11)<br>                                                                      ...<br> 24 |    IF 0 &amp; (100 - I * I) THEN OUTPUT = 'hello';                                 |  1400<br>                                                                      1400: CODE = L    1,1340(0,11)<br>                                                                      1404: CODE = M    0,1340(0,11)<br>                                                                      1408: CODE = LA   2,100(0,0)<br>                                                                      1412: CODE = SR   2,1<br>                                                                      1414: CODE = N    2,1300(0,1048571)<br>                                                                      1418: CODE = N    2,164(0,11)<br>                                                                      ...<br><br></font></pre>
<p>Not shown above is that the symbol table tells us variable <font color="#663300"><code>I</code></font>
 is stored at address 1340(11), which is why all of the 1340(0,11)'s 
appear above.  I don't understand IBM 360 assembly language, but what I <i>think</i> the code probably does is:<br></p>
<ul>
  <li>The first <font color="#663300"><code>IF</code></font>:</li>
  <ul>
    <li>1314 through 1318:  Compute the left-hand operand of the <font color="#663300"><code>&amp;</code></font> operator; i.e., <font color="#663300"><code>I*I</code></font>.</li>
    <li>1322 through 1336:  Compute the right-hand operand of the <font color="#663300"><code>&amp;</code></font> operator; i.e., <font color="#663300"><code>100-I**</code></font>. </li>
    <li>1338: Perform a bitwise-AND of the two operands.</li>
    <li>1340: Mask off all but the least-significant bit.<br></li>
  </ul>
  <li>The second <font color="#663300"><code>IF</code></font>:</li>
  <ul>
<li>1400-1412:  Compute the <i>right</i>-hand operand of the <font color="#663300"><code>&amp;</code></font> operator; i.e., <font color="#663300"><code>I*I</code></font>.</li><li>1414: Perform a bitwise-AND with 0.  Admittedly, I'm not quite sure <i>why</i> it would be 0 it's AND'ing with, but it's certainly AND'ing with something.</li><li>1418: Mask off all but the least-significant bit.</li>
  </ul>
</ul>
<p>But whether or not my interpretation is 100% correct, at least in 
this example there's no evidence of short-circuiting.  The 2nd <font color="#663300"><code>IF</code></font>
 in particular is pretty shocking.  Perhaps there's supposed to be some 
subsequent optimization I'm not aware of that would have cleaned it up.<br></p>

<h3><a name="common"></a>COMMON Memory</h3>
XPL/I also introduces the notion of <font color="#663300"><code>COMMON</code></font> memory, not present in XPL.&nbsp; The notion behind <font color="#663300"><code>COMMON</code></font>
 memory is that a very large application program like <b>HAL/S-FC</b> won't be 
loaded entirely in memory at once, but will instead be run as a sequence
 of "passes".&nbsp; <br>
<br>
Thus, <b>HAL/S-FC</b> isn't a single application program, but rather a set of 
them:&nbsp; PASS1, FLO, OPT, AUX, PASS2, PASS3, and PASS4.&nbsp; Each of
 these applications is loaded, run, and unloaded from memory, in succession.<br>
<br>
But!&nbsp; Each of these application programs may receive some kind of 
input data or state data from the preceding application program, and 
transmit output data or state data to the next application program in 
succession.&nbsp; In XPL/I's visualization, <i>some</i> of that data is 
passed in files.&nbsp; But other of that data is instead just assumed to
 remain in computer memory, unchanged from whatever the preceding 
application has left behind.&nbsp; The term XPL/I applies to this 
leftover memory is <font color="#663300"><code>COMMON</code></font>.&nbsp; It's formalized when you explicitly declare variables as being in <font color="#663300"><code>COMMON</code></font>.&nbsp; Variables declared to be in <font color="#663300"><code>COMMON</code></font>
 are not initialized by an XPL/I program, but are simply assumed to 
already contain the data needed.&nbsp; On the other hand, variables <i>not</i> declared <font color="#663300"><code>COMMON</code></font>
 are up for grabs, and no assumption can be made about their initial 
contents other than whatever initialization their declarations 
explicitly provide.<br>
<br>
Syntactically, <font color="#663300"><code>COMMON</code></font> data is declared in XPL/I by three methods:<br>
<ul>
  <li>Using the keyword <font color="#663300"><code>COMMON</code></font> in place of the keyword <font color="#663300"><code>DECLARE</code></font>.</li>
  <li>Using the keyword-pair <font color="#663300"><code>COMMON ARRAY</code></font> in place of the keyword <font color="#663300"><code>ARRAY</code></font>.</li>
  <li>Using the keyword-pair <font color="#663300"><code>COMMON BASED</code></font> in place of the keyword <font color="#663300"><code>BASED</code></font>.</li>
</ul>
<p>Another distinction is that <font color="#663300"><code>CHARACTER</code></font> variables cannot declared in <font color="#663300"><code>COMMON</code></font>, though <font color="#663300"><code>CHARACTER</code></font> variables can appear as fields in <font color="#663300"><code>COMMON BASED RECORD</code></font> variables.  <b>XCOM-I</b> actually relaxes this restriction.<br></p>
<p>It's not documented anywhere, as far as I know, but I would <i>assume</i> that there was originally an expectation that each cooperating application running in succession needed to declare <font color="#663300"><code>COMMON</code></font> in exactly the same way, using exactly the same ordering of variables and the same datatypes.  <b>XCOM-I</b> relaxes this restriction as well.  <br></p>
<p>Of course, <b>XCOM-I</b> makes no effort at all to pass <font color="#663300"><code>COMMON</code></font> data from one application to another using actual memory.  Rather, each XPL/I application program compiled by <b>XCOM-I</b> optionally (depending on its command-line options) can load a file of data into its <font color="#663300"><code>COMMON</code></font> area, and automatically writes out its <font color="#663300"><code>COMMON</code></font> area into a file upon termination.  By using the <font color="#663300"><code>--commoni</code></font> and <font color="#663300"><code>--commono</code></font> command-line switches of the application, a close degree of control can be exercised over which previously-saved <font color="#663300"><code>COMMON</code></font> blocks, if any, are passed to which application programs.<br></p>
<blockquote>
</blockquote>
<h3><a name="MemoryModel"></a>Memory Model for a Compiled XPL Program<br>
</h3>
<table width="100%" cellspacing="10" cellpadding="0">
  <tbody>
    <tr>
      <td valign="top">
<p>The theoretical memory space available at runtime for a compiled XPL program is 2<sup>24</sup>=16,777,216
 bytes in size, although the Wikipedia article on IBM System/360 tells 
us that the actual physical maximum was only 8 MB.&nbsp; In the C object
 code generated by XCOM-I, this is represented by the byte array called <font color="#663300"><code>memory</code></font>.<br>
For the original XPL and XPL/I compilers, the lowest portion and highest
 portion of this (theoretical) 16 MB space was dedicated to the 
executable code for the program and the data used by it.&nbsp; The 
middle of the area was used for the program's data.&nbsp; But in the <b>XCOM-I</b>
 framework, all of the program code is stored elsewhere, thus the entire
 16MB space can be dedicated just for the variables actually <font color="#663300"><code>DECLARE</code></font>'d
 in the XPL source code ... plus those few elements of data which the 
operating system needs to communicate to the program, such as run-time 
program options.<br></p>
<p>The memory nevertheless still needs to be partitioned into blocks 
dedicated to specific types of data, in order to facilitate management 
of dynamic data like <font color="#663300"><code>CHARACTER</code></font> or <font color="#663300"><code>BIT</code></font><font color="#663300"><code>(n&gt;32)</code></font> strings and <font color="#663300"><code>BASED</code></font>
 variables.&nbsp; I try to follow the same partitioning scheme as used 
by the original compilers, at least roughly.&nbsp; The broad outline of 
this partitioning scheme is seen in the diagram to the right.<b>&nbsp; <br></b></p>
<p>Regions 4 and 6 naturally did not exist in XPL, since <font color="#663300"><code>BASED</code></font> variables are an XPL/I extension to standard XPL.&nbsp; So when <b>XCOM-I</b> is run with the <font color="#663300"><code>--xpl</code></font> command-line switch, those regions both have fixed sizes of 0.<br></p>
<p>Mostly, the boundaries of these memory regions are established at compile-time, by which I mean they're established by <b>XCOM-I</b>
 and don't change thereafter.  The exception is the boundary area 
between memory regions 5 and 6.  As you may recall, at program startup, <font color="#663300"><code>BASED</code></font> variables have already been <font color="#663300"><code>DECLARE</code></font>'d and <b>XCOM-I</b>
 has thus made space for their dope vectors (region 4), but considered 
as arrays their sizes are 0.  At program start, region 6 is empty.  But 
memory region 6 grows <i>downward</i> when <font color="#663300"><code>BASED</code></font>
 variables are allocated memory at runtime, simultaneously shrinking the
 free-string memory region 5.  String data meanwhile occupies the space 
from <font color="#663300"><code>FREEBASE</code></font> to <font color="#663300"><code>FREEPOINT</code></font> in region 5, which means that the space between <font color="#663300"><code>FREEPOINT</code></font> and <font color="#663300"><code>FREELIMIT</code></font> is available both for growing the string data upward (thus increasing <font color="#663300"><code>FREEPOINT</code></font>) or growing the <font color="#663300"><code>BASED</code></font> data downward (thus decreasing <font color="#663300"><code>FREELIMIT</code></font>).<br></p>
<blockquote><b><font size="-1">Aside:</font></b><font size="-1">&nbsp; It would seem reasonable, at least to me, that if </font><font size="-1"><font color="#663300"><code>BASED</code></font> allocations proceed downward in memory, then the indices of the </font><font size="-1"><font color="#663300"><code>BASED</code></font> should also proceed downward as well.&nbsp; I mean that if we had a decoration such as <font color="#663300"><code>BASED MYBASED</code></font>, then <font color="#663300"><code>MYBASED(0)</code></font> would be at a higher address than </font><font size="-1"><font size="-1"><font color="#663300"><code>MYBASED(1)</code></font></font>, which would be at a higher address than </font><font size="-1"><font size="-1"><font size="-1"><font color="#663300"><code>MYBASED(2)</code></font></font></font>, and so on.&nbsp; If that were the case, then growing </font><font size="-1"><font size="-1"><font size="-1"><font color="#663300"><code>MYBASED</code></font></font></font>
 after its initial allocation would be more efficient (if it happened to
 border on unallocated space), since it just involves snatching an 
unallocate chunk of memory rather than moving the entire array.&nbsp; 
However, if I am reading the code in SPACELIB correctly this does not 
appear to be the case:&nbsp; Indices of </font><font size="-1"><font size="-1"><font color="#663300"><code>BASED</code></font></font> variables seem to increase upward in memory, just as they do in any other XPL/I array.&nbsp; </font><br>
</blockquote>

</td>
      <td valign="middle">
        <table width="100%" cellspacing="2" cellpadding="2" border="1">

  <tbody>
    <tr>
  <th valign="bottom"><font size="-1">Addresses<br>
    </font></th>
  <th valign="bottom"><font size="-1">Description<br>
    </font></th>
  <th valign="bottom"><font size="-1">Region Number<br>
    </font></th>
</tr>

<tr>
            <td valign="top" align="right"><font color="#663300"><code><font size="-1">0xFFFFFF</font></code></font><br>
<br>
<br>
<br>
<br>
<br>
<br>
              <font color="#663300"><code></code></font></td>
            <td valign="middle" align="center"><font size="-1"><br>
                <br>
Data pointed to by "dope vectors" of </font><font size="-1"><font size="-1"><font color="#663300"><code>BASED</code></font></font><br>
                <br>
                <br>
              </font></td><td valign="middle" align="center">6<br>
</td>

          </tr>
<tr>
  <td valign="bottom" align="right"><font color="#663300"><code><font size="-1">FREELIMIT</font></code></font></td>
  <td valign="middle" align="center"><font size="-1"><br>
512 unallocated bytes<br>
      <br>
    </font></td>
  <td valign="middle" align="center"><font size="-1">-</font><br>
  </td>
</tr>
<tr>
      <td valign="top" align="right"><font color="#663300"><code><font size="-1"><br>
                  <br>
                  <br>
                  <br>
FREEPOINT<br>
                  <br>
<br>
FREEBASE</font><br>
              </code></font></td>
<td valign="middle" align="center"><br>
          <font size="-1"><font size="-1">Data pointed to by "string descriptors" of <font color="#663300"><code>CHARACTER</code></font> or <font color="#663300"><code>BIT(&gt;32)</code></font><br>
              <br>
            </font></font>
      </td><td valign="middle" align="center">5<br>
</td>

    </tr>
    
    
    <tr>
  <td valign="middle" align="center"><font size="-1"><br>
    </font></td>
  <td valign="middle" align="center"><font size="-1"><font size="-1"><font color="#663300"><code><br>
BASED</code></font></font> dope vectors<br>
      <br>
    </font></td><td valign="middle" align="center">4<br>
</td>

</tr>
<tr>
  <td valign="bottom" align="right"><font size="-1"><font color="#663300"><code>DESCRIPTOR</code></font><br>
    </font></td>
  <td valign="middle" align="center"><font size="-1"><font size="-1"><font color="#663300"><code><br>
CHARACTER</code></font> or <font color="#663300"><code>BIT(&gt;32)</code><font color="#000000"> string descriptors<br>
        <br>
      </font></font></font></font></td><td valign="middle" align="center">3<br>
</td>

</tr>
<tr>
      <td valign="bottom" align="right"><br>
</td>
<td valign="middle" align="center"><font size="-1"><br>
            </font><font size="-1"><font color="#663300"><font color="#000000"><font color="#663300"><code>FIXED</code></font> and <font color="#663300"><code>BIT(</code><code>≤32)</code></font> variables</font></font></font><font size="-1"><font color="#663300"><font color="#000000"> for non-<font color="#663300"><code>COMMON</code></font></font></font></font><font size="-1"><br>
            <br>
          </font>
      </td><td valign="middle" align="center">2<br>
</td>

    </tr>
    <tr>
            <td valign="top"><br>
            </td>
            <td valign="middle" align="center"><font color="#663300"><code><br>
</code></font><font color="#663300"><font size="-1" color="#000000"><font size="-1"><font color="#663300"><font color="#000000"><font color="#663300"><code>FIXED</code></font> and <font color="#663300"><code>BIT(</code><code>≤32)</code></font> variables for </font><code>COMMON</code></font></font><font color="#663300"><code></code></font></font><code><br>
                  <br>
                </code></font></td><td valign="middle" align="center">1<br>
</td>

          </tr>
<tr>
      <td valign="bottom" align="right"><font color="#663300"><code><font size="-1">0x000000</font></code></font></td>
<td valign="middle" align="center"><br>
<font size="-1"><font color="#663300"><code><font color="#663300"><font size="-1" color="#000000">Data supplied by <font color="#663300"><code>MONITOR(13)</code></font> and <font color="#663300"><code>MONITOR(23)<br>
        <br>
</code></font></font></font>
    
    </code></font>
            
          </font>
      </td><td valign="middle" align="center">0<br>
</td>

    </tr>
    
    
    
    
    
  </tbody>
        </table>
        </td></tr></tbody></table>
<h3><a name="compactify"></a>Understanding COMPACTIFY</h3>
<p>At runtime, changes to sizes of <font color="#663300"><code>BASED</code></font>
 arrays may cause those arrays to move around within memory region 6 
(see the preceding section).  Depending on the type of changes, this can
 cause "holes" of unused memory to develop in memory region 6.  
Similarly, operations on <font color="#663300"><code>CHARACTER</code></font> variables such as <font color="#663300"><code>INPUT</code></font> or string concatenation (<font color="#663300"><code>||</code></font>) can cause holes of unused memory to develop in memory region 5.  As long as <font color="#663300"><code>FREEPOINT</code></font> is comfortably less than <font color="#663300"><code>FREELIMIT</code></font>,
 these holes don't cause any problem and can just be ignored.  However, 
it may eventually become necessary to repack these memory regions to 
consolidate the free space and eliminate the holes.  <br></p>
<p>As far as memory region 6 is concerned, that's handled transparently by the tools already discussed in <a moz-do-not-send="true" href="#basedManagement">the section on <font color="#663300"><code>BASED</code></font> variables</a> earlier, and won't be discussed here.  The <font color="#663333"><code>COMPACTIFY</code></font>
 procedure which handles this for memory region 5, unfortunately, does 
require some clarification, even though you typically don't need to 
explicitly call <font color="#663300"><code></code></font><font color="#663333"><code>COMPACTIFY</code></font> yourself, and can assume it will just be called automatically whenever needed.<br></p>
<p>Most importantly, while <font color="#663333"><code>COMPACTIFY</code></font> doesn't handle memory management of <font color="#663300"><code>BASED</code></font> variables, the existence of based variables <i>does</i> affect how <font color="#663333"><code>COMPACTIFY</code></font> operates, with the result that different versions of <font color="#663333"><code>COMPACTIFY</code></font> must be used for XPL code than for XPL/I code.  But there's a quirk in XPL's implementation:  While <font color="#663333"><code>COMPACTIFY</code></font> is considered a "built-in" function of the XPL runtime library, in point of fact it's <i>not</i> present in the XPL (or XPL/I) runtime library, and must instead be explicitly provided in the form of XPL source code.<br></p>
<p>Fortunately, that doesn't entail any effort on your part, since <b>XCOM-I</b>
 can usually figure out what to do on its own.  But still, it may be 
helpful to understand what's going one behind the scenes, for those 
cases in which you need to intervene.  The <b>XCOM-I</b> approach to the inclusion of <font color="#663333"><code>COMPACTIFY</code></font>
 is that prior to loading any of the XPL or XPL/I source-code files you 
explicitly specify, it automatically preloads a "library file", which is
 an XPL or XPL/I source-code file containing <i>at least</i> the source code for <font color="#663333"><code>COMPACTIFY</code></font>.  The library file it chooses is governed by the following rules:<br></p>
<ol>
  <li>By default, it chooses SPACELIB.xpl, which is a duplicate of the 
Intermetrics file of the same name provided with the XPL/I source code 
for the <b>HAL/S-FC</b> program.  It should be good for compiling all XPL/I source code.</li>
  <li>But if the <b>XCOM-I</b> command-line switch <font color="#663300"><code>--xpl</code></font>
 is used, the default library changes to XPL.LIBRARY.xpl.  This a 
duplicate of the library of the same name provided with the source code 
of McKeeman's <b>XCOM</b> program.  It should be good for compiling all standard XPL source code.</li>
  <li>But if the <b>XCOM-I</b> command-line switch <font color="#663300"><code>--lib-file=<i>FILENAME</i></code></font> is used, then <font color="#663300"><code><i>FILENAME</i></code></font> is used in place of the default library file.  This gives you the option of using some other version of <font color="#663333"><code>COMPACTIFY</code></font>, perhaps experimenting with it yourself.  If used along with an <font color="#663300"><code>--xpl</code></font> switch, then <font color="#663300"><code>--lib-file</code></font> must <i>follow</i> <font color="#663300"><code>--xpl</code></font> on the command line.<br></li>
</ol>
That's all you really <i>need</i> to know, and perhaps more.&nbsp; Unfortunately, <i>I</i> need to know more about it, in order to make it work in <b>XCOM-I</b>, and here's as good a place as any to write down some of that need-to-know info!<br>
<br>
The principal difficulty is that while XPL.LIBRARY.xpl works immediately
 for XPL program, as-is, as long as the memory partitioning described in
 the preceding section is compatible <i>enough</i> with McKeeman, the same cannot be said of SPACELIB.xpl for XPL/I programs.<br>
<br>
In brief, here's how the XPL <font color="#663333"><code>COMPACTIFY</code></font>
 of XPL.LIBRARY.xpl works.&nbsp; All of the "string descriptors" 
(providing the addresses and sizes of the character strings in region 5 
which need to be repacked) are found, contiguously, in memory region 3, 
which they completely fill.&nbsp; Because of this convenient 
arrangement, all of the string descriptors can all be accessed as if 
they were a single <font color="#663300"><code>FIXED</code></font> array.&nbsp; Standard XPL's built-in <font color="#663300"><code>DESCRIPTOR</code></font> and <font color="#663300"><code>NDESCRIPT</code></font>
 respectively give the location and size of this array of string 
descriptors.&nbsp; Repacking region 5 is a relatively-simple matter of 
sorting <font color="#663300"><code>DESCRIPTOR</code></font> array by 
address, using the sorted array to find the "holes", then moving the 
string data downward in region 5 to eliminate the holes, and finally 
updating the original descriptors in the <font color="#663300"><code>DESCRIPTOR</code></font> array to preserve the strings but to change the addresses.<br>
<br>
The only mild complication in the description above is that the <font color="#663300"><code>DESCRIPTOR</code></font> array can't be sorted <i>in place</i>.&nbsp; Rather, a separate scratch array is needed to help out the process:<br>
<blockquote>
  <pre><font color="#663300">DECLARE DX_SIZE LITERALLY '500', DX(DX_SIZE) BIT(16);</font><br></pre>
</blockquote>
This <font color="#663300"><code>DX</code></font> array is set up to contain the indices into the <font color="#663300"><code>DESCRIPTOR</code></font> array, and it's <font color="#663300"><code>DX</code></font> that's sorted rather than <font color="#663300"><code>DESCRIPTOR</code></font>.&nbsp; This is undoubtedly a good strategy, although it limits the total number of <font color="#663300"><code>DECLARE</code></font>'d <font color="#663300"><code>CHARACTER</code></font>
 variables to 500.&nbsp; On the other hand, the limit of 500 is 
completely arbitrary, and if you have enough memory (we do!) there's no 
reason it couldn't be increased as high as 64K.&nbsp; And by the simple 
expedient of declaring <font color="#663300"><code>DX</code></font> as <font color="#663300"><code>FIXED</code></font> rather than <font color="#663300"><code>BIT(16)</code></font>, the limit could be made much higher.<br>
<br>
Unfortunately, the relatively-simple processing fails for XPL/I code — or at least, for any XPL/I code having <font color="#663300"><code>BASED</code></font> variables containing <font color="#663300"><code>CHARACTER</code></font> data or <font color="#663300"><code>BIT(≥32)</code></font>
 data — because no longer are all of the string descriptors nicely lined
 up for us in memory region 3.&nbsp; Rather, many of them are smeared 
all over memory region 6.&nbsp; Nor is a limit of 500 strings remotely 
adequate for compiling programs like <b>HAL/S-FC</b>.&nbsp; Here is what I understand of the differences between how the XPL/I <font color="#663333"><code>COMPACTIFY</code></font> has to operate, as compared to the description I just gave of the XPL <font color="#663333"><code>COMPACTIFY</code></font>:<br>
<ul>
  <li>While the built-ins called <font color="#663300"><code>DESCRIPTOR</code></font> and <font color="#663300"><code>NDESCRIPT</code></font> still exist, and still provide exactly the same info about memory region 3, they are no longer relevant to <font color="#663333"><code>COMPACTIFY</code></font>.</li>
  <li><font color="#663300"><code>DX</code></font> is now a <font color="#663300"><code>BASED FIXED</code></font>,
 because it contains pointers to the string descriptors (i.e. it 
contains memory addresses of the string descriptors) rather than just 
indices into region 3.</li>
  <li><font color="#663300"><code>DX_SIZE</code></font> gives the number of elements of <font color="#663300"><code>DX</code></font>, but as it's nowhere <font color="#663300"><code>DECLARE</code></font>'d in the library, I suppose it must be an undocumented XPL/I built-in.</li>
</ul>
<blockquote>
  <p><b><font size="-1">Aside:</font></b><font size="-1">  I'd venture the guess that </font><font size="-1"><font color="#663300"><code>DX_SIZE</code></font> is initially set and space for </font><font size="-1"><font color="#663300"><code>DX</code></font> is initially allocate by the XPL/I compiler to handle the string descriptors which are </font><font size="-1"><font color="#663300"><code>DECLARE</code></font>'d and therefore known at compile time.  At runtime, SPACELIB would then take over the task of maintaining </font><font size="-1"><font color="#663300"><code>DX</code></font> and </font><font size="-1"><font color="#663300"><code>DX_SIZE</code></font> to handle additional string descriptors that come into existence (or leave it) when </font><font size="-1"><font color="#663300"><code>BASED</code></font> variables containing them grow (or shrink).</font><br></p>
</blockquote>
<ul>
  <li><br></li>
</ul>
<br>
TBD<br>
<h3>Structure of an XPL Program vs XPL/I<br>
</h3>

<p>An XPL program consists of any sequence of XPL <i>statements</i>, followed by the token <font color="#663333"><code>EOF</code></font>.&nbsp; In particular:<br></p>
<ul>
  <li>Declarations of variables can be intermixed with active statements such as assignments.</li>
  <li>Active code can exist at the global level, outside of any <font color="#663300"><code>PROCEDURE</code></font>s. <br></li>
</ul>

<blockquote>
  <p><font size="-1"><b>Note:</b>&nbsp; The original XPL compiler, which
 was called XCOM, performed a single pass.&nbsp; It required that the 
declaration of any particular identifier as an object (such as a 
variable) had to precede the use of that identifier, although there were
 provisions for making a forward declaration for a </font><font size="-1"><font color="#663333"><code>PROCEDURE</code></font>, so that the </font><font size="-1"><font color="#663333"><code>PROCEDURE</code></font> could be used before it was defined.&nbsp; <b>XCOM-I</b> relaxes this requirement.<br></font></p></blockquote><font size="-1"></font>
<p>Each of the sample programs I've encountered in standard XPL so far has been contained in a single <i>relatively</i>-small file.  For example, <b>ANALYZER</b> has a little over 1500 lines of source code, while <b>XCOM</b> has a little over 4200 lines.   <br></p>
<p>In contrast, the XPL/I source code for Intermetrics's HAL/S compiler <b>HAL/S-FC</b>
 has over 120,000 lines of source code spread across over 600 files, 
though any individual pass of the compiler has no more than around 
35,000 lines.  This huge size, along with the huge difference from 
programs in standard XPL, necessitates different methods for managing 
that source-code base, and some of those methods are reflected by 
compiler directives embedded within the source code.  Insofar as <b>HAL/S-FC</b>
 and its related applications are concerned, the top-level source-code 
file  (##DRIVER.xpl) for each application always contains all of the 
necessary directives for compiling the other source-code files needed, 
in the correct order, so in using XCOM-I to compile these applications 
you don't need to worry about any file other than ##DRIVER.xpl itself.<br></p>
<blockquote>
  <p><font size="-1"><b>Aside:</b> Well, the comment about ##DRIVER.xpl 
isn't exactly right.  Any XPL or XPL/I program will expect that there's a
 separate "library file" containing source code for the <font color="#663300"><code>COMPACTIFY</code></font>
 procedure, but the XPL/I source code for the program won't explicitly 
include the library file.  That's the compiler's responsibility.<br><b></b></font></p>
<p><font size="-1"><b>Aside:</b> Due to the lack of relevant 
Intermetrics documentation, what I'm about to describe is not only 
speculative on my part, but also represents certain pragmatic 
compromises that I don't believe literally existed in Intermetrics' XPL 
compiler or development procedures.  But if it will work for us using <b>XCOM-I</b> on <b>HAL/S-FC</b> and if there are no other lurking XPL/I programs that we need to worry about, why complain?</font><br></p>

</blockquote>
Compiler directives in XPL/I are comments or comment-like constructions 
which aren't documented in McKeeman and have no other obvious 
purpose.&nbsp; The specifics are covered by the subsections below.<br>
<h4>Compiler Directive Type:&nbsp; <font color="#663300"><code>/?<i>c</i> ... XPL/I source code ... ?/</code></font></h4>
This type of compiler directive is a conditional inclusion of source 
code, similar to the C language's <font color="#663300"><code>#if <i>c</i></code></font>.&nbsp; Here, <font color="#663300"><i><code>c</code></i></font>
 is supposed to be an upper-case alphabetical letter that represents the
 particular condition that needs to be "true".&nbsp; All conditions, <font color="#663300"><code>A</code></font> through <font color="#663300"><code>Z</code></font>, are by default "false".&nbsp; You make condition <font color="#663300"><i><code>c</code></i></font> "true" by using <b>XCOM-I</b>'s <font color="#663300"><code>--cond=<i>c</i></code></font> command-line switch.<br>
<br>
Interpretations of the possible conditions are entirely at the user's 
disposal; i.e., they vary by the particular source-code being compiled 
by <b>XCOM-I</b>.&nbsp; In the particular case of the XPL/I source code for the <b>HAL/S-FC</b> program, there are 4 
possible conditions <font color="#663300"><i><code>c</code></i></font> that I'm aware of:<br>
<br>
<table align="center" cellspacing="2" cellpadding="2" border="1">
  <tbody>
    <tr>
      <th valign="bottom" align="center">XCOM-I Command-Line Switch<br>
      </th>
      <th valign="top">Interpretation<br>
      </th>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>--cond=P</code></font><br>
      </td>
      <td valign="top"><b>HAL/S-FC</b> will be specialized for compiling the Space Shuttle's Primary Flight Software (PFS).</td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>--cond=B</code></font> </td>
      <td valign="top"><b>HAL/S-FC</b> will be specialized for compiling the Space Shuttle's Backup Flight Software (BFS).<br>
        <b>Note:</b>&nbsp; Either <font color="#663300"><code>--cond=P</code></font> or <font color="#663300"><code>--cond=B</code></font> must be used, but not both at the same time.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>--cond=A</code></font></td>
      <td valign="top">Produce debugging output related to memory management of <font color="#663300"><code>BASED</code></font> variables.</td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>--cond=C</code></font></td>
      <td valign="top">Produces debugging output related to actions by the <font color="#663300"><code>COMPACTIFY</code></font> procedure.</td>
    </tr>
  </tbody>
</table>
<br>
<ul></ul>
<blockquote>
  <p><font size="-1"><b>Aside:</b> This implies that you don't just compile <b>HAL/S-FC</b> <i>once</i> to get a HAL/S compiler that works for all HAL/S programs.  Rather, you compile <b>HAL/S-FC</b> <i>twice</i>,
 once to get a version of the HAL/S compiler that works for the primary 
flight software, and once to get a version of the compiler that works 
for the backup flight software.</font></p>
</blockquote>
<h4>Compiler Directive Type:&nbsp; <font color="#663300"><code>/%INCLUDE <i>module</i> %/</code></font></h4>
This type of compiler directive inserts an entire XPL/I source-code file, <i>module</i>.xpl, at the current point.&nbsp; It is used for importing <font color="#663300"><code>COMMON</code></font>-block
 declarations or macros which are used identically by all source-code 
files.&nbsp; By default, the included module is taken from the folder 
../HALINCL/.&nbsp; As far as I know this covers every use in <b>HAL/S-FC</b> source code.&nbsp; However, if necessary, <b>XCOM-I</b> has a command-line option (<font color="#663300"><code>--include=<i>folder</i></code></font>) which can be used to change the folder containing the modules.<br>
<h4>Compiler Directive Type:&nbsp; <font color="#663300"><code>/* ...comment... <i>$%module</i> */</code></font></h4>
This is a variant of the<font color="#663300"><code> /%INCLUDE <i>module</i> ...comment... %/</code></font>
 directive, which acts the same way, and for which my comments are otherwise the same.<br>
<h4>Compiler Directive Type:&nbsp; <font color="#663300"><code>/**MERGE <i>module</i> <i>procedure</i> */</code></font></h4>
This is yet another directive for including an XPL/I source-code file in
 the current XPL/I source-code file, but it differs from the other 
include-directives described above in that instead of importing 
definitions used in common by multiple source-code files, it instead is 
typically used for importing the source code for a single <font color="#663300"><code>PROCEDURE</code></font>.&nbsp; As above, <i>module</i>.xpl is the source-code file to include, while <i>procedure</i> is the name of the <font color="#663300"><code>PROCEDURE</code></font> contained in that file.&nbsp; In point of fact, <b>XCOM-I</b> simply ignores the procedure name.<br>
<blockquote><font size="-1"><b>Aside:</b> Procedure names don't match 
the filenames, usually, because the naming conventions for System/360 
files were severely limited vs identifiers in XPL.&nbsp; Thus the 
filenames were normalized, truncated forms of the procedure names.</font><br>
</blockquote>
Also, <i>module</i>.xpl is expected to be within the same folder as the 
source-code file being compiled; no other folders are searched for it, 
and there are no command-line switches to alter this behavior.<br>
<blockquote>
</blockquote>

<h3>PROCEDUREs, RETURNs, and Their Peculiarities<br>
</h3>
<p>In a view from a height, an XPL program consists of <font color="#663333"><code>PROCEDURE</code></font> definitions and of code that uses those definitions.<br></p>
<p>A procedure definition looks something like this:<br></p>
<blockquote>
  <pre><font color="#663300"><i>label</i>:<br>PROCEDURE(... <i>parameter list</i> ...) <i>ReturnType</i>;<br>	DECLARE ... <i>for the parameters</i> ...;<br>	DECLARE ... <i>for local variables</i> ...;<br><br>	... <i>code</i> ...;<br>END <i>label</i>;</font><br></pre>
</blockquote>

<p><font color="#663333"><font color="#000000">A lot of this is optional.  Thus while the initial <font color="#663300"><code><i>label</i>:</code></font> is required (since it's the name of the procedure), the </font></font><font color="#663333"><font color="#000000"><font color="#663333"><font color="#000000"><font color="#663300"><code><i>label</i></code></font></font></font>
 at the end of the definition is optional, and is really there only for 
readability purposes.  If the procedure needs no parameters, then the <font color="#663300"><i><code>parameter list</code></i></font>, <i>including</i> its enclosing parentheses, is omitted.  If the procedure returns no value, then <font color="#663300"><i><code>ReturnType</code></i></font> is omitted; if present, it is one of the basic non-subscripted datatypes <font color="#663300"><code>FIXED</code></font>, <font color="#663300"><code>BIT(<i>n</i>)</code></font>, or <font color="#663300"><code>CHARACTER</code></font>.  Each parameter in the </font></font><font color="#663333"><font color="#000000"><font color="#663333"><font color="#000000"><font color="#663300"><i><code>parameter list</code></i></font></font></font>
 must have a declaration within the body of the procedure, and while 
those declarations don't technically have to precede the declarations of
 the local variables as shown above, it was apparently customary to do 
so.</font></font></p><font color="#663333"><code>PROCEDURE</code></font> definitions in the source code can be nested, to any desired depth.  <font color="#663333"><code>PROCEDURE</code></font> definitions and <font color="#663300"><code>DO...END</code></font>
 blocks provide the program with a hierarchical structure of 
"scopes".&nbsp; The hierarchical structure is provided by the 
parent/child relationships among the scopes.  Variables are accessible 
within the scope in which they're declared, along with any descendant scopes.  If a
 variable is declared in more than one scope of the hierarchy, the one 
in the innermost enclosing scope is the one that is applicable.  Note, 
though, that variables can be declared only at the global level or in a 
procedure, and not within <font color="#663300"><code>DO...END</code></font> blocks. <br>
<blockquote><font size="-1"><b>Warning:</b>&nbsp; As usual, there are traps.&nbsp; As I mentioned above, </font><font size="-1"><font color="#663333"><code>PROCEDURE</code></font> definitions can be embedded within other </font><font size="-1"><font color="#663333"><code>PROCEDURE</code></font> definitions, and are accessible within that </font><font size="-1"><font color="#663333"><code>PROCEDURE</code></font> or descendant scopes.&nbsp; Can a </font><font size="-1"><font color="#663333"><code>PROCEDURE</code></font> be defined within a </font><font size="-1"><font color="#663300"><code>DO...END</code></font> block?&nbsp; It can!&nbsp; But (trap!) it is accessible anywhere in the enclosing </font><font size="-1"><font size="-1"><font color="#663333"><code>PROCEDURE</code></font></font> or that </font><font size="-1"><font size="-1"><font color="#663333"><code>PROCEDURE</code></font></font>'s descendants, and is <i>not</i> limited to the <font color="#663300"><code>DO...END</code></font> block in which it was defined.&nbsp; (For example, the <font color="#663300"><code>COMMENT_BRACKET</code></font> procedure within <b>HAL/S-FC</b>'s <font color="#663300"><code>OUTPUTWR</code></font>.xpl.) </font><br>

</blockquote>
<p>A <font color="#663333"><code>PROCEDURE</code></font> may be invoked in two different ways.&nbsp; If it returns a value via a <font color="#663300"><code>RETURN</code></font>
 statement, it can be used in an arithmetical expression or a string 
expression.&nbsp; If it doesn't return a value, or if it does return a 
value and you simply want to ignore the value, a <font color="#663333"><code>CALL</code></font> statement can be used to invoke the <font color="#663333"><code>PROCEDURE</code></font> but to discard any returned value.<br></p>
<p><b>Important:</b>&nbsp; All variables local to a <font color="#663333"><code>PROCEDURE</code></font> definition retain their values after the <font color="#663333"><code>PROCEDURE</code></font> returns.&nbsp; If the <font color="#663333"><code>PROCEDURE</code></font> is re-executed, those local variables retain the values they previously had in the prior invocation of the <font color="#663333"><code>PROCEDURE</code></font>.&nbsp; The values of those local variables, though retained, are inaccessible to code outside of the <font color="#663333"><code>PROCEDURE</code></font>,
 because the compiler enforces scopes of variables. (In C code, this 
would be the same thing as saying that every local variable of every 
function is automatically declared as <font color="#663333"><code>static</code></font>.)
</p>
<p><b><i>Very</i> important:</b> Any <i>parameter</i>s at the end of the calling list of a <font color="#663333"><code>PROCEDURE</code></font> can be omitted from when calling the <font color="#663333"><code>PROCEDURE</code></font>, and if omitted, they retain the same values as the last time the <font color="#663333"><code>PROCEDURE</code></font> was invoked <i>or</i> the values previously assigned to those parameters from within the <font color="#663333"><code>PROCEDURE</code></font> itself!&nbsp; (In essence, this is like saying that parameters of a <font color="#663333"><code>PROCEDURE</code></font> are not passed to the <font color="#663333"><code>PROCEDURE</code></font>, but rather that they are just aliases for some set of global variables dedicated to the <font color="#663333"><code>PROCEDURE</code></font>.)&nbsp; That's so weird that we need to see an example.&nbsp; Consider the following XPL <font color="#663333"><code>PROCEDURE</code></font> definition, and <font color="#663333"><code>CALL</code></font>s to it:
</p>
<blockquote>
  <pre><font color="#663333">weirdo: <br>procedure(x, y, z);<br>    declare (x, y, z) fixed;		/* Declare x,y,z as integers */<br>    output = x || ' ' || y || ' ' || z; /* Print out x,y,z */<br>    x = 29;<br>    y = y + 1;<br>end weirdo;<br><br>call weirdo(1, 2, 3);<br>call weirdo(4, 5);<br>call weirdo(6);<br>call weirdo();<br>call weirdo;</font><br></pre>
</blockquote>
<p>The five calls successively print out the following:
</p>
<blockquote>
  <pre>1 2 3<br>4 5 3<br>6 6 3<br>29 7 3<br>29 8 3<br></pre>
</blockquote>
<p><font color="#663333"><code>PROCEDURE</code></font>s cannot be recursive, either directly or indirectly.<br></p>
<p>Taking these facts altogether, <b>XCOM-I</b> implements both parameters and local variables of <font color="#663333"><code>PROCEDURE</code></font>s essentially as global variables in they way they are stored:&nbsp; i.e., each parameter and each local variable of each <font color="#663333"><code>PROCEDURE</code></font> has its own <i>static</i>
 address (in the global memory model), assigned at compile time and 
unchanging thereafter.&nbsp; The compiler enforces the logical scoping 
of these variables.<br></p>
<p>Regarding the <font color="#663300"><code>RETURN</code></font> statement, McKeeman explains that it is used to exit from a <font color="#663333"><code>PROCEDURE</code></font>
 and optionally to return a value.  Furthermore, the calling code can 
either use that return value or else ignore it.  Which makes perfect 
sense.  But  as usual, there are some documented and undocumented 
peculiarities to the <font color="#663300"><code>RETURN</code></font> statement as well:<br></p>
<ul>
  <li>McKeeman explains (p. 146) that calling code can <i>use</i> returned values from <font color="#663300"><code>PROCEDURE</code></font>s even if the <font color="#663300"><code>PROCEDURE</code></font> has no <font color="#663300"><code>RETURN</code></font> statement, or the <font color="#663300"><code>RETURN</code></font>
 statement specifies no value.  In this case, we are told, the return 
value is simply some unpredictable value from some unspecified 
System/360 register.  Which is rotten, of course, but so what?  This is 
never going to happen, right?  Wrong!  Actual XPL code does this from 
time to time.  <b>XCOM-I</b>, on the other hand, <i>always</i> returns a value from a <font color="#663300"><code>PROCEDURE</code></font>, whether or not there are any <font color="#663300"><code>RETURN</code></font> statements specifying a return value; the returned value in this case is 0 if <font color="#663300"><code>FIXED</code></font>, a <font color="#663300"><code>BIT</code></font> value of the appropriate width evaluating to 0, or else the empty string for a <font color="#663300"><code>CHARACTER</code></font>.</li>
  <li>McKeeman does not mention that <font color="#663300"><code>RETURN</code></font>
 statements may exist at the global level, outside of the scope of any 
procedure, and may return a value when they do.  But they can.  <b>XCOM-I</b>
 treats these as exits from the program back to the operating system, 
with the returned value being the program's exit code.  It thus expects 
the return value to be a program status code.</li></ul>
<h3>Blocks and Loops</h3>
<p>Compound statements in XPL are groupings of simple statements (such 
as assignments or if-then-else statements) enclosed within a <font color="#663300"><code>DO ... END</code></font> block:<br></p>
<blockquote>
  <pre><font color="#663300">DO ...;<br>    ... simple statements ...<br>END;</font><br></pre>
</blockquote>
<p>There are five different kinds of <font color="#663300"><code>DO ... END</code></font> blocks.  First, there is a mere grouping:</p>
<blockquote>
  <pre><font color="#663300">DO;<br>    ... simple statements ...<br>END;</font></pre>
</blockquote>

<p>Then there are 3 different kinds of loops:</p>
<pre><font color="#663300">DO <i>COUNTER</i> = <i>START</i> TO <i>END</i> [BY <i>STEP</i>];<br>    ... simple statements ...<br>END;<br><br></font><font color="#663300">DO WHILE <i>CONDITION</i>;<br>    ... simple statements ...<br>END;</font>
<br><font color="#663300">DO UNTIL <i>CONDITION</i>;<br>    ... simple statements ...<br>END;</font>
</pre>

<p>Note that <font color="#663300"><code>DO UNTIL</code></font> is new in XPL/I and is not present in standard XPL.<br></p>
<p>In these loops, <i><font color="#663300"><code>COUNTER</code></font></i>, <i><font color="#663300"><code>START</code></font></i>, <i><font color="#663300"><code>END</code></font></i>, and the optional <i><font color="#663300"><code>STEP</code></font></i> are all integers.  <i><font color="#663300"><code>STEP</code></font></i> defaults to 1, but must be <i>positive</i>.  <i><font color="#663300"><code>START</code></font></i>, <i><font color="#663300"><code>END</code></font></i>, and <i><font color="#663300"><code>STEP</code></font></i>
 may be expressions, but if so they are evaluated only a single time, at
 the start of the loop, and are not reevaluated thereafter.  <i><font color="#663300"><code>CONDITION</code></font></i>,
 on the other hand, is an expression evaluated on each loop; it is 
treated as "true" if its least-significant bit is 1, or "false" if its 
least-significant bit is 0.<br></p>
<p>The fifth kind of <font color="#663300"><code>DO ... END</code></font> block is:<br></p>
<blockquote>
  <pre><font color="#663300">DO CASE EXPRESSION;<br>    STATEMENT0;<br>    STATEMENT1;<br>    STATEMENT2;<br>    ...<br>END;</font><br></pre>
</blockquote>
<p>The <i><font color="#663300"><code>EXPRESSION</code></font></i> must evaluate to an integer.  If 0, then <i><font color="#663300"><code>STATEMENT0</code></font></i> is executed; if 1, then <i><font color="#663300"><code>STATEMENT1</code></font></i>
 is executed; and so on.  At most, a single statement is executed, and 
there is no "fall through" from one statement to the next.  If the <i><font color="#663300"><code>EXPRESSION</code></font></i>
 is negative or beyond the number of available statements, McKeeman 
tells us that "a random jump is executed".  In XCOM-I, no statement is 
executed under those circumstances, and control passes to the next 
statement after the <font color="#663300"><code>END</code></font>.<br></p>
<h3><code>ESCAPE</code> and <code>REPEAT</code><br>
</h3>

<p>The <font color="#663300"><code>ESCAPE</code></font> and <font color="#663300"><code>REPEAT</code></font>
 keywords appear to be undocumented XPL/I features not present in 
standard XPL.  Unfortunately, from the available material I can't think 
of any way to be <i>sure</i> what they do, so I can only speculate.<br></p>
<p><font color="#663300"><code>ESCAPE</code></font> appears in two different forms:<br></p>
<ul>
  <li><font color="#663300"><code><font color="#663300"><code>ESCAPE;</code></font> <br></code></font></li>
  <li><font color="#663300"><code>ESCAPE <i>LABEL</i>;</code></font> <font color="#663300"><code></code></font></li>
</ul>
<p>It should be noted that the HAL/S language has the keyword <code><font color="#663300">EXIT</font></code>, which also has these two forms.  (<a moz-do-not-send="true" href="https://www.ibiblio.org/apollo/Shuttle/Programming%20in%20HAL_S%20Sept%201978.pdf#page=96">See Ryer, p. 5-12</a>.)  <code><font color="#663300">EXIT</font></code> has the following behavior in HAL/S:<br></p>
<ul>
<li><font color="#663300"><code><font color="#663300"><code>EXIT</code></font>;</code></font> — Exits from the innermost enclosing <font color="#663300"><code>DO ... END</code></font> block.  I.e., it's essentially a <font color="#663300"><code>GO TO</code></font> to just after the closest enclosing <font color="#663300"><code>END</code></font>.</li>
  <li><font color="#663300"><code>EXIT <i>LABEL</i>;</code></font> — Exits from an enclosing <font color="#663300"><code>DO ... END</code></font> that isn't necessarily the innermost one, but rather the one which instead has the specified <i><font color="#663300"><code>LABEL</code></font></i> attached to it.  By "attached to it", I mean that they're directly adjacent, as in "<font color="#663300"><code><i>LABEL</i>: DO ...</code></font>".<font color="#663300"><code></code></font></li>
</ul>
<p>Until a more-plausible explanation comes along, my assumption is that <font color="#663300"><code><font color="#663300"><code>ESCAPE</code></font></code></font> in XPL/I has the same behavior as HAL/S's <font color="#663300"><code>EXIT</code></font>.<br></p>
<p>For example, consider the following XPL/I code:<br></p>
<blockquote><font color="#663300"><code>...</code><code></code></font><br>
  <font color="#663300"><code></code><code>MYBLOCK: </code><code></code></font><br>
  <font color="#663300"><code></code><code>DO ...</code><code></code></font><br>
  <font color="#663300"><code></code><code>&nbsp;&nbsp;&nbsp; ...</code><code></code></font><br>
  <font color="#663300"><code></code><code>&nbsp;&nbsp;&nbsp; DO ...</code><code></code></font><br>
  <font color="#663300"><code></code><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        ...</code><code></code></font><br>
  <font color="#663300"><code></code><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        ESCAPE; /* Escape #1 */</code><code></code></font><br>
  <font color="#663300"><code></code><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        ...</code><code></code></font><br>
  <font color="#663300"><code></code><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ESCAPE MYBLOCK; /* Escape #2 */</code><code></code></font><br>
  <font color="#663300"><code></code><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        ...</code><code></code></font><br>
  <font color="#663300"><code></code><code>&nbsp;&nbsp;&nbsp; END;</code><code></code></font><br>
  <font color="#cc0000"><code></code><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Escape #1 comes here! */</code></font><br>
  <font color="#663300"><code></code><code>&nbsp;&nbsp;&nbsp; ...</code></font><br>
  <font color="#663300"><code>END;</code></font><br>
  <font color="#cc0000"><code></code><code>/* Escape #2 comes here! */</code></font><br>
  <font color="#663300"><code>...</code></font><br>
  <font color="#663300"><code></code></font></blockquote>
<font color="#663300"><code><font color="#663300"><code>REPEAT</code></font></code></font> also appears in those same two forms:<br>
<ul>
<li><font color="#663300"><code><font color="#663300"><code>REPEAT;</code></font> <br></code></font></li><li><font color="#663300"><code><font color="#663300"><code><font color="#663300"><code>REPEAT</code></font></code></font> <i>LABEL</i>;</code></font> </li>
</ul>
And again, there's a <font color="#663300"><code><font color="#663300"><code><font color="#663300"><code>REPEAT</code></font></code></font></code></font>
 keyword in HAL/S as well.&nbsp; In this case, though, from examining 
the actual usage in HAL/S-FC source code, I believe that while the 
keyword has a <i>similar</i> behavior in HAL/S and XPL/I, there is 
nevertheless a distinction between them.&nbsp; Here's what I believe the
 behavior is in XPL/I:<br>
<ul>
<li><font color="#663300"><code><font color="#663300"><code>REPEAT;</code></font></code><font color="#000000"> </font></font>— "Repeats" the smallest enclosing <font color="#663300"><code>DO ... END</code></font>.  In case the smallest enclosing <font color="#663300"><code>DO ... END </code></font>is a loop — <font color="#663300"><code>DO WHILE</code></font> or <font color="#663300"><code>DO UNTIL</code></font> or <font color="#663300"><code>DO I = X TO Y</code></font> — saying that it "repeats" has a pretty clear meaning: XPL/I <font color="#663300"><code><font color="#663300"><code>REPEAT</code></font></code></font> is like a Python or C <font color="#663300"><code>continue</code></font> statement.  On the other hand, if the immediately-enclosing <font color="#663300"><code>DO ... END</code></font> is <i>not</i> a loop, the expected behavior is less clear; nor are there any instances of <font color="#663300"><code>REPEAT</code></font> in non-loops in legacy XPL/I code from which we might get a clue.&nbsp; <b>XCOM-I</b> implements <font color="#663300"><code><font color="#663300"><code>REPEAT</code></font></code></font>
 without a label simply as a jump to the beginning of the block, which 
means that you could form an infinite loop if there were no other code 
(like <font color="#663300"><code>ESCAPE</code></font> or <font color="#663300"><code>GO TO</code></font>) to exit the loop.</li>
<li><font color="#663300"><code><font color="#663300"><code><font color="#663300"><code>REPEAT</code></font></code></font> <i>LABEL</i>;</code></font> — Breaks out of inner loops as needed, until reaching an enclosing <font color="#663300"><code>DO ... END</code></font> loop that has the attached <i><font color="#663300"><code>LABEL</code></font></i>. <i>That's</i> the block that it repeats.</li>
</ul><ul>
</ul>
<blockquote>
  <font size="-1"><b>Aside:</b>&nbsp; The way my XPL/I implementation is different from HAL/S is that in HAL/S, <font color="#663300"><code>REPEAT</code></font> (without a label) goes to the beginning of the innermost enclosing <i>loop</i> (<font color="#663300"><code>DO WHILE</code></font> or <font color="#663300"><code>DO UNTIL</code></font> or <font color="#663300"><code>DO I = X TO Y</code></font>) rather than the innermost enclosing <font color="#663300"><code>DO ... END</code></font>.&nbsp; Which makes sense, since that's what you'd normally want.<br>
  </font></blockquote>
<b>Note:</b>&nbsp; Neither <font color="#663300"><code>ESCAPE</code></font> nor <font color="#663300"><code><font color="#663300"><code>REPEAT</code></font></code></font> accepts a label attached to an arbitrary statement.&nbsp; It must be a label attached to a <font color="#663300"><code>DO ... END</code></font> block, and it must at some level enclose the <font color="#663300"><code>ESCAPE</code></font> or <font color="#663300"><code><font color="#663300"><code>REPEAT</code></font></code></font> statement itself.<br>
<h3>Counter Value After Normal Loop Termination<br>

</h3>

<font color="#663300"><code></code></font>For XPL code such as<br>
<blockquote>
  <pre><font color="#663300">DO I = 1 to 100;<br>    ...<br>END;</font><br></pre>
</blockquote>
it appears to be undocumented what value <font color="#663300"><code>I</code></font>
 holds after the loop ends.&nbsp; Not all computer languages handle this
 in the same way.&nbsp; My considered opinion is that the loop counter 
holds the value at which the condition for continuation fails: in this 
example, 101.&nbsp; Or, if the loop is broken prematurely (as with <font color="#663300"><code><font color="#663300"><code>ESCAPE</code></font></code></font> from the preceding section), then the value the counter held when the <font color="#663300"><code><font color="#663300"><code>ESCAPE</code></font></code></font> occurred is retained.<br>
<blockquote><font size="-1"><b>Aside:</b></font>&nbsp; In Python, for 
example, the counter for an equivalent loop would have the value 100 
rather than 101 after normal termination of the loop.<br>
</blockquote>
<h3><a name="programOptions"></a>Program Options</h3>
<p>The topic of program options is a confusing one, because there are 
many different programs under discussion, and all or most of them have 
their own sets of program options, or sometimes even their own unique 
ways of specifying those options.  There's <b>XCOM-I</b>, whose program options you can discover with the command "<font color="#663300"><code>XCOM-I.py --help</code></font>".  Then too, when you use <b>XCOM-I</b> to compile an XPL or XPL/I program, <b>XCOM-I</b> endows the executables it produces with a uniform set of options; if (say) you had compiled an XPL program such as <i>MyProgram</i>.xpl, via a command like "<font color="#663300"><code>XCOM-I.py <i>MyProgram</i>.xpl</code></font>", you could find out what <i><b>MyProgram</b></i>'s uniform options were with the command "<i>MyProgram</i> --help".<br></p>
<p>But that tells us only about options that are the same in all 
programs of the XCOM-iverse.  What about options that influence the XPL 
or XPL/I program itself in program-specific ways?  What options specific to <i>MyProgram</i>.xpl are there, and how can those options be selected?<br></p>
<p>Originally, programs run on the IBM 360 would have been associated 
with Job Control Language (JCL) cards that (among other things) would 
have set the program options via what's called the "PARM field".  For 
example, in these JCL "EXEC" cards,<br></p>
<blockquote>
  <pre><font color="#663300">// XPL  EXEC  PGM=MONITOR,<br>//            PARM='SYTSIZE=1800,REFSIZE=2000,LISTING2,$I,$V,$U,$W'<br>...</font><br></pre>
</blockquote>
the PARM field is <font color="#663300"><code>'SYTSIZE=1800,REFSIZE=2000,LISTING2,$I,$V,$U,$W'</code></font>.&nbsp; Of course, we have no JCL in our <b>XCOM-I</b> framework, but the equivalent would be the <font color="#663300"><code>--parm</code></font> command-line option, <i>à la</i><br>
<blockquote>
  <pre><font color="#663300"><i>MyProgram</i> --parm=<code>'SYTSIZE=1800,REFSIZE=2000,LISTING2,$I,$V,$U,$W'</code></font></pre>
</blockquote>
Such a PARM field consists of individual options (or parameters), 
separated by commas (and no spaces surrounding the commas).&nbsp; So in 
this example, the parameters being selected for <i><b>MyProgram</b></i> are<br>
<blockquote>
  <pre><font color="#663300">SYTSIZE=1800<br>REFSIZE=2000<br>LISTING2<br>$I<br>$V<br>$U<br>$W</font><br></pre>
</blockquote>
As for how these parameters get from the PARM field to the XPL or XPL/I 
program itself — i.e., how do you write XPL code to access the 
parameters? —  there is unfortunately no standardized method.&nbsp; In 
the vision of <i>A Compiler Generator</i>, a vision which Intermetrics shared, there's an assembly-language program called the <i>submonitor</i>, separate from <b><i>MyProgram</i></b>,
 that parses the PARM field to find the individual parameters and 
decides what to do with them.&nbsp; Some of the parameters may influence
 the submonitor itself, and never even be made available to the XPL 
program at all.&nbsp; Others may be used to set the values of variables 
used by the XPL program.&nbsp; For example, McKeeman (p. 251) suggests 
some "possible" parameters, and McKeeman's sample submonitor 
program (XMON.bal) does various things with parameters of those 
suggested names.&nbsp; Indeed, I think all of McKeemans suggested parameters 
affect only the submonitor, which doesn't exist at all in <b>XCOM-I</b>, so none of these suggested options are implemented in <b>XCOM-I</b>.&nbsp; Or at least, not supported in the same way, as you'll see some or all of them reappear in a little bit.<br>
<br>
In other words, there's not meaningful support for program parameters for standard XPL in <b>XCOM-I</b>, because standard XPL itself had no standard method for dealing with them. <br>
<br>
For XPL/I, on the other hand, Intermetrics had an elaborate set of parameters for <b>HAL/S-FC</b>, as well as a system for making those parameters available available to the XPL/I program.&nbsp; <b>XCOM-I</b>
 fully supports passing these Intermetrics parameters to the XPL/I 
program.&nbsp; Take a look at the first page of a report from a typical 
run of <b>HAL/S-FC</b>:<br>
<blockquote>
  <pre><font color="#009900">  HAL/S REL32V0           T H E   V I R T U A L   A G C   P R O J E C T            MAY 17, 2024    16:43:5.39     PAGE 1<br><br><br>   HAL/S COMPILER PHASE 1 -- VERSION OF MAY 17, 2024.  CLOCK TIME = 9:15:17.00.<br><br><br>TODAY IS MAY 17, 2024.  CLOCK TIME = 16:43:5.39.<br> <br> PARM FIELD: TITLE=T H E   V I R T U A L   A G C   P R O J E C T<br><br><br> COMPLETE LIST OF COMPILE-TIME OPTIONS IN EFFECT<br><br><br>       *** TYPE 1 OPTIONS ***<br> <br>        NOADDRS<br>        NODECK<br>        NODUMP<br>        NOHALMAT<br>        NOHIGHOPT<br>        NOLFXI<br>        NOLIST<br>        NOLISTING2<br>        NOLSTALL<br>        NOPARSE<br>        NOREGOPT<br>          SCAL<br>        NOSDL<br>        NOSREF<br>        NOSRN<br>        NOTABDMP<br>          TABLES<br>        NOTABLST<br>        NOVARSYM<br>          ZCON<br><br><br>       *** TYPE 2 OPTIONS ***<br> <br>       BLOCKSUM = 400<br>       CARDTYPE = <br>       COMPUNIT = 0<br>            DSR = 1<br>      LABELSIZE = 1200<br>         LINECT = 59<br>      LITSTRING = 2500<br>      MACROSIZE = 500<br>          PAGES = 2500<br>        SYMBOLS = 200<br>          TITLE = T H E   V I R T U A L   A G C   P R O J E C T<br>       XREFSIZE = 2000<br> <br><br> *** NO LANGUAGE SUBSET IN EFFECT ***</font><br></pre>
</blockquote>
As you can see, the first thing such a typical run does is to print the PARM field as is, then then to print a list of the 
individual parameters in effect.&nbsp; Parameters are categorized as either "Type 
1", which means that they are simple on/off settings, or else as "Type 
2", which means that they accept numerical or string values.&nbsp; For 
example, the option allowing for production of HALMAT by <b>HAL/S-FC</b>'s first pass is of Type 1:&nbsp; It is turned "on" with the parameter <font color="#009900"><code>HALMAT</code></font> or turned "off" with the parameter <font color="#009900"><code>NOHALMAT</code></font>; its default is "off" (<font color="#009900"><code>NOHALMAT</code></font>).&nbsp;
 (Don't worry about the fact that you don't know what "HALMAT" is, or 
why one might want to produce it.)&nbsp; Whereas the option that 
overrides the company name in the page heading is of Type 2:&nbsp; Its 
default value is an empty string, meaning "don't override" the default 
company name, but in this case I've overridden it via a PARM field of <font color="#663300"><code>--parm='TITLE=T H E&nbsp;&nbsp; V I R T U A L&nbsp;&nbsp; A G C&nbsp;&nbsp; P R O J E C T'</code></font>.&nbsp;
 Notice that parameters whose values are strings are not enclosed in 
quotes, which might mean that a string parameter such as this one cannot
 contain a comma.<br><br>
In addition to Type 1 and Type 2, parameters are also categorized as <i>printable</i> or <i>unprintable</i>.&nbsp;
 The only distinction is that "printable" ones are printed out on the 
first page of the output listing, and the "unprintable" ones are 
not.&nbsp; In other words, there a lots of other parameters whose values <i>aren't</i> shown in the sample printout above.&nbsp; So there are actually 3 separate categories of parameters:&nbsp; Type 1 
printable, Type 1 unprintable, and Type 2 printable.&nbsp; (While in 
principle there are Type 2 unprintable parameters also, there are none presently 
defined in any existing options processor.)<br>
<blockquote><font size="-1"><b>Aside:</b> There are several exceptions too.  The parameter <font color="#009900"><code>LFXI</code></font> / <font color="#009900"><code>NOLFXI</code></font> is categorized as "non-printable" and yet special code was apparently inserted into <b>HAL/S-FC</b> to make it print anyway; the comments in the code explicitly say so.  The same section of code, on the other hand, explicitly <i>prevents</i> printing of the parameters <font color="#009900"><code>QUASI</code></font> and <font color="#009900"><code>TRACE</code></font>, even though they're categorized as printable. </font><br>
</blockquote>
I should note that not all of the parameters are documented ... though I
 suppose by now you probably shouldn't be very surprised by that.&nbsp; 
There's pretty good documentation of quite a few of them in the HAL/S-FC
 User's Manual (<a moz-do-not-send="true" href="https://www.ibiblio.org/apollo/Shuttle/HAL_S-FC%20User's%20Manual%20Nov%202005.pdf#page=65">see Section 5.0</a>), and some less-reliable documentation in <a moz-do-not-send="true" href="https://www.ibiblio.org/apollo/Shuttle/19760020796.pdf#page=830">IR-182 Sections 13.4</a> and <a moz-do-not-send="true" href="https://www.ibiblio.org/apollo/Shuttle/19760020796.pdf#page=59">3.3</a>,
 which I assume you'll be able to read without my explaining them 
first.&nbsp; (That's a lie, by the way; I just don't understand all of 
them well enough to regurgitate them, or else I'm sure I would!)<br>
<br>
Parameters are delivered to the XPL/I program via the <font color="#663300"><code>MONITOR(13)</code></font> function.&nbsp; (<a moz-do-not-send="true" href="#MONITOR13">See here</a>
 to read about the precise mechanism.)&nbsp; In brief, there are several
 "options processors" available to parse the PARM field and provide the 
parsed contents to the XPL/I program.&nbsp; These options processors are
 specific to the XPL/I program you're compiling.&nbsp; The existing 
options processors built into the runtime library go by the names<br>
<ul>
  <li>COMPOPT (default)<br>
</li>
  <li>LISTOPT</li>
  <li>MONOPT<br></li>
</ul>
With <font color="#663300"><code>MONITOR(13)</code></font>, <i>one</i> 
of those options processors is selected; there's no mixing-and-matching 
allowed.&nbsp; We'll get to the topic of what to do if none of these 
meets your needs in a moment.<br>
<br>
If the XPL/I program being compiled is <b>HAL/S-FC</b>, these existing 
options processors can have different behavior depending when compiling 
the Primary Flight Software (PFS) vs the Backup Flight Software (BFS), 
vs compiling for the IBM 360 ... by which I mean that different options 
are supported in these cases.&nbsp; The following table gives very brief
 summary of the parameters supported by each existing options processor.<br>
<blockquote><font size="-1"><b>Note:</b>&nbsp; In the Type 1 sections of the table, what's given are the parameters to <i>enable</i> the settings.&nbsp; The parameters to <i>disable</i>
 the settings are the same, but prefixed by "NO"; for example, LISTING2 
vs NOLISTING2.&nbsp; Many of the parameters (both Type 1 and Type 2) 
also allow you to use an abbreviated nickname; for example, if you're 
too lazy to type LISTING2, you can instead use the nickname L2.&nbsp; If
 you want to negate a parameter nickname, you can prefix it with "N" (<i>not</i>
 "NO"); for example L2 vs NL2.&nbsp; In other words, LISTING2=L2 and 
NOLISTING2=NL2. &nbsp; Moreover, each parameter has a default value 
that's used if you don't explicitly specify a new one.&nbsp; In the table below, the 
parentheses after the parameter names give both the default values and 
the nicknames (if any).</font><br>
</blockquote>
<br>
<table align="center" cellspacing="2" cellpadding="2" border="1">
  <tbody>
    <tr>
      <td valign="top" align="center"><b>COMPOPT<br>
PFS</b><br>
      </td>
      <th valign="top" align="center">COMPOPT<br>
BFS<br>
      </th>
      <th valign="top" align="center">COMPOPT<br>
360<br>
      </th>
      <td valign="bottom" align="center"><b>LISTOPT</b></td>
      <th valign="bottom" align="center">MONOPT</th>
    </tr>
    <tr>
      <td rowspan="1" colspan="5" valign="top" align="center"><i>Type 1, Printable</i><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">DUMP (off, DP)<br>
      </td>
      <td valign="top" align="center">DUMP (off, DP)</td>
      <td valign="top" align="center">DUMP (off, DP)</td>
      <td valign="top" align="center">TABLST (off, TL)<br>
      </td>
      <td valign="top" align="center">DUMP (off, DP)<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">LISTING2 (off, L2)<br>
      </td>
      <td valign="top" align="center">LISTING2 (off, L2)<br>
      </td>
      <td valign="top" align="center">LISTING2 (off, L2)</td>
      <td valign="top" align="center">TABDMP (off, TBD)<br>
      </td>
      <td valign="top" align="center">LISTING2 (off, L2)<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">LIST (off, L)<br>
      </td>
      <td valign="top" align="center">LIST (off, L)<br>
      </td>
      <td valign="top" align="center">LIST (off, L)</td>
      <td valign="top" align="center">ALL (off)<br>
      </td>
      <td valign="top" align="center">ALTER (off)<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">TRACE (on, TR)<br>
      </td>
      <td valign="top" align="center">TRACE (on, TR)<br>
      </td>
      <td valign="top" align="center">TRACE (on, TR)</td>
      <td valign="top" align="center">BRIEF (off)<br>
      </td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">VARSYM (off, VS)<br>
      </td>
      <td valign="top" align="center">VARSYM (off, VS)<br>
      </td>
      <td valign="top" align="center">DECK (off, D)</td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">DECK (off, D)<br>
      </td>
      <td valign="top" align="center">DECK (off, D)<br>
      </td>
      <td valign="top" align="center">TABLES (on, TBL)</td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">TABLES (on, TBL)<br>
      </td>
      <td valign="top" align="center">TABLES (on, TBL)<br>
      </td>
      <td valign="top" align="center">TABLST (off, TL)</td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">TABLST (off, TL)<br>
      </td>
      <td valign="top" align="center">TABLST (off, TL)<br>
      </td>
      <td valign="top" align="center">ADDRS (off, A)</td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">ADDRS (off, A)<br>
      </td>
      <td valign="top" align="center">ADDRS (off, A)<br>
      </td>
      <td valign="top" align="center">SRN (off)</td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">SRN (off)<br>
      </td>
      <td valign="top" align="center">SRN (off)<br>
      </td>
      <td valign="top" align="center">SDL (off)</td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">SDL (off)<br>
      </td>
      <td valign="top" align="center">SDL (off)<br>
      </td>
      <td valign="top" align="center">TABDMP (off, TBD)</td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">TABDMP (off, TBD)<br>
      </td>
      <td valign="top" align="center">TABDMP (off, TBD)<br>
      </td>
      <td valign="top" align="center">ZCON (on, Z)</td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">ZCON (on, Z)<br>
      </td>
      <td valign="top" align="center">ZCON (on, Z)<br>
      </td>
      <td valign="top" align="center">FCDATA (off, FD)<br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">HALMAT (off, HM)<br>
      </td>
      <td valign="top" align="center">HALMAT (off, HM)<br>
      </td>
      <td valign="top" align="center">SCAL (on, SC)<br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">REGOPT (off, R)<br>
      </td>
      <td valign="top" align="center">SCAL (on, SC)<br>
      </td>
      <td valign="top" align="center">MICROCODE (on, MC)<br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">MICROCODE (on, MC)<br>
      </td>
      <td valign="top" align="center">MICROCODE (on, MC)<br>
      </td>
      <td valign="top" align="center">SREF (off, SR)<br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">SREF (off, SR)<br>
      </td>
      <td valign="top" align="center">SREF (off, SR)<br>
      </td>
      <td valign="top" align="center">QUASI (off, Q)<br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">QUASI (off, Q)<br>
      </td>
      <td valign="top" align="center">QUASI (off, Q)<br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">TEMPLATE (off, TP)<br>
      </td>
      <td valign="top" align="center">REGOPT (off, R)<br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">HIGHOPT (off, HO)<br>
      </td>
      <td valign="top" align="center">TEMPLATE (off, TP)<br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center">HIGHOPT (off, HO)<br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td rowspan="1" colspan="5" valign="top" align="center"><i>Type 1, Unprintable</i><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">PARSE (off, P)<br>
      </td>
      <td valign="top" align="center">PARSE (off, P)<br>
      </td>
      <td valign="top" align="center">PARSE (off, P)<br>
      </td>
      <td valign="top" align="center">X3 (off)</td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">LSTALL (off, LA)<br>
      </td>
      <td valign="top" align="center">LSTALL (off, LA)<br>
      </td>
      <td valign="top" align="center">LSTALL (off, LA)<br>
      </td>
      <td valign="top" align="center">X4 (off)</td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">LFXI (on)<br>
      </td>
      <td valign="top" align="center">LFXI (on)<br>
      </td>
      <td valign="top" align="center">LFXI (on)<br>
      </td>
      <td valign="top" align="center">X5 (off)</td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">X1 (off)<br>
      </td>
      <td valign="top" align="center">X1 (off)</td>
      <td valign="top" align="center">X0 (off)</td>
      <td valign="top" align="center">X6 (off)</td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">X4 (off)</td>
      <td valign="top" align="center">X4 (off)</td>
      <td valign="top" align="center">X1 (off)</td>
      <td valign="top" align="center">X7 (off)</td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">X5 (off)</td>
      <td valign="top" align="center">X5 (off)</td>
      <td valign="top" align="center">X2 (off)</td>
      <td valign="top" align="center">X8 (off)</td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">XA (off)</td>
      <td valign="top" align="center">XA (off)</td>
      <td valign="top" align="center">X3 (off)</td>
      <td valign="top" align="center">X9 (off)</td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">X6 (off)</td>
      <td valign="top" align="center">X6 (off)</td>
      <td valign="top" align="center">X4 (off)</td>
      <td valign="top" align="center">XA (off)</td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">XB (off)</td>
      <td valign="top" align="center">XB (off)</td>
      <td valign="top" align="center">XA (off)</td>
      <td valign="top" align="center">XD (off)</td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">XC (off)</td>
      <td valign="top" align="center">XC (off)</td>
      <td valign="top" align="center">X6 (off)</td>
      <td valign="top" align="center">XE (off)</td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">XE (off)</td>
      <td valign="top" align="center">XF (off)</td>
      <td valign="top" align="center">XB (off)</td>
      <td valign="top" align="center">XF (off)</td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">XF (off)</td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center">XC (off)</td>
      <td valign="top" align="center">XG (off)</td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center">XE (off)</td>
      <td valign="top" align="center">XH (off)</td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center">XF (off)</td>
      <td valign="top" align="center">XI (off)</td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center">XJ (off)</td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center">XK (off)</td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center">XL (off)</td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center">XM (off)</td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center">XN (off)</td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center">XO (off)</td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center">XP (off)</td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td rowspan="1" colspan="5" valign="top" align="center"><i>Type 2, Printable</i><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">TITLE ("", T)<br>
      </td>
      <td valign="top" align="center">TITLE ("", T)</td>
      <td valign="top" align="center">TITLE ("", T)</td>
      <td valign="top" align="center">TITLE ("", T)<br>
      </td>
      <td valign="top" align="center">LINECT (59, LC)<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">LINECT (59, LC)<br>
      </td>
      <td valign="top" align="center">LINECT (59, LC)</td>
      <td valign="top" align="center">LINECT (59, LC)</td>
      <td valign="top" align="center">LINECT (59, LC)<br>
      </td>
      <td valign="top" align="center">PAGES (250, P)<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">PAGES (2500, P)<br>
      </td>
      <td valign="top" align="center">PAGES (2500, P)</td>
      <td valign="top" align="center">PAGES (250, P)<br>
      </td>
      <td valign="top" align="center">PAGES (10000, P)<br>
      </td>
      <td valign="top" align="center">MIN (50000)<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">SYMBOLS (200, SYM)<br>
      </td>
      <td valign="top" align="center">SYMBOLS (200, SYM)</td>
      <td valign="top" align="center">SYMBOLS (200, SYM)<br>
      </td>
      <td valign="top" align="center">LIST (1, L)<br>
      </td>
      <td valign="top" align="center">MAX (5000000)<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">MACROSIZE (500, MS)<br>
      </td>
      <td valign="top" align="center">MACROSIZE (500, MS)</td>
      <td valign="top" align="center">MACROSIZE (500, MS)<br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center">FREE (14336)<br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">LITSTRINGS (2000, LITS)<br>
      </td>
      <td valign="top" align="center">LITSTRINGS (2000, LITS)</td>
      <td valign="top" align="center">LITSTRINGS (2000, LITS)<br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">COMPUNIT (0, CU)<br>
      </td>
      <td valign="top" align="center">COMPUNIT (0, CU)</td>
      <td valign="top" align="center">COMPUNIT (0, CU)<br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">XREFSIZE (2000, XS)<br>
      </td>
      <td valign="top" align="center">XREFSIZE (2000, XS)</td>
      <td valign="top" align="center">XREFSIZE (2000, XS)<br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">CARDTYPE ("", CT)<br>
      </td>
      <td valign="top" align="center">CARDTYPE ("", CT)</td>
      <td valign="top" align="center">CARDTYPE ("", CT)<br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">LABELSIZE (1200, LBLS)<br>
      </td>
      <td valign="top" align="center">LABELSIZE (1200, LBLS)</td>
      <td valign="top" align="center">LABELSIZE (1200, LBLS)<br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">DSR (1)<br>
      </td>
      <td valign="top" align="center">DSR (1)</td>
      <td valign="top" align="center">DSR (1)<br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">BLOCKSUM (400, BS)<br>
      </td>
      <td valign="top" align="center">BLOCKSUM (400, BS)</td>
      <td valign="top" align="center">BLOCKSUM (400, BS)<br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
    <tr>
      <td valign="top" align="center">MFID ("")<br>
      </td>
      <td valign="top" align="center">OLDTPL ("", 0)<br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
      <td valign="top" align="center"><br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<br>
In addition to these named parameters, <a moz-do-not-send="true" href="https://www.ibiblio.org/apollo/Shuttle/19760020796.pdf#page=830">early documentation</a> indicates that <i>control toggles</i>
 can also appear in the PARM field.&nbsp; Control toggles are 
two-character strings which normally would be embedded in program 
comments.&nbsp; Generally speaking, program comments are ignored by 
compilers.&nbsp; But when these particular two-character strings are 
found within a program comment of an XPL program, they are used to 
enable certain program features from the point they appear until a 
countermanding control toggle is found.&nbsp; The control toggles I'm aware of that were supported by one or another version of <b>XCOM</b> are listed below.&nbsp; Not all of them are necessarily suitable for command-line usage; for example, the action of "<font color="#663300"><code>$|</code></font>"
 depends on its particular column.&nbsp; The list below has been merged 
from McKeeman (p. 148), IR-182-1 (section 13.4), and SUNY XCOM 4.5 
source code:<br>
<ul>
  <li><font color="#663300"><code>$B</code></font> — Interlist code bytes in hexadecimal.</li>
  <li><font color="#663300"><code>$D</code></font> — Print compilation statistics and symbol table at the end of compilation (initially enabled).</li>
  <li><font color="#663300"><code>$E</code></font> — Interlist emitted code (assembly format) and data.</li>
  <li><font color="#663300"><code>$I</code></font> — Print Impact 
summary, indicating variables outside the scope of any procedure which 
were referenced, plus procedures called.&nbsp; (Default = Off.)<br>
  </li>
  <li><font color="#663300"><code>$L</code></font> — List the compiled program (listing is initially enabled).</li>
  <li><font color="#663300"><code>$M</code></font> — List program without auxiliary information (speeds compilation by minimizing string storage usage).</li>
  <li><font color="#663300"><code>$N</code></font> — Produce a warning message if a procedure is called with fewer actual than formal parameters.</li>
  <li><font color="#663300"><code>$Q</code></font> — This toggle seems to have been available for a while and then discontinued.&nbsp; It <i>may</i> have caused compilation to terminate after processing the library file.<br>
  </li>
  <li><font color="#663300"><code>$R</code></font> — Collect cross-reference data for each symbol (based on statement numbers) and print with symbol table. (Default = On.)<br>
  </li>
  <li><font color="#663300"><code>$S</code></font> — Dump symbol table at the end of each procedure, if any local data is declared. (Default = Off.)<br>
  </li>
  <li><font color="#663300"><code>$T</code></font> — Begin tracing execution of XCOM at this point, during compilation.</li>
  <li><font color="#663300"><code>$U</code></font> — Terminate tracing of XCOM.</li>
  <li><font color="#663300"><code>$V</code></font> — Expand variable 
cross reference to include names of procedures referencing data and 
names of procedures calling other procedures.&nbsp; (Default = Off.)</li>
  <li><font color="#663300"><code>$X</code></font> — Do not abort compilation when ceiling on count of severe errors has been exceeded.<br>
  </li>
  <li><font color="#663300"><code>$Y</code></font> — Use <font color="#663300"><code>'|'</code></font> as margin marker rather than <font color="#663300"><code>'I'</code></font>.<br>
  </li>
  <li><font color="#663300"><code>$Z</code></font> — Allow the compiled program to execute in spite of severe errors.</li>
  <li><font color="#663300"><code>$|</code></font> — Set margin.&nbsp; 
The portion of succeeding cards starting from the column containing the |
 will be ignored.&nbsp; Note that this can only be used to make the card
 width <i>shorter</i> than 80 columns.<br>
  </li>
</ul>
If control 
toggles were able to appear in the PARM field (as well as inside of 
program comments), then in effect they'd act like unnamed Type 1 
parameters.&nbsp; Indeed, you can see examples of these in the sample 
JCL cards I showed you at the top of this section.&nbsp; But I am unclear as to 
whether control toggles survived into the latest versions of XPL/I or 
not, and whether they're acceptable in PARM fields.&nbsp; Currently, parameters with a leading '<font color="#663300"><code>$</code></font>'
 are 
accepted (in the sense that there's no error message or abend) in PARM 
fields, but 
ignored.&nbsp; However, there is a command-line option that can be made 
to serve the same purpose as control toggles in the PARM field:&nbsp; 
The <font color="#663300"><code>--extra=<i>N</i>,'<i>STRING</i>'</code></font> option causes the <font color="#663300"><code><i>STRING</i></code></font> to be returned to the XPL program upon the first invocation of <font color="#663300"><code>INPUT(<i>N</i>)</code></font>; subsequent invocations of <font color="#663300"><code>INPUT(<i>N</i>)</code></font> get data from the file attached to input <font color="#663300"><code><i>N</i></code></font>.&nbsp; So for example, if you wanted to use the control toggle <font color="#663300"><code>$E</code></font>, but didn't want to modify your XPL source code to add it into a comment, you could use the command-line option <font color="#663300"><code>--extra=0,'/* $E */'</code></font>.<br>
<blockquote><b><font size="-1">Aside:</font></b><font size="-1">&nbsp; </font><font size="-1">Again, to be clear, <b>XCOM-I</b>
 itself has no cognizance whatever of control toggles.&nbsp; Control 
toggles, if available, are provided to and used by legacy versions of <b>XCOM</b> which <b>XCOM-I</b> may have compiled for you.</font><br>
</blockquote>




If you're writing <i>new</i> XPL or XPL/I programs, of course, then 
these specific options processors aren't going to satisfy your 
needs.&nbsp; There are still ways you can process options for your own 
custom purposes.&nbsp; I don't want to go into
 great detail, since it's unclear who (if anybody) will actually be 
producing any new XPL programs, so here I'll just give it the 
once-over-lightly.&nbsp; There are three different approaches of greater
 or 
lesser difficulty and (in)convenience.&nbsp; <br>
<blockquote><font size="-1"><b>Aside:</b>&nbsp; Several of the possible approaches involve providing your own C code to supplement the C code output by <b>XCOM-I</b> when it translates your XPL or XPL/I source code.&nbsp; That can be done via <font color="#663300"><code>CALL INLINE</code></font>
 statements in your XPL/I source code, but it's rather cumbersome to do 
so.&nbsp; A more-elegant way is to instead create an entire C 
source-code file, and then just place it into the folder of C code 
created by <b>XCOM-I</b>.&nbsp; Such a file should have an '<font color="#663300"><code>#include "runtimeC.h"</code></font>'
 in it, and proceed from there.&nbsp; If it involves any active code, 
versus compile-time initialization of variables, you'll still have to 
have a </font><font size="-1"><font size="-1"><font color="#663300"><code>CALL INLINE</code></font></font> in your XPL/I code to actually call the new C function you've defined.<br>
    <br>
    <b>Very importan</b><b>t</b>:&nbsp; Any custom file you put into <b>XCOM-I</b>'s output folder for any given project will be <u><i>deleted</i></u> the next time <b>XCOM-I</b> builds that project.&nbsp; So make sure it's not your <i>only</i> copy!&nbsp; In this sense, using a filesystem link to your custom C file is safer than using the file itself.<br>
  </font></blockquote>

<ol>
  <li><a moz-do-not-send="true" href="#builtin">The built-in library function</a> <font color="#663300"><code>PARM_FIELD</code></font> returns a string containing the value of the <font color="#663300"><code>--parm</code></font> command-line switch as-is.  You could therefore just write XPL code to parse <font color="#663300"><code>PARM_FIELD</code></font>.  This will be your easiest course of action.</li>
  
  
<li>Or if you would prefer to do things "the Intermetrics way", you can 
devise an options processor that takes advantage of the machinery 
already in the <b>XCOM-I</b> runtime library.  This lets you feed in your parameters using the <font color="#663300"><code>--parm</code></font>
 command-line switch, using the same "PARM"/"NOPARM" syntax as the other
 options processors.  If you look at the source-code file 
XCOM-I/runtimeC.c, you'll find several instances of a datatype called <font color="#663300"><code>optionsProcessor_t</code></font>,
 which is a structure whose definition you can examine in the file 
runtimeC.h.  Basically, it's just a structure listing all of the Type 1 
and Type 2 parameter names, their abbreviated nicknames, the negations 
of both types of names, the default value of the parameter, and a 
"mask".  I'll explain what a mask is in a moment.  I hope it will be 
reasonably clear from looking at those examples just how to make your 
own custom <font color="#663300"><code>optionsProcessor_t</code></font>.  If you can do that, you'll be ready for XPL/I calls to <font color="#663300"><code>MONITOR</code></font> of the form "<font color="#663300"><code>CALL MONITOR(13, 'USEROPT');</code></font>".  Here, <font color="#663300"><code>'USEROPT'</code></font> is literal; you don't get a choice of what to call it. The C code you need to create to do all of that doesn't require any <font color="#663300"><code>CALL INLINE</code></font> statements, and looks something like the following:</li>
</ol>
<blockquote>
  <blockquote>
    <pre><font color="#663300">#include "runtimeC.h"<br>optionsProcessor_t <i>myOptionsProcessor</i> = {<br>	... <br>};<br>USEROPT = &amp;<i>myOptionsProcessor</i>;</font><br></pre>
  </blockquote>
</blockquote>
<ol>

</ol>

<ol start="3">
  <li>Or you could provide C code to directly process <font color="#663300"><code>argv[] </code></font>and <font color="#663300"><code>argc</code></font>.  
This may be the hardest approach of all, since as you'll recall, XPL 
variables are not modeled as C variables.  To get any parsed parameters 
into XPL variables requires numerically knowing the addresss at which 
the variables reside in the simulated IBM 360 memory (C array <font color="#663300"><code>memory</code></font>),
 as well as knowing the names of the C functions to convert the values 
into IBM 360 formats.  While there's only a handful of such functions (<font color="#663300"><code>putFIXED</code></font>, <font color="#663300"><code>putCHARACTER</code></font>, ...), I have not documented them as of yet, nor indeed <i>any</i> of the functions used privately by <b>XCOM-I</b>'s runtime library.</li>
</ol>
<p>As far as the "mask" is concerned, among the items returned by the <font color="#663300"><code>MONITOR(13)</code></font> function is a 32-bit (<font color="#663300"><code>FIXED</code></font>) value referred to as the "options code" or the "option bits".  Each type 1 parameter sets or resets (or <i>can</i>
 be made to set or reset) one bit position in the options code.  That's 
what the "mask" is:  A specification of the bit (or combination of bits)
 the parameter sets.  For example, the LISTING2 parameter is associated 
with mask 0x00000002, and therefore will bitwise OR the options code 
with 2; whereas NOLISTING2 would bitwise AND the options code with ~2 
(0xFFFFFFFE).    Or you can just use a mask of 0x00000000, and your new 
parameter(s) will leave the options code untouched.<br></p>

<blockquote>
</blockquote>

<font color="#663300"><code></code></font>
<ul>

</ul>

<h3><a name="builtin"></a>Built-In Runtime-Library Functions</h3>
<p>Standard XPL has a variety of so-called "built-ins", comprising 
runtime-library functions callable from XPL code.  Some of these 
bullt-ins can appear on either the right-hand or left-hand side of 
assignments, and some have to be <font color="#663300"><code>CALL</code></font>'d like user-defined <font color="#663300"><code>PROCEDURE</code></font>s.
 XPL/I has roughly the same built-ins, plus-or-minus a few, mostly (but 
not entirely) defined to have the same functionality.  The compiler 
recognizes these built-ins, and there is no need for them to be declared
 in any way prior to use.  Since these built-ins were mostly written 
originally in IBM System/360 basic assembly language, the runtime 
library supplied with XCOM-I has been entirely written in C, without any
 reference to the original runtime-library source code.<br></p>
<p>The list below is from McKeeman (p. 140-142), with some alterations 
due to XPL/I, and some hopefully-helpful notes from me.  The parameter 
descriptions in the list below identify the datatypes of parameters by 
the following convention:<br></p>
<ul>
  <li><font color="#663300"><code>FIXED</code></font> — <code><font color="#663300">NE</font></code><font color="#663300"><code><sub>x</sub></code></font></li>
  <li><font color="#663300"><code>CHARACTER</code></font> descriptor — <font color="#663300"><code></code><code>DE<sub>x</sub></code></font></li>
  <li>Symbolic name of a variable, with or without a subscript — <font color="#663300"><code></code><code>V</code></font></li></ul>
<p>I suppose I should make it clear that the <b>XCOM-I</b> environment 
is not precisely like that envisaged in the original XPL language as 
confined to an IBM 360 runtime environment, and as such, built-in 
functions don't work exactly the same way either.  What's described here
 is how <i>the </i><i><b>XCOM-I</b></i><i> runtime library's functions </i>corresponding to the original built-in functions work.<br></p>
<ul>

</ul>

<table align="center" cellspacing="2" cellpadding="2" border="1">
  <tbody>
    <tr>
      <th valign="bottom" align="center">Library Function<br>
      </th>
      <th valign="bottom">Description From Original Documentation<br>
      </th>
      <th valign="bottom">Additional Notes<br>
      </th>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>ABS(NE)</code><code><br>
          </code></font></td>
      <td valign="middle">This function returns the absolute value of <font color="#663300"><code>NE</code></font>.&nbsp;
 (Note: "80000000", the maximum negative number, has no representable 
absolute value and returns "7FFFFFFF", the maximum positive number.)<br>
      </td>
      <td valign="middle">(XPL/I only.)<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>ADDR(V)</code></font></td>
      <td valign="middle">A function with numeric value which is the (at most) 24-bit absolute address of the variable (subscripted or not) <font color="#663300"><code>V</code></font>.&nbsp; Mostly used in conjunction with <font color="#663300"><code>COREWORD</code></font> or <font color="#663300"><code>COREBYTE</code></font>.<br>
      </td>
      <td valign="middle">If the variable has a subscript, then the 
returned address is that of a specific array element, rather than of the
 beginning of the array.&nbsp; For a <font color="#663300"><code>CHARACTER</code></font> or long <code><font color="#663300">BIT</font></code> string (i.e., for <font color="#663300"><code>BIT(33)</code></font> through <font color="#663300"><code>BIT(2048)</code></font> datatypes), the returned address is that of the <i>descriptor</i>
 for the variable, and if you want to find the actual data, you then 
must first fetch the value of the descriptor and then massage it 
further.&nbsp; For XPL/I's <font color="#663300"><code>BASED</code></font> variables (see IR-182-1 p. 13-3), using the unsubscribed name of the variable for <code><font color="#663300">V</font></code><font color="#663300"><code></code></font> will return the address in memory where the pointer to the <font color="#663300"><code>BASED</code></font> variable's data is stored; whereas adding the subscript <font color="#663300"><code>(0)</code></font> to <code><font color="#663300">V</font></code><font color="#663300"><code></code></font> returns the address of the variable's data itself.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>BYTE(DE,NE)<br>
          </code></font></td>
      <td valign="middle">A function with numeric value given by the <font color="#663300"><code>NE</code></font><font size="-1"><sup>th</sup></font> 8 bits of the string described <font color="#663300"><code>DE</code></font>.<br>
      </td>
      <td valign="middle">By "string", McKeeman means either <font color="#663300"><code>CHARACTER</code></font> data or <font color="#663300"><code>BIT</code></font> data.&nbsp; As far as <font color="#663300"><code>BIT</code></font> data is concerned, this function works for any data-width; i.e., for <font color="#663300"><code>BIT(1)</code></font> through <font color="#663300"><code>BIT(2048)</code></font>, and not just for "long" <font color="#663300"><code>BIT</code></font> string.&nbsp; However, there's some difference between how <font color="#663300"><code>CHARACTER</code></font> and <font color="#663300"><code>BIT</code></font> data is treated.&nbsp; <font color="#663300"><code>BIT</code></font> data is retrieved from memory as-is, whereas <font color="#663300"><code>CHARACTER</code></font>
 data is transparently translated between EBCDIC encoding (in memory) vs
 ASCII encoding (for manipulation) by the software.&nbsp; The latter 
behavior is specific to <b>XCOM-I</b>, and wouldn't have been needed by the original <b>XCOM</b>, since back then, all <font color="#663300"><code>CHARACTER</code></font>
 data was encoded in EBCDIC all the time, whether or not it resided in 
"memory".&nbsp; Moreover, if you try to do so, it is possible to fool <b>XCOM-I</b>'s <font color="#663300"><code>BYTE</code></font>
 function into thinking an area of memory is a different datatype than 
it really is, thus defeating the translation mechanism ... so please 
don't try to do that.<br>
        <br>
Note that <font color="#663300"><code>BYTE</code></font> can appear 
either in an expression (such as on the right-hand side of an assignment), in which case it returns a value as just 
described, or else on the left-hand side of an assignment, in which case
 it modifies the value stored in memory.&nbsp; McKeeman recommends not using <font color="#663300"><code>BYTE</code></font> on the left-hand side of an assigment, due to the possibility of unintended consequences.<br>
        <br>
The documentation does not explain what's supposed to happen if <font color="#663300"><code>NE</code><code>&lt;0</code></font> or <font color="#663300"><code>NE</code><code>&gt;=len(</code><code>DE</code><code>)</code></font>.&nbsp; Alas, that's not a theoretical question, because such uses of <font color="#663300"><code>BYTE</code></font> really appear in legacy XPL code.&nbsp; Given the sloppy subscripting accepted by XPL, my guess is that <font color="#663300"><code>BYTE</code></font> just grabs whatever happens to reside wherever <font color="#663300"><code>NE</code></font>
 leads it.&nbsp; Unlike the usual sloppy subscripting in XPL code, this 
would almost certainly be a mistake by the programmer, because the 
location of string data in memory is dynamically assigned and liable to 
change during the course of execution, so the programmer can't really 
know reliable what lies beyond the bounds of a string.&nbsp; Thus my 
guess is that when <font color="#663300"><code>NE</code></font> is out 
of bounds for the string size, it's probably a mistake on the part of 
the program that was never detected because it never produced any error 
messages.<br>
        <blockquote><font size="-1"><b>Aside:</b> For example, it happens in the <font color="#663300"><code>SCAN</code></font> procedure of <b>XCOM</b>, in the vicinity of line 835 at this writing,<br>
          </font>
          <blockquote>
            <pre><font size="-1" color="#663300">CP = 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>DO WHILE BYTE(TEXT, CP) = BYTE(' ') &amp; CP &lt;= TEXT_LIMIT;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>   CP = CP + 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>END;&nbsp;&nbsp;</font><font size="-1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font></pre>
          </blockquote>
          <font size="-1">where <font color="#663300"><code>TEXT</code></font> happens to be a string with <font color="#663300"><code>LEN(TEXT)=1</code></font> containing a single blank space, and <font color="#663300"><code>TEXT_LIMIT=0</code></font>.&nbsp; Here, <font color="#663300"><code>BYTE(TEXT,CP)</code></font> is out of bounds on the very first iteration of the loop.&nbsp; In C, if the operands of the <font color="#663300"><code>&amp;</code></font> operator were reversed, then <font color="#663300"><code>BYTE(TEXT,CP)</code></font> would never be executed, and the problem would be avoided.&nbsp; But <i>if</i>
 that kind of optimization of conditionals is a feature of XPL, it's not
 a feature that's mentioned anywhere to my knowledge, and <b>XCOM-I</b> does not attempt it.</font><br>
        </blockquote>
Whether or not that's a true in interpretation, in <b>XCOM-I</b> the <font color="#663300"><code>BYTE</code></font> function returns a value of 0 (corresponding to an EBCDIC <font color="#663300"><code>NUL</code></font>) if <font color="#663300"><code>NE</code></font> is out of bounds, or else silently does nothing at all if on the left-hand side of an assignment.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>BYTE(DE)<br>
          </code></font></td>
      <td valign="middle">Same as <font color="#663300"><code>BYTE(DE,0)</code></font></td>
      <td valign="middle"><br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>CLOCK_TRAP<br>
          </code></font></td>
      <td valign="middle">Not supported in <b>XCOM</b>.</td>
      <td valign="middle">And it's not supported in <b>XCOM-I</b> either.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>COMPACTIFY<br>
          </code></font></td>
      <td valign="middle">A procedure called automatically to repack the free storage 
area for string data when it is exhausted. Calls can be triggered by <font color="#663300"><code>||</code></font>, <font color="#663300"><code>INPUT</code></font>, number-to-string conversions, or an explicit call:<br>
        <blockquote><font color="#663300"><code>CALL COMPACTIFY;<br>
            </code></font></blockquote>
        <font color="#663300"><code></code></font>The variables <font color="#663300"><code>FREEBASE</code></font>, <font color="#663300"><code>FREELIMIT</code></font>, <font color="#663300"><code>FREEPOINT</code></font>, <font color="#663300"><code>DESCRIPTOR</code></font>, and <font color="#663300"><code>NDESCRIPT</code></font> are used by <font color="#663300"><code>COMPACTIFY</code></font>.<br>
        <font color="#663300"><code></code></font></td>
      <td valign="middle">The "free-storage area" is where the data for <font color="#663300"><code>CHARACTER</code></font> and long <font color="#663300"><code>BIT</code></font>-string
 variables is stored.&nbsp; As a program which involves string variables
 executes, the strings tend to change size and move around in the 
free-storage area, thus causing unused "holes" in memory to 
develop.&nbsp; <font color="#663300"><code>COMPACTIFY</code></font> repacks the area so as to remove the holes.<br>
<blockquote>
  <font size="-1"><b>Aside:</b>&nbsp; While long <font color="#663300"><code>BIT</code></font>-strings (&gt;32 bits) are technically similar to <font color="#663300"><code>CHARACTER</code></font>
 strings, they differ in the fact that the amount of storage they 
require is determined at compile-time and does not change after 
that.&nbsp; The original McKeeman and Intermetrics compilers therefore 
stored them outside of the free-storage area — or at least in the very 
lowest addresses of the free-string area </font><font size="-1"><font size="-1">—</font>
 in order to save any execution time that would otherwise have been 
wasted during allocation of memory or garbage allocation.&nbsp; <b>XCOM-I</b>
 is not so picky, since even the most feeble modern computer will be 
approximately 14.3926 gazillion times faster than an IBM 360 was.&nbsp; <b>XCOM-I</b>
 thus saves (me) a little effort by grouping the long bit strings with 
the character strings in memory, at an immeasurably-small cost in 
execution time.</font><br>
</blockquote>
XPL/I's <font color="#663300"><code>BASED</code></font> variables are stored in a separate memory region and do not participate in garbage collection by <font color="#663300"><code>COMPACTIFY</code></font>.&nbsp; <a moz-do-not-send="true" href="#MemoryModel">See the earlier discussion of this</a>.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>COREBYTE(NE)<br>
          </code></font></td>
      <td valign="middle">A byte array identical to the IBM System/360 
memory.&nbsp; The subscript is the absolute byte address of the byte 
selected.&nbsp; <font color="#663300"><code>COREBYTE</code></font> may be used on either side of the replacement operator (i.e., <font color="#663300"><code>=</code></font>).<br>
      </td>
      <td valign="middle">The function returns a <font color="#663300"><code>FIXED</code></font>
 value, if used in an expression, but only the least-significant 8 bits 
contain the value.&nbsp; Similarly, if used on the left-hand side of an 
assignment, it receives a <font color="#663300"><code>FIXED</code></font> value from the right-hand side, but only stores the least-significant 8 bits at the specified memory address.&nbsp; The <b>XCOM-I</b> version of this function performs no EBCDIC translation as <font color="#663300"><code>BYTE</code></font> (see above) does, so it does not expect the data in memory to be <font color="#663300"><code>CHARACTER</code></font> data.&nbsp; Whether this will turn out to be an issue remains to be seen.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>COREWORD(NE)<br>
          </code></font></td>
      <td valign="middle">Like <font color="#663300"><code>COREBYTE</code></font>, except the subscript corresponds to the word address in memory.&nbsp; Thus an assignment to <font color="#663300"><code>COREBYTE(4)</code></font> can change <font color="#663300"><code>COREWORD(1)</code></font>.<br>
      </td>
      <td valign="middle">Since XPL has only a 24-bit address space, only the least-significant 3 bytes of the "4-byte word address" <font color="#663300"><code>NE</code></font> are used.&nbsp; According to IR-182-1 (p. 13-3), this function <i>differs</i> in XPL/I as follows:<br>
        <blockquote><font size="-1">According to "<i>A COMPILER GENERATOR</i>", <font color="#663300"><code>NE</code></font> is a word index, or word-aligned address. However, in the Intermetrics version, <font color="#663300"><code>NE</code></font> must be a byte address, and the user must himself guarantee that the lower-most two bits are 0's (full word aligned).</font><br>
        </blockquote>
I <i>think</i> that what's being implied by this cryptic comment is that McKeeman's <font color="#663300"><code>COREWORD</code></font> in XPL worked like this:<br>
        <ul>
          <li><font color="#663300"><code>COREWORD(0)</code></font> consists of <font color="#663300"><code>COREBYTE(0)</code></font> through <font color="#663300"><code>COREBYTE(3)</code></font>.</li>
          <li><font color="#663300"><code>COREWORD(1)</code></font> consists of <font color="#663300"><code>COREBYTE(4)</code></font> through <font color="#663300"><code>COREBYTE(7)</code></font>.</li>
          <li><font color="#663300"><code>COREWORD(2) </code></font>consists of <font color="#663300"><code>COREBYTE(8)</code></font> through <font color="#663300"><code>COREBYTE(11)</code></font>.</li>
          <li>and so on.</li>
        </ul>
        <p>whereas Intermetrics's <font color="#663300"><code>COREWORD</code></font> in XPL/I worked like this:<br></p>
        <ul>
<li><font color="#663300"><code>COREWORD(0)</code></font> consists of <font color="#663300"><code>COREBYTE(0)</code></font> through <font color="#663300"><code>COREBYTE(3)</code></font>.</li>
          <li><font color="#663300"><code>COREWORD(1)</code></font> is illegal.</li>
          <li><font color="#663300"><code>COREWORD(2)</code></font> is illegal.</li>
          <li><font color="#663300"><code>COREWORD(3)</code></font> is illegal.</li>
<li><font color="#663300"><code>COREWORD(4)</code></font> consists of <font color="#663300"><code>COREBYTE(4)</code></font> through <font color="#663300"><code>COREBYTE(7)</code></font>.</li>
          <li><font color="#663300"><code>COREWORD(5)</code></font> is illegal.</li>
          <li><font color="#663300"><code>COREWORD(6)</code></font> is illegal.</li>
          <li><font color="#663300"><code>COREWORD(7)</code></font> is illegal.</li>
<li><font color="#663300"><code>COREWORD(8) </code></font>consists of <font color="#663300"><code>COREBYTE(8)</code></font> through <font color="#663300"><code>COREBYTE(11)</code></font>.</li>
          <li><font color="#663300"><code>COREWORD(9)</code></font> is illegal.</li>
<li>and so on.</li>
        </ul>
        <p>To my way of thinking, McKeeman's description doesn't say 
what IR-182-1 says it says, and unfortunately, McKeeman's clarification 
that "an assignment to <font color="#663300"><code>COREBYTE(4)</code></font> can change <font color="#663300"><code>COREWORD(1)</code><font color="#000000">", does not in fact clarify it very much either.<br></font></font></p>
        <p><font color="#663300"><font color="#000000"><b>XCOM-I</b> 
conforms to the latter (Intermetrics) usage, with the exception that 
addresses like 1, 2, 3, 5, 6, 7, 9, ... are perfectly fine:  </font></font><font color="#663300"><code>COREWORD(1)</code></font> consists of <font color="#663300"><code>COREBYTE(1)</code></font> through <font color="#663300"><code>COREBYTE(4)</code></font>, and so on.  Which conforms just fine to the description in McKeeman as well, if not necessarily to McKeeman's actual usage.<br></p>
        <blockquote><font size="-1"><b>Aside:</b>&nbsp; In point of fact, </font><font size="-1"><font color="#663300"><code>COREWORD</code></font>
 is not used in any software written in standard XPL that's available to
 me, so I cannot determine empirically which of these choices (if 
either) is correct.&nbsp; If it is somehow discovered later that 
McKeeman's <b>XCOM</b> really does need to behave in the manner Intermetrics claimed that it did, then <b>XCOM-I</b>'s <font color="#663300"><code>--xpl</code></font>
 command-line switch will be extended to select between the two 
behaviors.&nbsp; But I don't intend to waste any effort implementing 
that until/unless I have enough evidence to justify it.&nbsp; For now, 
it's a moot point.</font><br>
        </blockquote>

      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>DATE<br>
          </code></font></td>
      <td valign="middle">A function with the numeric value of the date, coded as<br>
        <blockquote>(day of year) + 1000 * (year - 1900)<br>
        </blockquote>
      </td>
      <td valign="middle">McKeeman doesn't inform us of anything so mundane as the time zone to which this relates.&nbsp; <b>XCOM-I</b> uses UTC.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>DATE_OF_GENERATION<br>
          </code></font></td>
      <td valign="middle">A word variable initialized with the value of <font color="#663300"><code>DATE</code></font> during compilation of the program being run.<br>
      </td>
      <td valign="middle">Unfortunately, there's a slight bug in <b>XCOM-I</b> which I haven't found any satisfying way to resolve, which is that <font color="#663300"><code>DATE_OF_GENERATION</code></font> uses the local time-zone of the C compilation rather than UTC as <font color="#663300"><code>DATE</code></font> (see above) does.
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>DESCRIPTOR(NE)<br>
          </code></font></td>
      <td valign="middle">The description of the <font color="#663300"><code>NE</code></font><font size="-1"><sup>th</sup></font> string as a numeric value.<br>
      </td>
      <td valign="middle">I believe that this cryptic description is 
referring to the fact that in the way memory is allocated for the 
variables declared by <b>XCOM</b>, the 32-bit string descriptors for all <font color="#663300"><code>CHARACTER</code></font> and <font color="#663300"><code>BIT(n)</code></font> (<font color="#663300"><code>n</code></font>&gt;32) variables appear consecutively in memory.&nbsp; By symbolically labeling the very first of those descriptors as <font color="#663300"><code>DESCRIPTOR</code></font>, and treating <font color="#663300"><code>DESCRIPTOR</code></font> as of the <font color="#663300"><code>FIXED</code></font> datatype, <font color="#663300"><code>DESCRIPTOR</code></font>
 becomes an easily-accessible array of all the string descriptors.&nbsp;
 This is useful, for example, for memory-management procedures like <font color="#663300"><code>COMPACTIFY</code></font>.&nbsp; The number of elements of the array is given by the built-in <font color="#663300"><code>NDESCRIPT</code></font> (see below).<br>
</td></tr><tr><td valign="middle" align="center"><font color="#663300"><code>EXIT</code><code><br>
          </code></font></td>
      <td valign="middle">A procedure<br>
        <blockquote><font color="#663300"><code>CALL EXIT;</code></font><br>
        </blockquote>
which causes an abnormal exit form XPL execution. <br>
      </td>
      <td valign="middle">In fact, <b>XCOM-I</b> models this a C-language <font color="#663300"><code>exit(1)</code></font>.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>FILE(NE<sub>1</sub>,NE<sub>2</sub>)</code><code><br>
          </code></font></td>
      <td valign="middle">An array-valued pseudovariable for manipulation of random-access bulk storage.&nbsp; Examples of its use are<br>
        <blockquote><font color="#663300"><code>DECLARE BUFF(3600) BIT(8);</code><code><br>
            </code><code>BUFF = FILE(I, J);</code><code><br>
            </code><code>FILE(I-1, J) = BUFF;</code></font><br>
        </blockquote>
One record is transferred into or out of the buffer array by the 
assignments shown above.&nbsp; FILE cannot appear on both sides of the 
same assignment.&nbsp; <br>
      </td>
      <td valign="middle"><a name="file"></a>I've actually truncated McKeeman's 
description of <font color="#663300"><code>FILE</code></font>, because it is so long and so much of it is specific to IBM 
System/360, while being quite irrelevant to us.&nbsp; The key facts are 
these:<br>
        <ul>
          <li>"Random access files" may be attached to the running program.&nbsp; <br></li>
          <li>Once attached, they are identified by a "device number" that ranges from 1 to 9.&nbsp; <br></li>
          <li>Each attached random-access file may be for input-only, output-only, or both.&nbsp; <br></li>
          <li>Each of the attached files consists of records of a fixed size.</li>
          <li>Different files may have different record sizes.</li>
          <li>These random-access files, and the associated <font color="#663300"><code>FILE</code></font> operations, are <i>completely distinct</i> from the "sequential files" (numbered 0 through 9) accessed via the <font color="#663300"><code>INPUT</code></font> and <font color="#663300"><code>OUTPUT</code></font> functions (see below).</li>
<li>Record sizes <i>typically</i> do not change during program execution.  (But see the continued comments below.)</li>
        </ul>
By default, no random-access files are attached to programs.&nbsp; 
Originally (back in 1970), they were attached at runtime via Job Control
 Language (JCL) <font color="#663300"><code>DD</code></font> 
cards.&nbsp; But with programs compiled via XCOM-I, files are attached 
at program startup by using the program's command-line switches.&nbsp; 
The relevant switch is <font color="#663300"><code>--raf</code></font>, and multiple instances can be used on the same command line.<br>
        <blockquote><font color="#663300"><code>--raf=<i>I,R,N,F</i></code></font><br>
        </blockquote>
The parameters of the <font color="#663300"><code>--raf</code></font> switch are:<br>
        <ul>
          <li><font color="#663300"><code>I</code></font> is either a 
literal I (for "input"), a literal O (for "output"), or a literal B (for
 "both input and output").  Note that for O, an empty file will always 
be created by the program; for B, if there's an existing file of the 
specified name, then it will be used, but an empty file will be created 
otherwise.</li>
          <li><font color="#663300"><code>R</code></font> is the record 
size associated with the file.  3600 and 7200 are typical values, but 
not the only ones in use.  They must match the expectations of the 
program's XPL code for using the data.</li>
          <li><font color="#663300"><code>N</code></font> is the device number, from 1 through 9, to which the file should be attached.</li>
          <li><font color="#663300"><code>F</code></font> is the relative or absolute path to the file.</li>
        </ul>
        
<p>In spite of what I said above, the XPL/I documentation (IR-182-1, p. 
13-5) does describe one way to change the record size of a random-access
 file once the program has begun operation, and that is via a call to <font color="#663300"><code>MONITOR(4,R,N)</code></font> (see below), where <font color="#663300"><code>R</code></font> and <font color="#663300"><code>N</code></font> have the same meanings as for <font color="#663300"><code>--raf</code></font>.  It also tells us that such a call must precede the first use of <font color="#663300"><code>FILE(N)</code></font>.  <b>XCOM-I</b>
 relaxes this restriction, though it seems that the original restriction
 should be treated as very good advice to follow.  Note, by the way, 
that the call to <font color="#663300"><code>MONITOR(4,R,N)</code></font>
 has no way to distinguish between input files and output files, so its 
record-size manipulation is applied simultaneously to input file <font color="#663300"><code>N</code></font> and output file <font color="#663300"><code>N</code></font>, if they differ.<br></p>

      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>FREEBASE</code><code><br>
          </code></font></td>
      <td valign="middle">A word variable containing the absolute address of the top of constant strings and thus the bottom of the repackable area.<br>
      </td>
      <td valign="middle">In <b>XCOM-I</b>, this is implemented as a function rather than a variable, and is not directly modifiable by user code.&nbsp; <br>
        <br>
What the description from the original documentation is trying to say is that most kinds of variables — such as <font color="#663300"><code>FIXED</code></font> or <font color="#663300"><code>BIT(1)</code></font> types, or descriptors for <font color="#663300"><code>CHARACTER</code></font> or long <font color="#663300"><code>BIT</code></font>-string types, or arrays thereof, or pointers to <font color="#663300"><code>BASED</code></font>
 variables — are stored in memory at low addresses determined at compile
 time, and remain unchanged in address thereafter.&nbsp; In contrast, 
data for <font color="#663300"><code>CHARACTER</code></font> variables can grow or shrink or move at runtime.&nbsp; <font color="#663300"><code>FREEBASE </code></font>is the boundary between those regions of memory.<br>
        <br>
In <b>XCOM-I</b>, data allocated at runtime via the <font color="#663300"><code>MONITOR(6,...)</code></font> or <font color="#663300"><code>MONITOR(19,...)</code></font> function (see below), sometimes for storing data of for <font color="#663300"><code>BASED</code></font> variables,  also appears above the <font color="#663300"><code>FREEBASE</code></font> boundary.<font color="#663300"><code></code></font></td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>FREELIMIT</code><code><br>
          </code></font></td>
      <td valign="middle">A word variable containing the absolute address of the last usable byte in the string-data area. <br>
      </td>
      <td valign="middle">I believe that the description lies, and that <font color="#663300"><code>FREELIMIT</code></font> is the first unusable byte beyond the string-data area, rather than the last usable byte in it.<br>
<br>
In XPL, all memory beyond <font color="#663300"><code>FREELIMIT</code></font> is unused by the program.&nbsp; In XPL/I, the data for <font color="#663300"><code>BASED</code></font> variables is stored at <font color="#663300"><code>FREELIMIT</code></font> and above.&nbsp; However, the memory-management technique for is to push <font color="#663300"><code>FREELIMIT</code></font> <i>downward</i> in order to make room for <font color="#663300"><code>BASED</code></font> variables.&nbsp; So for either XPL or XPL/I, the <i>initial</i> value of <font color="#663300"><code>FREELIMIT</code></font> is the highest memory location used by the program.&nbsp; XCOM-I sets the initial value of <font color="#663300"><code>FREELIMIT</code></font> at <font color="#663300"><code>"FFFC00"</code></font> (i.e., 1024 bytes below the top of physical memory), in order to leave a small amount of space for <font color="#663300"><code>COMPACTIFY</code></font> to use as scratch memory.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>FREEPOINT</code><code><br>
          </code></font></td>
      <td valign="middle">A word variable containing the absolute address of the next free byte in the string-data area.&nbsp; When <font color="#663300"><code>FREEPOINT</code></font> passes <font color="#663300"><code>FREELIMIT</code></font>, <font color="#663300"><code>COMPACTIFY</code></font> must be called.<br>
      </td>
      <td valign="middle">In other words, at any given time, only the memory region between <font color="#663300"><code>FREEPOINT</code></font> and <font color="#663300"><code>FREELIMIT</code></font> is available for dynamically-allocating new free memory for <font color="#663300"><code>BASED</code></font> variables or <font color="#663300"><code>CHARACTER</code></font> variables.&nbsp; as the program continues to execute, dynamic memory allocation and subsequent memory-freeing may cause <font color="#663300"><code>FREEPOINT</code></font> to steadily creep upward, and the area from <font color="#663300"><code>FREEBASE</code></font> to <font color="#663300"><code>FREEPOINT</code></font> to become increasingly fully of unusable holes.&nbsp; Eventually, <font color="#663300"><code>COMPACTIFY</code></font> will be <i>automatically</i> called, repacking the data to eliminate the holes, and moving <font color="#663300"><code>FREEPOINT</code></font> downward in memory once again.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>INLINE(NE<sub>1</sub>,...)<br>
          </code></font></td>
      <td valign="middle">Inserts arbitrary IBM System/360 machine code directly into the instruction stream.<br>
      </td>
      <td valign="middle">I've replaced McKeeman's lengthy description 
with a short synopsis, because the applicability of the original 
functionality has change drastically in the 55 years (as of this 
writing) since <i>A Compiler Generator</i> was written.<br>
        <br>
        <b>XCOM-I</b> does <i>not</i> support the originally-described functionality as-is.&nbsp; Instead, you can use <br>
        <blockquote><font color="#663300"><code>CALL INLINE(DE);</code></font><br>
        </blockquote>
to perform the conceptually-similar task of inserting an arbitrary 
string of C-language code directly into the instruction stream.&nbsp; If
 the string contains newline characters (<font color="#663300"><code>'\n'</code></font>), then a single <font color="#663300"><code>INLINE</code></font> can insert multiple lines of C code.&nbsp; (But recall, an XPL string can be no longer than 256 characters.)<br>
        <br>
More-importantly, in <b>XCOM-I</b>, there is also a different mechanism for using legacy <font color="#663300"><code>CALL INLINE</code></font> statements to patch lengthy C-language replacements for the original BAL code represented by the <font color="#663300"><code>INLINE</code></font>s into the instruction stream, while leaving the original XPL/I source code unchanged.&nbsp; <a moz-do-not-send="true" href="#hooks">This important but far from automatic mechanism is the topic of a later section</a>.<br>
        <br>
Thankfully, no available legacy standard XPL program contains any <font color="#663300"><code>CALL INLINE</code></font> statements, so the difficulties presented by them are limited to XPL/I code such as <b>HAL/S-FC</b>.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>INPUT(NE)</code><code><br>
          </code></font></td>
      <td valign="middle">A function with descriptor value specifying the next record on input file <font color="#663300"><code>NE</code></font>.<br>
      </td>
      <td valign="middle">I've truncated McKeeman's rather roundabout description, because I don't find it very informative as-is to more-modern readers.<br>
        <br>
What McKeeman is trying to say is that any given program can have several files attached to it for so-called <i>sequential</i>
 input.&nbsp; You can think of these files as consisting of lines of 
text, and you can read them, one text-line at a time, by using the <font color="#663300"><code>INPUT</code></font> built-in function.&nbsp; For the original McKeeman <b>XCOM</b> (or the Intermetrics version of <b>XCOM</b>), the text in the sequential files would have been encoded in EBCDIC, but for use with <b>XCOM-I</b> they are encoded in ASCII.<br>
        <br>
Because XPL comes from the era and computing environment it did, it 
expects input to be supplied on computer punch cards.&nbsp; As such, it 
expects lines of input to actually be 80 columns wide, even if they need
 to be padded by spaces to do so.&nbsp; Not all XPL programs have 
problems with lines of other lengths have a problem with lines of a 
different length, but some do.&nbsp; Notably, the original <b>XCOM</b> is one of the programs that behaves incorrectly unless it gets its way.&nbsp; Because of that, <b>XCOM-I</b>'s built-in <font color="#663300"><code>INPUT</code></font> function transparently truncates lines to 80 columns or pads them 80 columns as necessary.<br>
        <br>
        <br>
There are up to 9 input files attached to the program, numbered, 0 through 9 — yes, I <i>know</i> that's 10 files, but just keep reading — and you access them via those "device numbers".&nbsp; For example,<br>
        <blockquote><font color="#663300"><code>DECLARE CHARACTER C;</code><code><br>
            </code><code>C = INPUT(5);</code></font><br>
        </blockquote>
reads a single line from sequential file number 5 into the variable <font color="#663300"><code>C</code></font>.<br>
        <blockquote><font size="-1"><b>Important:</b> These "sequential files" and the <font color="#663300"><code>INPUT</code></font> mechanism are completely separate from the "random-access files" described in <font color="#663300"><code>FILE</code></font>'s notes earlier!</font><br>
        </blockquote>
By default, there is a single sequential file attached to the program, though it is attached to <i>both</i> device number 0 and device number 1.&nbsp; The default attached file is <font color="#663300"><code>stdin</code></font>, and thus any text piped into the program via a redirector (<font color="#663300"><code>&lt;</code></font>) on the program's command line will be available on both <font color="#663300"><code>INPUT(0)</code></font> and <font color="#663300"><code>INPUT(1)</code></font>.<br>
        <blockquote><font size="-1"><b>Aside:</b>&nbsp; In case you're wondering, I don't think that the reason two separate devices are associated with <font color="#663300"><code>stdin</code></font> is very deep or interesting.&nbsp; I imagine it's just kind of symmetric to the fact that <font color="#663300"><code>OUTPUT(0)</code></font> and <font color="#663300"><code>OUTPUT(1)</code></font> (see below) are both attached by default to <font color="#663300"><code>stdout</code></font>.&nbsp; In situations like this I'm tempted to quote Emerson</font> <font size="-1">— "a foolish consistency is the hobgoblin of little minds" — but I suspect the decision was pragmatic rather than foolish.</font><br>
        </blockquote>
There's no explanation or obvious provision in the documentation for what happens when an end-of-file is reached, and <b>XCOM-I</b>
 makes no particular provision for it either.&nbsp; I suppose it must 
depend on the particular program.&nbsp; For example, some XPL programs 
assume that a blank line terminates a file.&nbsp; Other programs may 
look for special patterns, such as the string "EOF".&nbsp; <b>XCOM-I</b> returns an empty string for reads past the end of the file.<br>
        <br>
Additional input files can be attached via the program's command-line switch <font color="#663300"><code>--ddi</code></font>:<br>
        <blockquote><font color="#663300"><code>--ddi=<i>N,F</i></code></font><br>
        </blockquote>
Here, <font color="#663300"><code><i>F</i></code></font> is the pathname to the file, and <font color="#663300"><i><code>N</code></i></font>
 is the device number to which it should be attached.&nbsp; By the way, 
if you want to debug your program once it has been translated by <b>XCOM-I</b>
 to C and then the C has been compiled to an exectuable, I've sometimes 
found piping input into the program via a command-line redirector (<font color="#663300"><code>&lt;</code></font>)
 to be somewhat problematic.&nbsp; It's handy in those situations to 
override the default attachment of stdin to device 0 by using <font color="#663300"><code>--ddi=0,<i>F</i></code></font> instead of piping.&nbsp; <br>
        <br>
There is no way to change the attachments once the program is running, although there are <font color="#663300"><code>MONITOR</code></font> calls (see below) which can close attached files at runtime.<br>
        <br>
In XPL/I, there's an additional alternative, in which <i>Partioned Data Set</i> (PDS) files can be attached for use by <font color="#663300"><code>INPUT</code></font>
 instead of sequential files. A PDS is partitioned into sections, each 
with its own 8-character identifying name (right-padded with blanks if 
necessary).&nbsp; An attempted read past the end of a partition returns 
an empty string.<br>
        <br>
Only one partition of the PDS is available via <font color="#663300"><code>INPUT</code></font> at any given time, but <br>
        <blockquote><font color="#663300"><code><i>F</i> = MONITOR(2, <i>N</i>, <i>NAME</i>);</code></font><br>
        </blockquote>
(see below) can be used at any time to switch device <font color="#663300"><code><i>N</i></code></font> to the partition whose name is contained in the string called <font color="#663300"><code><i>NAME</i></code></font>.&nbsp; The value returned, <font color="#663300"><code><i>F</i></code></font>, is 0 if the switch was successful, or 1 if there was no such partition.<br>
        <br>
A PDS is thus similar to a <i>folder</i> of sequential files, with the partition names corresponding to filenames within the folder.&nbsp; <br>
        <br>
By default, no there is no PDS attached to programs.&nbsp; However, a 
PDS can be attached for input via the program's command-line switch <font color="#663300"><code>--pdsi</code></font>:<br>
        <blockquote><font color="#663300"><code>--pdsi=<i>N</i>,<i>F</i></code></font><br>
        </blockquote>
Because of PDS similarity to folders, that's how they're implemented in <b>XCOM-I</b>. So <font color="#663300"><code><i>F</i></code></font> should be the pathname of a folder, and the partitions should be ASCII text files within the folder.&nbsp; <font color="#663300"><code><i>N</i></code></font>,
 of course, is the device number on which the attachment is to be 
made.&nbsp; However, no specific partition is selected for reading until
 the necessary <font color="#663300"><code>MONITOR(2, <i>N</i>, <i>NAME</i>)</code></font> call has been made.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>INPUT</code><code><br>
          </code></font></td>
      <td valign="middle">Same as <font color="#663300"><code>INPUT(0)</code></font><br>
      </td>
      <td valign="middle"><br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>INTERRUPT_TRAP</code><code><br>
          </code></font></td>
      <td valign="middle">Not supported in <b>XCOM</b>.<br>
      </td>
      <td valign="middle">Not supported in <b>XCOM-I</b>.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>LENGTH(DE)</code><code><br>
          </code></font></td>
      <td valign="middle">A function with the numeric value equal to the number of characters in the string denoted by the parameter.<br>
      </td>
      <td valign="middle"><br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>LINE_COUNT</code><code><br>
          </code></font></td>
      <td valign="middle">This function returns the number of lines which have been printed on the SYSPRINT file since the last page eject.<br>
      </td>
      <td valign="middle">(XPL/I only.)&nbsp; "SYSPRINT" refers to <font color="#663300"><code>OUTPUT(0)</code></font> and <font color="#663300"><code>OUTPUT(1)</code></font> (see below).<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>LINK</code><code><br>
          </code></font></td>
      <td valign="middle">This procedure performs the functions necessary to exit the current program phase and pass control to the next phase on the <font color="#663300"><code>PROGRAM DD</code></font> sequence, preserving <font color="#663300"><code>COMMON</code></font> data and any other dynamically allocated space which has not been deallocated.<br>
      </td>
      <td valign="middle">(XPL/I only.)&nbsp; This refers to the notion 
that a sequence of XPL/I programs is being run via Job Control Language 
(JCL), with each program passing data to the next program in 
sequence.&nbsp; However, this <font color="#663300"><code>LINK</code></font> built-in is specific to the original computing environment, and performs no function in <b>XCOM-I</b>, which has a different mechanism sharing data between program passes.&nbsp; <a moz-do-not-send="true" href="#common">Refer to the extensive discussion concerning <font color="#663300"><code>COMMON</code></font> memory</a>.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>MONITOR(NE<sub>1</sub>,...)</code><code><br>
          </code></font></td>
      <td valign="middle">Calls the "submonitor".<br>
      </td>
      <td valign="middle">The "submonitor" is a separate program from 
whatever XPL or XPL/I program is being compiled and run, providing some 
kine of system-specific functionality.&nbsp; In so far as McKeeman is 
concerned, the submonitor's functionality and even it calling sequence 
was unknowable, and thus the McKeeman <b>XCOM</b> system simply discarded all calls to the submonitor.<br>
        <br>
Not so with XPL/I: There is an extensive set of functions provided by the submonitor, and the XPL/I program <b>HAL/S-FC</b> uses them extensively as well, so <b>XCOM-I</b>
 needs to support them.&nbsp; Most (I hope!) but not all submonitor 
functions are known from their descriptions in section 13.3 of 
IR-182-1.&nbsp; Besides which, <b>HAL/S-FC</b> source code contains the source code for <font color="#663300"><code>MONITOR</code></font> (written in IBM 360 Basic Assembly Language), from which additional information can be obtained.<br>
        <br>
Because of the complexity of <font color="#663300"><code>MONITOR</code></font>, <a moz-do-not-send="true" href="#monitor">an entire separate section is devoted to explaining it</a>.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>MONITOR_LINK</code><code><br>
          </code></font></td>
      <td valign="middle">A fixed array which can be used for transmission of information between a program and the submonitor.<br>
      </td>
      <td valign="middle">(See Table 8.4.6 in McKeeman.)&nbsp; I'm not presently aware of any need to implement this in <b>XCOM-I</b>.&nbsp; However, there are <font color="#663300"><code>MONITOR</code></font> functions (see above) whose operations remain a mystery, so there's a possibility that that could change.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>NDESCRIPT(NE)</code><code><br>
          </code></font></td>
      <td valign="middle">A word variable containing the upper bound in the array <font color="#663300"><code>DESCRIPTOR</code></font> (see above) of the descriptions.<br>
      </td>
      <td valign="middle">See <font color="#663300"><code>DESCRIPTOR</code></font> above.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>OUTPUT(NE)</code><code><br>
          </code></font></td>
      <td valign="middle">This is the analog of <font color="#663300"><code>INPUT</code></font> (see above) but for outputting textual data rather than inputting it.<br>
      </td>
      <td valign="middle">Most of the comments concerning <font color="#663300"><code>INPUT</code></font> (see above) are directly applicable to <font color="#663300"><code>OUTPUT</code></font>, or else are analogous in a very obvious way, so I'll try to confine my remarks to the clear differences between the two.<br>
        <br>
The most common use of <font color="#663300"><code>OUTPUT</code></font> is to "print" to the "SYSPRINT" device.&nbsp; Unlike the original <b>XCOM</b> computing environment, in which SYSPRINT was an actual printer, in <b>XCOM-I</b> SYSPRINT by default refers to <font color="#663300"><code>stdout</code></font>.&nbsp; And by default, <font color="#663300"><code>stdout</code></font> is attached to both <font color="#663300"><code>OUTPUT(0)</code></font> and <font color="#663300"><code>OUTPUT(1)</code></font>. But there are differences between the two!&nbsp; Use of <font color="#663300"><code>OUTPUT(0)</code></font> is simpler, and therefore more common, but <font color="#663300"><code>OUTPUT(1)</code></font> is more flexible.&nbsp; Let's start with <font color="#663300"><code>OUTPUT(0)</code></font>.<br>
        <br>
Output statements via <font color="#663300"><code>OUTPUT(0)</code></font> might look something like this:<br>
        <blockquote><font color="#663300"><code>OUTPUT(0) = 'Hello, world!';</code><code><br>
            </code><code>OUTPUT(0) = 'Hello' || ',' || ' ' || 'world' || '!';</code><code><br>
            </code><code>OUTPUT(0) = 'This is OUTPUT statement number ' || 3;</code><code><br>
            </code><code>OUTPUT(0) = 25;</code></font><br>
        </blockquote>
Thus we can print any character strings or numbers we like, and can concatenate them using the string-concatenation operator (<font color="#663300"><code>||</code></font>), with <b>XCOM-I</b> doing the work of automatically converting numbers to strings where necessary.<br>
        <br>
Each use of <font color="#663300"><code>OUTPUT(0)</code></font> results in another physical line being printed.&nbsp; When printing messages with <font color="#663300"><code>OUTPUT</code></font>,
 since it is expected that the lines are being output to a physical 
printer, the system keeps track of the number of lines being printed, 
and automatically inserts page breaks in the output once a page has been
 filled up.&nbsp; At the tops of pages, a page number and optional 
headings and subheadings are also printed.&nbsp; The headings and 
subheadings, though, are simply whatever has been previously set up, and
 you can't change them or otherwise influence them using <font color="#663300"><code>OUTPUT(0)</code></font>.<br>
        <br>
With <font color="#663300"><code>OUTPUT(1)</code></font>, on the other 
hand, there's quite a bit of additional functionality.&nbsp; For 
example, it isn't necessarily true that each use of <font color="#663300"><code>OUTPUT(1)</code></font> prints another line.&nbsp; The <i>first</i> character of each <font color="#663300"><code>OUTPUT(1)</code></font> isn't directly printed, but instead is a "carriage-control character" (or "ANSI control character"), as follows:<br>
        <ul>
          <li>'<font color="#663300"><code> </code></font>' — Single-space the line and print.  This is the same behavior as <font color="#663300"><code>OUTPUT(0)</code></font>: i.e., any line you print to <font color="#663300"><code>OUTPUT(0)</code></font>, you could instead prefix it with a space character and send it to <font color="#663300"><code>OUTPUT(1)</code></font> instead.</li>
          <li>'<font color="#663300"><code>0</code></font>' — Double-space the line and print.</li>
          <li>'<font color="#663300"><code>-</code></font>' — Triple-space the line and print.</li>
          <li>'<font color="#663300"><code>+</code></font>' — Do <i>not</i>
 space the line at all, but print.  In other words, prints but doesn't 
advance to the next line.  It behaves like an ASCII carriage-return 
character (<font color="#663300"><code>'\r'</code></font>).  For a physical printer back in the day, this would allow you to overprint the line upon the next <font color="#663300"><code>OUTPUT</code></font>.  Unfortunately, for <font color="#663300"><code>stdout</code></font> on most computers, we can't emulate such overprinting in any meaningful way.  Thus in <b>XCOM-I</b>, the behavior is indistinguishable from the "single space and print" behavior.</li>
          <li>'<font color="#663300"><code>1</code></font>' — Form feed.
  I.e., advance to the top of the next page, regardless of how many 
left-over lines remain on the current page.  In <b>XCOM-I</b>, this is accomplished by embedding the ASCII form-feed character (<font color="#663300"><code>'\l'</code></font>) in the output.</li>
          <li>'<font color="#663300"><code>H</code></font>' — Heading 
line.  This doesn't print anything, but takes the remainder of the line 
and sets it as the heading for subsequent pages.</li>
          <li>'<font color="#663300"><code>2</code></font>' — Subheading
 line.  This doesn't print anything, but takes the remainder of the line
 and sets it as the subheading for subsequent pages.</li>
        </ul>
If you experiment with <font color="#663300"><code>OUTPUT(1)</code></font>, and even to a certain extent with <font color="#663300"><code>OUTPUT(0)</code></font>, you may become very confused, because various things won't work as you expect.&nbsp; Or at least, <i>I</i> was very confused at first.&nbsp; To get past this confusion, you need to grasp the following<br>
        <blockquote><b>Very important point</b>:&nbsp; For the computer 
systems most people are familiar with today, when we print a line of 
text, we expect that line of text to end with an implicit advance to the
 next line; i.e., with a "newline" character, often signified in 
programming languages by <font color="#663300"><code>'\n'</code></font>.&nbsp; Whereas in System/360 (and therefore in XPL or XPL/I), the implicit newline occurs <i>prior</i> to the text being printed by the <font color="#663300"><code>OUTPUT</code></font> command.&nbsp; I.e., today we typically ask ourselves "what happens at the <i>end</i> of the line"", whereas for XPL you need to ask "what happens at the <i>beginning</i> of the line?".<br>
        </blockquote>
Similarly to <font color="#663300"><code>INPUT</code></font>, you can attach additional sequential output files (<font color="#663300"><code><i>F</i></code></font>) on device numbers (<font color="#663300"><code><i>N</i></code></font>),<br>

        <blockquote><font color="#663300"><code>--ddo=<i>N,F</i></code></font><br>
        </blockquote>

Or for Partitioned Data Sets,<br>
        <blockquote><font color="#663300"><code>--pdso=<i>N</i>,<i>F</i></code></font><br>
        </blockquote>
For selecting partitions of a PDS, you don't use the same <font color="#663300"><code>MONITOR</code></font> call as for <font color="#663300"><code>INPUT</code></font>, but instead use: <br>

        <blockquote><font color="#663300"><code><i>F</i> = MONITOR(1, <i>N</i>, <i>NAME</i>);</code></font><br>
        </blockquote>
        <font color="#663300"><code>OUTPUT</code></font> commands 
targets for a PDS don't immediately write data to the physical 
PDS.&nbsp; Rather, the data being output is buffered in memory until the
 <font color="#663300"><code>MONITOR(1, <i>N</i>, <i>NAME</i>)</code></font> call occurs, and the data is then written out to the selected partition in its entirety.&nbsp; The return value (<font color="#663300"><code><i>F</i></code></font>)
 is 0 if the partition is new (i.e., if it didn't previously exist in 
the PDS), while it is 1 if the partion previously existed but has now 
been overwritten with entirely new contents.</td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>OUTPUT</code><code><br>
          </code></font></td>
      <td valign="middle">The same as <font color="#663300"><code>OUTPUT(0)</code></font>.<br>
      </td>
      <td valign="middle"><br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>PARM_FIELD</code><code><br>
          </code></font></td>
      <td valign="middle">This function returns a character string which contains the entire parameter specification coded on the <font color="#663300"><code>PARM=</code></font> option on the <font color="#663300"><code>EXEC</code></font> card.&nbsp; If no <font color="#663300"><code>PARM</code></font> is specified, a null string will be returned.<br>
      </td>
      <td valign="middle">(XPL/I only.)&nbsp; A program of any 
complexity generally has a number of options selectable at 
runtime.&nbsp; For XPL/I programs like <b>HAL/S-FC</b>, the mechanism for selecting such options was originally a Job Control Language (JCL) card such as:<br>
        <blockquote><font color="#663300"><code>PARM='SYTSIZE=1800,REFSIZE=20000,LISTING2,$I,$V,$U,$W'</code></font><br>
        </blockquote>
Thus, <font color="#663300"><code>PARM_FIELD</code><code> </code></font>would have had the value <font color="#663300"><code>'SYTSIZE=1800,REFSIZE=20000,LISTING2,$I,$V,$U,$W'</code></font> in such a case.<br>
        <br>
In <b>XCOM-I</b>, <font color="#663300"><code>PARM_FIELD</code></font> 
is implemented as a function rather than a variable, but nevertheless 
returns data of the kind described.&nbsp; Of course, there is no JCL 
supplying such parameters, but the compiled program nevertheless has a 
command-line option that does the same job:<br>
        <blockquote><font color="#663300"><code>--parm='SYTSIZE=1800,REFSIZE=20000,LISTING2,$I,$V,$U,$W'<br>
</code></font></blockquote>
        <blockquote><b><font color="#663300"><code></code></font></b><font size="-1"><b>Aside:</b>
 Depending on your operating system, some trickery may be involved in 
correctly forming such a command-line option.&nbsp; In Linux or (I 
suppose) Mac OS, the command shell expects the dollar sign (<font color="#663300"><code>$</code></font>)
 to indicate that the value of an environment variable is desired.&nbsp;
 In other words, if the string in the command-line option shown above 
had no quotes, then (for example) <font color="#663300"><code>$I</code></font> would be replaced by the value of the environment-variable <font color="#663300"><code>I</code></font>
 ... probably a blank!&nbsp; And the same thing would happen if the 
option were enclosed in double-quotes.&nbsp; But by using single-quotes,
 we defeat that substitution, and <font color="#663300"><code>$I</code></font> is reported in </font><font size="-1"><font color="#663300"><code>PARM_FIELD</code></font> literally as <font color="#663300"><code>$I</code></font>.&nbsp; Alternate tricks to defeating substitution could include using the backslash (<font color="#663300"><code>'\'</code></font>) escape character in front of all dollar signs (<font color="#663300"><code>$</code></font>).&nbsp; <br>
            <br>
            <b>Aside:</b> It has been decades since I used Windows in 
any serious way, so I don't really know whether there's any similar 
problem with it.&nbsp; Probably not.</font><br>
        </blockquote>
        <font color="#663300"><code></code></font></td>
    </tr>
    <tr>
  <td valign="middle" align="center"><font color="#663300"><code>RECORD_WIDTH(V)</code></font><br>
  </td>
  <td valign="top"><br>
  </td>
  <td valign="middle">(XPL/I only.)&nbsp; IR-182-1 doesn't mention it, but it appears to me that <font color="#663300"><code>RECORD_WIDTH</code></font> is a new built-in in XPL/I which when given the symbolic name of a <font color="#663300"><code>BASED</code></font> variable returns the variable's record size (in bytes).&nbsp; In <b>HAL/S-FC</b>'s XPL/I source code (the only available example of use of <font color="#663300"><code>RECORD_WIDTH</code></font>), I find it used only for a couple of <font color="#663300"><code>BASED RECORD</code></font>
 variables, which makes sense according to the naming, but I have no way
 to tell just from those few examples what the actual applicability 
was.&nbsp; In <b>XCOM-I</b>, it will work for any <font color="#663300"><code>BASED</code></font> variable, <font color="#663300"><code>RECORD</code></font> or not.<br>
  </td>
</tr>
<tr>
      <td valign="middle" align="center"><font color="#663300"><code>SET_LINELIM(NE)</code><code><br>
          </code></font></td>
      <td valign="middle">This procedure establishes the number of lines
 which will be printed on the SYSPRINT file before an automatic page 
eject and header line will be printed.<br>
      </td>
      <td valign="middle">(XPL/I only.)&nbsp; See <font color="#663300"><code>OUTPUT(NE)</code></font>.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>SHL(NE<sub>1</sub>,NE<sub>2</sub>)</code><code><br>
          </code></font></td>
      <td valign="middle">A function with the numeric value given by shifting the value of <font color="#663300"><code>NE<sub>1</sub></code></font> left (logical shift, zeroes appear in the least significant bit position) the number of positions indicated by the value of <font color="#663300"><code>NE<sub>2</sub></code></font>.<br>
      </td>
      <td valign="middle">One point I found confusing for quite a while is that you'd suppose that logical shifts would operate on <font color="#663300"><code>BIT</code></font> variables, and particularly on long-<font color="#663300"><code>BIT</code></font> variables, for which XPL provides no conveniences at all for accessing individual bits.&nbsp; Not so!&nbsp; <font color="#663300"><code>SHL</code></font> operates only on <font color="#663300"><code>FIXED</code></font> values, and can only shift by up to 32 positions.&nbsp; <font color="#663300"><code>BIT</code></font> variables are converted to <font color="#663300"><code>FIXED</code></font> if shift operations on them are needed.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>SHR(</code></font><font color="#663300"><code><font color="#663300"><code>NE<sub>1</sub>,NE<sub>2</sub></code></font>)</code><code><br>
          </code></font></td>
      <td valign="middle">Logical shift right.&nbsp; <font color="#663300"><code>SHL</code></font> and <font color="#663300"><code>SHR</code></font> are used in conjunction with <font color="#663300"><code>&amp;</code></font>, <font color="#663300"><code>|</code></font>, and <font color="#663300"><code>¬</code></font> for masking and data packing.<br>
      </td>
      <td valign="middle">But recall that it is preferable to use <font color="#663300"><code>~</code></font> rather than <font color="#663300"><code>¬</code></font> with <b>XCOM-I</b>. </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>STRING(<i>IDENTIFIER</i>)<br>
STRING(<i>INTEGER</i>)</code><code><br>
          </code></font></td>
      <td valign="middle">This function transforms the variable <font color="#663300"><code>NE</code></font> (which should be <font color="#663300"><code>FIXED</code></font> for proper usage) into a <font color="#663300"><code>CHARACTER</code></font> descriptor.&nbsp; <font color="#663300"><code>NE</code></font> should have the form:<br>
        <br>
        <table align="center" cellspacing="2" cellpadding="2" border="1">
          <tbody>
            <tr>
              <th valign="middle" align="center">Length - 1<br>
              </th>
              <th valign="middle" align="center">&nbsp;Data Address<br>
              </th>
            </tr>
            <tr>
              <td valign="middle" align="center">8 bits<br>
              </td>
              <td valign="middle" align="center">24 bits<br>
              </td>
            </tr>
          </tbody>
        </table>
        <br>
      </td>
      <td valign="middle">(XPL/I only.) I admit that the description at 
left is confusing.&nbsp; The whole concept is confusing.&nbsp; Here's my
 take on it:&nbsp; I believe that <font color="#663300"><code>STRING</code></font> is used in one of two situations:<br>
<ul>
  <li>You have an <font color="#663300"><code><i>IDENTIFIER</i></code></font> for a <font color="#663300"><code>CHARACTER</code></font> variable, and you want the string descriptor for the string contained in that variable; or</li>
  <li>By some kind of arithmetical process, a <font color="#663300"><code><i>INTEGER</i></code></font> value has been created that you want to treat as a string descriptor.<br></li>
</ul>
These are respectively equivalent to<br>
<ul>
  <li><font color="#663300"><code>COREWORD(ADDR(IDENTIFIER))</code></font></li>
  <li><font color="#663300"><code>INTEGER</code></font></li>
</ul>
<p><b>XCOM-I</b> implements <font color="#663300"><code>STRING</code></font> using these equivalences, and there is no runtime library function as such that's called <font color="#663300"><code>STRING</code></font>.<br></p>
<p>To make things a bit more confusing, <font color="#663300"><code>STRING</code></font> is the one built-in I'm aware of that is <i>also</i>
 commonly used as a name for a variable.  If names of built-ins are 
declared as variables (or procedures), the user's declaration overrides 
the built-in for the scope of the declaration.<br></p>

      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>STRING_GT(DE<sub>1</sub>,DE<sub>2</sub>)</code><code><br>
          </code></font></td>
      <td valign="middle">This function returns a <font color="#663300"><code>TRUE</code></font> value if the contents of string <font color="#663300"><code>DE<sub>1</sub></code></font> is greater than the contents of string <font color="#663300"><code>DE<sub>2</sub></code></font>, based on the collating sequence of the characters, irrespective of the lengths of <font color="#663300"><code>DE<sub>1</sub></code></font> and <font color="#663300"><code>DE<sub>2</sub></code></font>. Otherwise, the value is <font color="#663300"><code>FALSE</code></font>. This is functionally equivalent to padding the shorter of <font color="#663300"><code>DE<sub>1</sub></code></font> or <font color="#663300"><code>DE<sub>2</sub></code></font> with blanks and then comparing the strings.<br>
      </td>
      <td valign="middle">(XPL/I only.)&nbsp; If this seems confusing, it may be helpful to recall that when the XPL relational operators <font color="#663300"><code>&lt;</code></font>, <font color="#663300"><code>&gt;</code></font>, <font color="#663300"><code>&lt;=</code></font>, and <font color="#663300"><code>&gt;=</code></font> compare two <font color="#663300"><code>CHARACTER</code></font>
 values, they look first at the lengths of the values, and only if the 
lengths are equal do they compare the actual character data.&nbsp; For 
example,<br>
        <blockquote><font color="#663300"><code>'ZZZ' &lt; 'AAAA'</code></font><br>
        </blockquote>
because <font color="#663300"><code>'ZZZ'</code></font> has only 3 characters, while <font color="#663300"><code>'AAAA'</code></font> has 4.&nbsp; Presumably <font color="#663300"><code>STRING_GT</code></font> was introduced because somebody at Intermetrics didn't think that kind of behavior was great, and thus <font color="#663300"><code>STRING_GT('ZZZ', 'AAAA')</code></font> will report instead that <font color="#663300"><code>'ZZZ'</code></font> is greater than <font color="#663300"><code>'AAAA'</code></font>.<br>
        <br>
The collating sequence in either case is EBCDIC rather than the 
more-usual ASCII.&nbsp; The primary visually-obvious consequence of this
 is that digits come after letters rather than before them.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>SUBSTR(DE,NE<sub>1</sub>,NE<sub>2</sub>)</code><code><br>
          </code></font></td>
      <td valign="middle">A function with descriptor value specifying the substring of the string specified by <font color="#663300"><code>DE</code></font>, starting at position with <font color="#663300"><code>NE<sub>1</sub></code></font> with length <font color="#663300"><code>NE<sub>2</sub></code></font>.<br>
      </td>
      <td valign="middle">I.e., it allocates and returns a new string created by taking a substring of length <font color="#663300"><code>NE<sub>2</sub></code></font>, starting at position <font color="#663300"><code>NE<sub>1</sub></code></font> in string <font color="#663300"><code>DE</code></font>.<sub><code></code></sub><sub><code></code></sub><font color="#663300"><code></code></font> </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>SUBSTR(DE,NE)</code><code><br>
          </code></font></td>
      <td valign="middle">Like the above except that all characters from <font color="#663300"><code>NE</code></font> to the end of the string are taken.<br>
      </td>
      <td valign="middle"><br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>TIME</code><code><br>
          </code></font></td>
      <td valign="middle">A function with numeric value given by the time-of-day coded as centiseconds since midnight.<br>
      </td>
      <td valign="middle">McKeeman does not specify the time zone.&nbsp; <b>XCOM-I</b> uses UTC.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>TIME_OF_GENERATION<br>
          </code></font></td>
      <td valign="middle">A word variable initialized with the value of <font color="#663300"><code>TIME</code></font> during compilation of the program.<br>
      </td>
      <td valign="middle"><font color="#663300"><code>TIME</code></font> (see above) isn't literally available during compilation.&nbsp; Moreover, <b>XCOM-I</b>
 implements this as a function rather than as a variable, which should 
be transparent to the programmer.&nbsp; <br>
<br>
Unfortunately, there's a slight bug in <b>XCOM-I</b> which I haven't found any satisfying way to resolve, which is that <font color="#663300"><code>TIME_OF_GENERATION</code></font> uses the local time-zone of the C compilation rather than UTC as <font color="#663300"><code>TIME</code></font> (see above) does.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>TRACE<br>
          </code></font></td>
      <td valign="middle">A procedure,<br>
        <blockquote><font color="#663300"><code>CALL TRACE;</code></font><br>
        </blockquote>
which causes activation of the instruction-by-instruction trace at runtime.<br>
      </td>
      <td valign="middle">This is described in quite a lot of detail in 
McKeeman's Appendix 2.&nbsp; At present, it is accepted during 
compilation but does nothing at runtime in code generated by <b>XCOM-I</b>.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>UNTRACE<br>
          </code></font></td>
      <td valign="middle">A procedure,<br>
        <blockquote><font color="#663300"><code>CALL UNTRACE;</code></font><br>
        </blockquote>
which turns off run-time trace.<br>
      </td>
      <td valign="middle">See <font color="#663300"><code>TRACE</code></font>.<br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<h3><a name="monitor"></a>The MONITOR Built-In Runtime-Library Function</h3>
<p>As mentioned before, an XPL/I program obtained various services 
outside what the XPL/I language proper or runtime library could provide,
 by instead making requests to the separate "submonitor" program.  The 
mechanism was a call of the <font color="#663300"><code>MONITOR</code></font> procedure.  For <b>XCOM-I</b>, on the other hand, there is no separate submonitor program, and we may as well think of <font color="#663300"><code>MONITOR</code></font> as being just another built-in runtime-library function.  Well, not just <i>any</i>
 runtime-library function.  A big difference is that it provides a very 
large number of functions, each one of which can require its own unique 
syntax, thus necessitating a somewhat more-flexible discussion of how to
 use it.</p>
<p>The only uniform feature among the many aspects of <font color="#663300"><code>MONITOR</code></font> usage is that each separate function it provides is identified by a number, and such a function number is passed to <font color="#663300"><code>MONITOR</code></font>
 as its first parameter.  My explanations in the table below are mostly 
pulled from Chapter 13 of IR-182-1, and then altered according to my 
understanding (or lack thereof).  Functions 24 through 32 are deduced, 
poorly, from the <b>HAL/S-FC</b> BAL source-code file for the submonitor program (which happens to be called "MONITOR").<br></p>
<p>A number of the <font color="#663300"><code>MONITOR(...)</code></font>
 functions work with what's called "IBM hexadecimal floating-point" 
format, and specifically to the 64-bit (double-precision) version of 
that format, as opposed to the 32-bit (single-precision) version of it. 
To make the discussion more concise, I'll just refer to it as "DP 
floating point".  <br></p>
<p>To be perfectly clear, there is <i>no</i> floating-point datatype in 
XPL/I, there are no floating-point literal constants, and there is no 
provision whatever to make it convenient for you (the programmer!) to 
hard-code such constants into your XPL source code, nor to interpret any
 such hexadecimal constant you find within legacy source code.  Rather, 
you must somehow obtain the hexadecimal equivalents for whatever 
floating-point constants you wish to use, and then hard-code those 
hexadecimals into your code.  For your convenience — or more accurately,
 for <i>mine</i> — I've included a little utility called ibmHex.py that 
you can use to convert back-and-forth between human-readable 
floating-point numbers and DP floating point.  Just run <font color="#663300"><code>ibmHex.py --help</code></font> for instructions.  This little utility can either be run in a stand-alone fashion, or else <font color="#663300"><code>import</code></font>ed as a Python module.  But I digress!<br></p>
<p>To understand DP floating point, imagine 8 groups of 8 bits each:<br></p>
<blockquote>
  <pre><font color="#663300">SEEEEEEE FFFFFFFF FFFFFFFF ... FFFFFFFF</font></pre>
</blockquote>
<p>where <font color="#663300"><code>S</code></font> is the sign, <font color="#663300"><code>E</code></font> is the exponent, and <font color="#663300"><code>F</code></font> is the fraction.  (SP floating point is the same, but with 3 <font color="#663300"><code>FFFFFFFF</code></font>-groups rather than 7 of them.)  The exponent is a power of 16, biased by 64, and thus represents 16<sup>-64</sup> through 16<sup>63</sup>.
  The fraction is an unsigned number, of which the leftmost bit 
represents 1/2, the next bit represents 1/4, and so on.  As a special 
case, 0 is encoded as all zeroes.<br><br>For example, the 64-bit hexadecimal pair 0x42640000 0x00000000 parses as:<br></p>
<ul>
  <li>Sign = 0 (i.e., positive)</li>
  <li>Exponent = 16<sup>0x42-0x40</sup> = 16<sup>2</sup> = 2<sup>8</sup>.</li>
  <li>Fraction = 0.0110 0100 ...</li>
</ul>
<p>or in total, 1100100 (binary), or 100 decimal.<br></p>
<p>As in the preceding section, I want to make it clear that the descriptions given here are how <i>the <b>XCOM-I</b> runtime library's <font color="#663300"><code>MONITOR</code></font> functions</i> work, and not how the original <font color="#663300"><code>MONITOR</code></font> functions as confined to an IBM 360 runtime environment worked!</p>

<table align="center" cellspacing="2" cellpadding="2" border="1">

  <tbody>
    <tr>
      <th valign="bottom" nowrap="nowrap" align="center">MONITOR Call<br>
      </th>
      <th valign="bottom">Description From Original Documentation<br>
      </th>
      <th valign="bottom">Additional Notes<br>
      </th>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">CALL MONITOR(0,<i>n</i>);<br>
    </font></code></td>
      <td valign="middle">Closes output file <i><font color="#663300"><code>n</code></font></i>.<br>
</td>
      <td valign="middle">I believe this refers to the sequential file or PDS attached for use with <font color="#663300"><code>OUTPUT(<i>n</i>)</code></font>, and <i>not</i> the random-access file (if any) attached for use with <font color="#663300"><code>FILE(<i>n</i>)</code></font>.<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>F</i>=MONITOR(1,<i>n</i>,<i>name</i>);<br>
    </font></code></td>
      <td valign="middle">Assumes that a PDS is attached to output device <font color="#663300"><code><i>n</i></code></font>.&nbsp; Physically writes any data previously buffered in memory by <font color="#663300"><code>OUTPUT(<i>n</i>)</code></font> operations into the PDS's member named <code><font color="#663300"><i>name</i></font></code>.&nbsp; The <code><font color="#663300"><i>name</i></font></code>
 parameter is a string 8 characters long, padded with blanks as 
necessary.&nbsp; Returns 0 if the member hadn't existed previously in 
the PDS, or 1 if the contents of an existing member of that name was 
replaced.<br>
</td>
      <td valign="middle"><br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>F</i>=MONITOR(2,<i>n</i>,<i>name</i>);<br>
    </font></code></td>
      <td valign="middle">Assumes that a PDS is attached to input device <font color="#663300"><code><i>n</i></code></font>.&nbsp; Sets future <font color="#663300"><code>INPUT(n)</code></font> operations to pull data from the PDS's member named <code><font color="#663300"><i>name</i></font></code>.&nbsp; The <code><font color="#663300"><i>name</i></font></code>
 parameter is a string 8 characters long, padded with blanks as 
necessary.&nbsp;  Returns 0 if the member was found, or 1 if it was not 
found.<br>
</td>
      <td valign="middle">The end-of-data for the member is detected when an input string of 0 length is encountered.<br>
  <br>
IR-182-1 asserts that devices 4 and 7 have the following abnormal <i>ad hoc</i> behavior very specific to <b>HAL/S-FC</b>.&nbsp;
 A PDS called "INCLUDE" is normally attached to input device 4, while 
either "INCLUDE" or "OUTPUT6" is normally attached to input device 
7.&nbsp; But member <code><font color="#663300"><i>name</i></font></code>&nbsp; is sought in device 4 or 7, then <code><font color="#663300"><i>name</i></font></code> is first sought in "INCLUDE" but upon failure is then sought in "OUTPUT6".<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">CALL MONITOR(3,<i>n</i>);<br>
    </font></code></td>
      <td valign="middle">Closes input file <i><font color="#663300"><code>n</code></font></i>.</td>
      <td valign="middle">I believe this refers to the sequential file or PDS attached for use with <font color="#663300"><code>INPUT(<i>n</i>)</code></font>, and <i>not</i> the random-access file (if any) attached for use with <font color="#663300"><code>FILE(<i>n</i>)</code></font>.</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">CALL MONITOR(4,<i>n</i>,<i>b</i>);<br>
    </font></code></td>
      <td valign="middle">Changes the record size of random-access file <code><font color="#663300"><i>n</i></font></code> to <code><font color="#663300"><i>b</i></font></code>.&nbsp; Must precede the first use of <font color="#663300"><code>FILE(<i>n</i>)</code></font>.<br>
</td>
      <td valign="middle"><br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">CALL MONITOR(5,ADDR(DW));<br>
    </font></code></td>
      <td valign="middle">Sets the location of the double-word work area (<font color="#663300"><code>DW</code></font>) for subsequent use by <font color="#663300"><code>MONITOR(9,...)</code></font> and <font color="#663300"><code>MONITOR(10,...)</code></font>.<br>
</td>
      <td valign="middle"><code><font color="#663300">DW</font></code> is meant to be literal here, at least for <b>HAL/S-FC</b>, and should not be replaced by anything else.<br>
  <br>
  <code><font color="#663300">DW</font></code> refers to an array of <font color="#663300"><code>FIXED</code></font>
 variables used in pairs, to hold 64-bit values. In particular, these 
pairs are often used to hold double-precision floating-point numbers in 
IBM System/360 format.&nbsp;&nbsp; <code><font color="#663300">MONITOR(9,<i>op</i>)</font></code> <font color="#663300"><font color="#000000">(see
 below) is then capable of performing various arithmetical operations on
 those numbers.&nbsp; Since XPL/I itself has no facilities for 
floating-point variables or operations on them, this workaround is the 
only available way to employ floating-point numbers in XPL/I programs.<br>
<br>
In legacy HAL/S code, I've found that at least 14 words of memory are 
needed for this work area.&nbsp; In the XCOM-I implementation, the </font></font><font color="#663300"><font color="#000000"><code><font color="#663300">MONITOR(5)</font></code> call is rejected within 14 words of the end of memory.</font></font><code><font color="#663300"><br>
    </font></code></td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>F</i>=MONITOR(6,ADDR(<i>basedVariable</i>),<i>n</i>);<br>
    </font></code></td>
      <td valign="middle">Allocates n bytes of storage in free memory, clearing that memory to 0, and assigns the pointer of the <font color="#663300"><code><i>basedVariable</i></code></font> to point to that newly-allocated space.&nbsp; Returns 0 upon success, or 1 upon failure.<br>
</td>
      <td valign="middle">Note that although the description <i>claims</i> that <code><font color="#663300">MONITOR(6)</font></code> operates on <font color="#663300"><code>BASED</code></font> variables, in point of fact <code><font color="#663300">MONITOR(6)</font></code> updates only the pointer (i.e, the first 4 of the total 28 bytes) of the <font color="#663300"><code>BASED</code></font> variable's dope vector.&nbsp; Therefore, there doesn't even need to be a full dope vector.&nbsp; Indeed, the <code><font color="#663300"><i>basedVariable</i></font></code> could in fact just be a regular old non-<font color="#663300"><code>BASED</code></font> <font color="#663300"><code>FIXED</code></font>,
 and afterward it would contain the address of the memory block that had
 been allocated.&nbsp; In fact, this is the most-common usage.<font color="#663300"><font color="#000000"> </font></font><br>
<br>
In spite of what I just said, it would be natural to suppose that even if <code><font color="#663300">MONITOR(6)</font></code> does have these alternative uses, that it still is used to allocate memory for <font color="#663300"><code>BASED</code></font>
 variables, and perhaps for string data.&nbsp; But this is not the 
case.&nbsp; As far as I can ascertain, there is a single instance in 
legacy XPL/I source code in which <font color="#663300"><font color="#000000"><code><font color="#663300">MONITOR(6)</font></code> actually operates to allocate memory for a </font></font><font color="#663300"><font color="#000000"><font color="#663300"><code>BASED</code></font> variable; that's for <font color="#663300"><code>DX</code></font>, a scratch variable used by <code><font color="#663300">COMPACTIFY</font></code>.&nbsp; (<a moz-do-not-send="true" href="#compactify">See here</a>.) </font></font><br>
<br>
Rather, my observation is that essentially all of the memory available 
to the program has been pre-allocated at program startup.&nbsp; Whether 
that preallocation is via <code><font color="#663300">MONITOR(6)</font></code> or by other means isn't clear, because we haven't the source code for Intermetrics's <b>XCOM</b>.&nbsp; The only uses for <code><font color="#663300">MONITOR(6)</font></code> and for <code><font color="#663300">MONITOR(7)</font></code> (see next entry) would appear to be these:<br>
<ul>
  <li><i>Giving back</i> pre-allocated memory that turns out to be unneeded.</li>
  <li>Temporarily allocating scratch memory for (for example) <font color="#663300"><code>COMPACTIFY</code></font>.</li>
  <li>Return previously-allocated scratch memory to the system.<br></li>
</ul>

</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>F</i>=MONITOR(7,ADDR(<i>basedVariable</i>),<i>n</i>);<br>
    </font></code></td>
      <td valign="middle">Frees the memory previously allocated via <code><font color="#663300">MONITOR(6,ADDR(<i>basedVariable</i>),<i>n</i>)</font></code>.&nbsp; However, <code><font color="#663300"><i>basedVariable</i></font></code>'s pointer is not changed, and thus will continue to point to the freed area until explicitly changed.<br>
</td>
      <td valign="middle" bgcolor="transparent">See the comments for <code><font color="#663300">MONITOR(6)</font></code>.&nbsp; <br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">CALL MONITOR(8, <i>dev</i>, <i>filenum</i>);<br>
    </font></code></td>
      <td valign="middle">Set PDS DDNAME.<br>
</td>
      <td valign="middle" bgcolor="transparent">Apparently, the use of <code><font color="#663300">MONITOR(8)</font></code>
 changed after the only documentation of it (in IR-182-1) was produced, 
leaving us to try to infer its usage from context in the HAL/S-FC and <code><font color="#663300">MONITOR</font></code>'s source code.&nbsp; The purpose seems to be to change the association of files to device numbers, <i>à la</i> <font color="#663300"><code>DD</code></font>'s in JCL, but to do so dynamically during execution rather than statically at program startup.&nbsp; <br>
<br>
The <font color="#663300"><code><i>dev</i></code></font> parameter, an integer, would appear to be the logical device number as used in an <code>XPL <font color="#663300">INPUT(<i>dev</i>)</font></code> or <font color="#663300"><code>OUTPUT(<i>dev</i>)</code></font> (or in a HAL/S <font color="#663300"><code>READ(<i>dev</i>)</code></font> or <font color="#663300"><code>WRITE(<i>dev</i>)</code></font>).<br>
<br>
The <i><font color="#663300"><code>filenum</code></font></i> parameter is trickier for me to understand, because I'm unclear how <font color="#663300"><code>DD</code></font>
 in JCL associates a dataset name with a file number, so take what I say
 with a grain of salt.&nbsp; My inference, subject to change, is that if
 you have a dataset identified with the <font color="#663300"><code>DD</code></font> name "<font color="#663300"><code>INPUT<i>n</i></code></font>" (where <font color="#663300"><code><i>n</i></code></font> is a digit), then that is <font color="#663300"><code><i>filenum</i>=<i>n</i></code></font>; whereas a dataset named "<font color="#663300"><code>OUTPUT<i>n</i></code></font>" is associated with <font color="#663300"><code><i>filenum</i>="80000000"|<i>n</i></code></font>.&nbsp; Recall that <font color="#663300"><code>"80000000"</code></font> is XPL-speak for 0x80000000.&nbsp; So the <i><font color="#663300"><code>filenum</code></font></i> is implicit in the dataset name, and the most-significant bit is used to indicate the direction of data flow.<br>
<br>
For example, <font color="#663300"><code>INPUT(4)</code></font> invocations might normally input data from <font color="#663300"><code>INPUT4</code></font>, but you could associate it instead with <font color="#663300"><code>INPUT2</code></font> via<br>
<blockquote>
  <pre><font color="#663300">CALL MONITOR(8, 4, "80000000" | 2);</font><br></pre>
</blockquote>
and then reassociate it later with <font color="#663300"><code>INPUT4</code></font> via<br>
<blockquote>
  <pre><font color="#663300">CALL MONITOR(8, 4, "80000000" | 4);<br></font></pre></blockquote>
The description "Set PDS DDNAME" I've given as the description comes 
from the associated program comment in MONITOR.bal, the source-code for 
the <font color="#663300"><code>MONITOR</code></font> procedure.&nbsp; 
It would seem to imply that it has something specifically do with 
Partitioned Data Sets (PDS).&nbsp; It's difficult to see why that would 
be so; I think it merely reflects the specific usage in HAL/S-FC, which 
indeed relates to PDS.&nbsp; The XCOM-I runtime library allows it to be 
used for and PDS <i>or</i> sequential dataset.&nbsp; It is not applicable to random-access files.<br>
<br>
Of course, there is no JCL, and consequently no DD statements, associated with an XPL or XPL/I file compiled with <b>XCOM-I</b>, nor with a HAL/S file compiled with <b>HAL/S-FC</b>.&nbsp; The description above has to be applied instead to command-line switches in a hopefully-obvious way.<br>
<blockquote>
</blockquote>


</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>F</i>=MONITOR(9,<i>op</i>);<br>
    </font></code></td>
      <td valign="middle">Performs floating point evaluation as specified by value of <code><font color="#663300"><i>op</i></font></code>.&nbsp; Operands are obtained from work area whose address was set up via a <font color="#663300"><code>MONITOR(5)</code></font>
 call. The first operand is taken from the first double word of the work
 area and the second operand from the second double word. The result is 
placed in the first double word of the work area. The return code is 0 
if the operation succeeds, or 1 if the operation fails (under or 
overflow).<br>
  <br>
The values of <code><font color="#663300"><i>op</i></font></code> are:<br>
  <table align="center" cellspacing="2" cellpadding="2" border="1">
    <tbody>
      <tr>
        <th valign="top">OP<br>
        </th>
        <th valign="top">Function<br>
        </th>
      </tr>
      <tr>
        <td valign="top" align="center">1<br>
        </td>
        <td valign="top" align="center">arg1 + arg2<br>
        </td>
      </tr>
      <tr>
        <td valign="top" align="center">2<br>
        </td>
        <td valign="top" align="center">arg1 - arg2<br>
        </td>
      </tr>
      <tr>
        <td valign="top" align="center">3<br>
        </td>
        <td valign="top" align="center">arg1 * arg2<br>
        </td>
      </tr>
      <tr>
        <td valign="top" align="center">4<br>
        </td>
        <td valign="top" align="center">arg1 / arg2<br>
        </td>
      </tr>
      <tr>
        <td valign="top" align="center">5<br>
        </td>
        <td valign="top" align="center">arg1<sup>arg2</sup><br>
        </td>
      </tr>
      <tr>
        <td valign="top" align="center">6<br>
        </td>
        <td valign="top" align="center">sin(arg1)<br>
        </td>
      </tr>
      <tr>
        <td valign="top" align="center">7<br>
        </td>
        <td valign="top" align="center">cos(arg1)<br>
        </td>
      </tr>
      <tr>
        <td valign="top" align="center">8<br>
        </td>
        <td valign="top" align="center">tan(arg1)<br>
        </td>
      </tr>
      <tr>
        <td valign="top" align="center">9<br>
        </td>
        <td valign="top" align="center">exp(arg1)<br>
        </td>
      </tr>
      <tr>
        <td valign="top" align="center">10<br>
        </td>
        <td valign="top" align="center">log(arg1)<br>
        </td>
      </tr>
      <tr>
        <td valign="top" align="center">11<br>
        </td>
        <td valign="top" align="center">sqrt(arg1)<br>
        </td>
      </tr>
    </tbody>
  </table>
  <br>
</td>
      <td valign="middle">"arg1" refers to the DP floating-point number stored in the pair of work-area valued <font color="#663300"><code>DW(0),DW(1)</code></font>.<br>
  <br>
"arg2" refers to the DP floating-point number stored in the pair of work-area valued <font color="#663300"><code>DW(2),DW(3)</code></font>.<br>

  <br>
The DP floating-point result of the operation is stored back into <font color="#663300"><code>DW(0),DW(1)</code></font>, although not all of the operations can necessarily produce results of full DP accuracy from DP operands.<br>
  <br>
The angular unit for trigonometric operations is the radian.<br>
<br>
Note that the values stored in these registers of the work-area are in 
the binary format of "IBM hexadecimal floating-point", which are not 
used anywhere else in XPL memory (unless copied from the working area).<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>F</i>=MONITOR(10,<i>string</i>);<br>
    </font></code></td>
      <td valign="middle">Performs character to DP floating-point conversion upon characters in <code><font color="#663300"><i>string</i></font></code>.
 The return code is 0 if the result is valid, or 1 if conversion was not
 possible. The result is placed in the first double word of the work 
area provided by the <font color="#663300"><code>MONITOR(5)</code></font> call.<br>
</td>
      <td valign="middle">In other words, <code><font color="#663300"><i>string</i></font></code> is interpreted as a DP floating-point number and stored in <font color="#663300"><code>DW(0),DW(1)</code></font>.&nbsp; Any of the usual representations for decimal numbers are accepted in the string, including the usual <font color="#663300"><code>E</code></font> notation for exponents.<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">CALL MONITOR(11);<br>
    </font></code></td>
      <td valign="middle">No-op.<br>
</td>
      <td valign="middle"><br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>string</i>=MONITOR(12,<i>p</i>);<br>
    </font></code></td>
      <td valign="middle">Converts floating-point number in the first double word of the work area to standard HAL/S character form. Value of <code><font color="#663300"><i>p</i></font></code> indicates whether the operand is SP (<code><font color="#663300"><i>p</i></font></code>=0) or DP (<code><font color="#663300"><i>p</i></font></code>=8).<br>
</td>
      <td valign="middle">In other words, this is the inverse of <code><font color="#663300">MONITOR(10,<i>string</i>)</font></code> (see above).<br>
  <br>
As far as the "standard HAL/S character form" is concerned, it's described in HAL/S documentation (<i>Programming in HAL/S</i>, p. 3) as follows:<br>
  <ul>
    <li>0.0: Printed as " 0.0" (notice the leading space).</li>
    <li>Positive:  Printed as " d.ddd...E±ee"</li>
    <li>Negative:  Printed as "-d.ddd...E±ee"</li>
  </ul>
Except for the special case 0.0, the number of printed fractional digits
 is always the same, although we're not told exactly how many that it 
is:&nbsp; merely that it is "implementation dependent".&nbsp; I believe,
 without any basis — and therefore <b>XCOM-I</b> implements — that the 
number of fractional digits is chosen to provide the maximum accuracy, 
which is 6 for single precision and 15 for double precision.<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>address</i>=MONITOR(13,<i>name</i>);<br>
    </font></code></td>
      <td valign="middle">Performs DELETE of current option processor and then LOADs an option processor specified by <code><font color="#663300"><i>name</i></font></code>.
 The option processor loaded is called and passed a pointer to the PARM 
field in effect at the time of compiler invocation. The option processor
 passes the PARM field and establishes an options table (see Chapter 9 
[of document IR-182-1]) whose address is passed back as a return 
value.&nbsp; If <code><font color="#663300"><i>name</i></font></code> is a null string, the pointer to the existing options table is returned.<br>
</td>
      <td valign="middle"><a name="MONITOR13"></a><a moz-do-not-send="true" href="#programOptions">See the earlier discussion concerning program options</a>.&nbsp;
 In brief, each XPL or XPL/I program has some defined set of "Type 1" 
options and "Type 2" options.&nbsp; The former are binary (on/off) 
options, whereas the latter are options with integer or string values.<br>
<br>
<code><font color="#663300">MONITOR(13,<i>name</i>)</font></code>
 returns an address which is used by the XPL program to find options settings for it that have been
 set up by the run-time library.&nbsp; In C terms, it's the equivalent 
for <font color="#663300"><code>argv[]</code></font> but with more 
behind-the-scenes interpretation of the parameters.&nbsp; Those program 
options would originally have been provided by the Job Control 
Language (JCL) which initiated execution of the program, by means a 
"PARM field" given on one of the JCL cards.&nbsp; For example, in the 
JCL<br>
<blockquote>
  <pre><font color="#663300">//XPL EXEC PGM=MONITOR,<br>//         PARM='SYTSIZE=1800,REFSIZE=20000,LISTING2,$I,$V,$U,$W'</font><br></pre>
</blockquote>
the PARM field is the string <font color="#663300"><code>'SYTSIZE=1800,REFSIZE=20000,LISTING2,$I,$V,$U,$W'</code></font>,
 and the comma-delimited items are the individual options 
selected.&nbsp; Presumably, the operating system wouldn't have been able
 to directly interpret the meaning of this PARM field on its own, since 
the types of options would have been specific to the program being 
run.&nbsp; So an "option processor" specific to the allowed parameters
must be loaded to perform that interpretation.&nbsp; In the case of 
the Intermetrics version of <b>HAL/S-FC</b>, the particular options processor for compiler pass 1 was <code><font color="#663300"><i>name</i></font></code><font color="#663300"><code>='COMPOPT '</code></font>, whereas it was an empty string for passes 2 and 3, and <font color="#663300"><code>'LISTOPT '</code></font>
 for pass 4.&nbsp; (Note the trailing spaces to make the non-empty 
strings come out to 8 characters.&nbsp; These trailing spaces are not required in <b>XCOM-I</b>.)&nbsp; <br>
<br>
Again, just to be doubly clear, <code><font color="#663300">MONITOR(13)</font></code> provides access to options settings <i>not</i> for <b>XCOM</b> or <b>XCOM-I</b>, but rather for the XPL program being compiled by <b>XCOM-I</b>, and specifically for <b>HAL/S-FC</b>. <br>
<br><b>XCOM-I</b> supports the pre-existing built-in options processors 
'COMPOPT', 'LISTOPT' and 'MONOPT'.&nbsp; (MONOPT provides the parameters
 described in McKeeman, but they are passed to the XPL/I program in the 
Intermetrics manner rather than being confined to the submonitor as in 
McKeeman.)&nbsp; Plus, it is possible (as described in the discussion of
 program options) for the user to define their own custom options 
processor called 'USEROPT'.&nbsp; Whenever <code><font color="#663300">MONITOR(13)</font></code> is called, it saves the <code><font color="#663300"><i>name</i></font></code> and the PARM field to a file called "monitor13.parms".&nbsp; If called with an empty <code><font color="#663300"><i>name</i></font></code>, or more typically as <code><font color="#663300">MONITOR(13,0)</font></code>, it simply reloads the contents of monitor13.parms and reuses those.<br>
<br>
The <code><font color="#663300"><i>address</i></font></code> returned by <code><font color="#663300">MONITOR(13)</font></code> is a pointer in memory to the beginning of a block of 6 consecutive <font color="#663300"><code>FIXED</code></font> values<font size="-1"><b>:</b></font><br>
<ul>
  <li><font color="#663300"><font color="#000000">The<b> </b>first is a <font color="#663300"><code>FIXED</code></font> value (called </font></font><font color="#663300"><font color="#000000"><font color="#663300"><code>OPTIONS_CODE</code></font> or <font color="#663300"><code>OPTION_BITS</code></font>) that collects</font></font>
 32 bit flags, each of them (in principle) itself representing a type 1 
(on/off) option.  Refer to the source-code files COMPOPT.bal, 
LISTOPT.bal, and MONOPT.bal (in the MONITOR.ASM folder of the <b>HAL/S-FC</b> source code) for the detailed list of which options correspond to which of the 32 bits.</li><li><font color="#663300"><font color="#000000">The remaining five values are the pointer addresses for <font color="#663300"><code>BASED FIXED</code></font> arrays:  </font><code>CON</code></font>, <font color="#663300"><code>PRO</code></font>, <font color="#663300"><code>TYPE2</code></font>, <font color="#663300"><code>VALS</code></font>, <font color="#663300"><code>NPVALS</code></font> (or <font color="#663300"><code>MONVALS</code></font>), each of which the options processor has already allocated memory for and equipped with data:</li>
  
<ul>

    <li><font color="#663300"><code>CON</code></font>:  This is an array of string descriptors for the selected type 1 options.  <b>HAL/S-FC</b> uses it just for printing a report in pass 1, while using <font color="#663300"><code>OPTIONS_CODE</code></font> in place of it for any more-significant purpose. <a moz-do-not-send="true" href="#programOptions">Our earlier section on program options</a> lists the order in which the parameters appear in <font color="#663300"><code>CON</code></font>.</li><li><font color="#663300"><code>PRO</code></font>:  In principle, this is like <font color="#663300"><code>CON</code></font>, but instead contains the opposites of the selected options.  For example, if "LISTING2" appears in <font color="#663300"><code>CON</code></font>, then "NOLISTING2" appears in <font color="#663300"><code>PRO</code></font>.  However, because no known legacy XPL/I software uses it, <b>XCOM-I</b> doesn't presently support <font color="#663300"><code>PRO</code></font>, but instead always returns a pointer equal to 0.</li>
    <li><font color="#663300"><code>TYPE2</code></font>:  This array 
contains the names (as string descriptors) of options of type 2 (i.e., 
options which can be assigned value other than on/off).  They are 
presented in the order listed in the discussion of program options. <br></li>
    <li><font color="#663300"><code>VALS</code></font>:  This array contains the values of the options of type 2, in the same order as the names in the <font color="#663300"><code>TYPE2</code></font> array.  Once again, see the discussion of program options.</li>
    <li><font color="#663300"><code>NPVALS/MONVALS</code></font>: This is like <font color="#663300"><code>VALS</code></font>, except that in principle it contains values of options which are <i>not</i> among the list printed by <b>HAL/S-FC</b>, which roughly speaking, is half of them.  No known legacy software uses <font color="#663300"><code>NPVALS/MONVALS</code></font>, so <b>XCOM-I</b> doesn't presently support it and instead always returns a pointer equal to 0.</li>
  
</ul>
</ul>
<ul>

</ul>



</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>F</i>=MONITOR(14,<i>n</i>,<i>a</i>);<br>
    </font></code></td>
      <td valign="middle">N/A<br>
</td>
      <td valign="middle">This is a no-op for <b>XCOM-I</b> but may be implemented in the future.&nbsp; It is related to so-called Simulation Data Files (SDF), which are only relevant to <b>HAL/S-FC</b>
 compiler passes 3 and 4, which are not currently on Virtual AGC's 
roadmap for implementation since none of the support software for SDF 
has survived.<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>I</i>=MONITOR(15);<br>
    </font></code></td>
      <td valign="middle">Returns Revision Level and Catenation Number from last <font color="#663300"><code>MONITOR(2)</code></font>
 call.&nbsp; Catenation number is obtained from PDS directory data and 
Revision Level from user data field as specified in the HAL/SDL ICD. The
 values are returned in the left and right halfwords of the result.<br>
</td>
      <td valign="middle">TBD<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">CALL MONITOR(16,<i>n</i>);<br>
    </font></code></td>
      <td valign="middle">Sets flags in byte to be returned as high 
order byte of return code at end of compilation. Flags are passed as 
right most byte of fullword <code><font color="#663300"><i>n</i></font></code>. If high order bit of <code><font color="#663300"><i>n</i></font></code> is zero, flags are OR'ed into existing flags. If high order bit of <code><font color="#663300"><i>n</i></font></code> is one, flags replace existing flags.<br>
</td>
      <td valign="middle">TBD<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">CALL MONITOR(17,name);<br>
    </font></code></td>
      <td valign="middle">Causes <i><code><font color="#663300">name</font></code></i> to be copied to third parm field (if any) passed to <font color="#663300"><code>MONITOR</code></font> by the program that invoked the compiler. See HAL/SDL ICD.<br>
</td>
      <td valign="middle">TBD<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>T</i>=MONITOR(18);<br>
    </font></code></td>
      <td valign="middle">Returns elapsed CPU time since beginning of run in units of .01 seconds.<br>
</td>
      <td valign="middle"><br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>F</i>=MONITOR(19,<i>addressList</i>,<i>sizeList</i>);<br>
    </font></code></td>
      <td valign="middle">This is an extended form of <font color="#663300"><code>MONITOR(6)</code></font> (see above), accepting arrays of addresses of <font color="#663300"><code>BASED</code></font> variables and their block sizes.&nbsp; Unlike <font color="#663300"><code>MONITOR(6)</code></font>, the newly-allocated blocks of memory are not cleared to 0.<br>
</td>
      <td valign="middle"><b>XCOM-I</b> does not implement this function.&nbsp; Besides, it's unclear how to represent a "list".<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">CALL MONITOR(20,</font></code><code><font color="#663300"><code><font color="#663300"><i>addressList</i>,<i>sizeList</i></font></code>);<br>
    </font></code></td>
      <td valign="middle">This is an extended form of <font color="#663300"><code>MONITOR(7)</code></font> (see above), accepting arrays of addresses of <font color="#663300"><code>BASED</code></font> variables and their block sizes. <br>
</td>
      <td valign="middle"><b>XCOM-I</b> does not implement this function.
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>I</i>=MONITOR(21);<br>
    </font></code></td>
      <td valign="middle">Returns remaining amount of memory (in bytes) that's free for allocation via <font color="#663300"><code>MONITOR(6)</code></font>.<br>
</td>
      <td valign="middle">For Intermetrics <b>XCOM</b>, I believe, <font color="#663300"><code>MONITOR(6)</code></font> could use <i>any</i> contiguous block of free memory, including those that were candidates for garbage collection.&nbsp; Whereas <b>XCOM-I</b>
 only allocates memory within the contiguous block at the end of the 
free-memory space.&nbsp; Consequently, this function would originally 
have found the largest free block wherever it was located, whereas <b>XCOM-I</b> merely reports the size of the final block of free memory.<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>F</i>=MONITOR(22,<i>n<sub>1</sub></i>);</font></code><br>
<code><font color="#663300"><code><font color="#663300"><i>F</i>=MONITOR(22,0,<i>n<sub>2</sub></i>);</font></code>
    </font></code></td>
      <td valign="middle">Calls SDF access package.<br>
</td>
      <td valign="middle">I don't know what this means, nor what the parameters represent.<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>descriptor</i>=MONITOR(23);<br>
    </font></code></td>
      <td valign="middle">Returns the <code><font color="#663300"><i>descriptor</i></font></code> of the 10-character string obtained from 
the ID field of the File Control Block of the first phase of the 
compiler.&nbsp; The ID field is maintained by the <b>XPLZAP</b> program and contains the identifying string printed on the header of each page of the HAL listing".
</td>
      <td valign="middle">I think that what the original documentation was trying to get at is that <b>HAL/S-FC</b>'s version code, printed on each of the report pages printed by <b>XCOM</b> (or now, <b>XCOM-I</b>), is given by this ID string, and that the ID string is provided to each pass of <b>HAL/S-FC</b> via a call to <code><font color="#663300">MONITOR(23)</font></code>.&nbsp; Of course, in the modern reimplementation, there is no <b>XPLZAP</b> program, and it wouldn't be compatible with <b>XCOM-I</b> if there were one.&nbsp; In <b>XCOM-I</b>, the ID string itself is by default 'REL32V0&nbsp;&nbsp; ', but it can be changed via the <b>XCOM-I</b> command-line parameter <font color="#663300"><code>--identifier</code></font>.<br>
<br>
As for what a "descriptor" is, see <a moz-do-not-send="true" href="#datatypes">the description of the CHARACTER datatype</a>.&nbsp;&nbsp; In brief, the return value is not itself the ID string, but an integer value (i.e., of the <font color="#663300"><code>FIXED</code></font> datatype) that provides an index for finding the ID string in memory. <br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">MONITOR(24)<br>
    </font></code></td>
      <td valign="middle">Read a block of a load module.<br>
</td>
      <td valign="middle">TBD<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">MONITOR(25)<br>
    </font></code></td>
      <td valign="middle">Read a mass-memory load block.<br>
</td>
      <td valign="middle">TBD<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">MONITOR(26)<br>
    </font></code></td>
      <td valign="middle">Read a MAF (memory analysis file) block<br>
</td>
      <td valign="middle">TBD<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">MONITOR(27)<br>
    </font></code></td>
      <td valign="middle">Write a MAF block<br>
</td>
      <td valign="middle">TBD<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">MONITOR(28)<br>
    </font></code></td>
      <td valign="middle">Link to dump analysis service routine<br>
</td>
      <td valign="middle">TBD<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">MONITOR(29)<br>
    </font></code></td>
      <td valign="middle">Return current page number<br>
</td>
      <td valign="middle">TBD<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">MONITOR(30)<br>
    </font></code></td>
      <td valign="middle">Return JFCB as string<br>
</td>
      <td valign="middle">TBD<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">CALL MONITOR(31</font></code><code><font color="#663300"><code><font color="#663300">,<i>n</i></font></code>,<i>recnum</i>)<br>
    </font></code></td>
      <td valign="middle">Virtual-memory lookahead service.<br>
</td>
      <td valign="middle">I think this may be optional.&nbsp; At any rate, it presently does nothing in <b>XCOM-I</b>.<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>F</i>=MONITOR(32)<br>
    </font></code></td>
      <td valign="middle">Find out subpool minimum size<br>
</td>
      <td valign="middle">The memory-allocation and -deallocation functions (<code><font color="#663300">MONITOR</font></code>
 6, 7, 19, and 20) are supposed to get their memory from something 
called "SUBPOOL 22".&nbsp; SUBPOOLs apparently have block-sizes which 
are either 2048 or 4096 bytes, depending on the operating system.&nbsp; <code><font color="#663300">MONITOR(32)</font></code>
 returns the appropriate block size for the operating system.&nbsp; 
Given that the block size is bigger in later versions of the operating 
system, I infer that bigger is better, within certain limits, and hence <b>XCOM-I</b> arbitrarily returns 4096.<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">MONITOR(33)<br>
    </font></code></td>
      <td valign="middle">Find out FILE max REC# and BLKSIZ<br>
</td>
      <td valign="middle">TBD<br>
</td>
    </tr>
    
    
    
    
    
    
  </tbody>
</table><br>
<h1><a name="debugging"></a>Debugging XPL Programs</h1>

<p>It is admittedly unlikely that many people will be writing new XPL or
 XPL/I programs nowadays, and will instead be compiling only legacy XPL 
or XPL/I programs ... assuming that I haven't already compiled all of 
them first!  (Which is a distinct possibility.)  Since such legacy 
programs will presumably all have been debugged decades before, there's 
not as much need for a debugger as there is for computer languages in 
which there are many active developers.  Nevertheless, XPL or XPL/I 
programs can be run under a debugger to a certain extent.<br></p>
The trick is to realize that while we have no debugger for the XPL language, we do have debuggers for C, and once <b>XCOM-I</b>
 has translated XPL or XPL-I software into C, such C debuggers can be 
used.  It is merely necessary when compiling the C code to include the 
necessary command-line switches that cause the C compiler to incorporate
 debugging information into the executable.  For the <b>gcc</b> C compiler, that command-line switch is <font color="#663300"><code>-ggdb</code></font>, and incorporating it can be done simply by adding it to the <b>make</b> command like via<br>
<blockquote><font color="#663300"><code>make EXTRA=-ggdb ...</code></font><br>
</blockquote>
Having done this, any debugger which can accept <b>gdb</b> style debugging info, such as <b>gdb</b> itself or full-screen wrappers for <b>gdb</b>, can now be used for debugging.&nbsp; For other C compilers or other debuggers, perhaps different switches would be needed.<br>
<br>
But debugging XPL code via its C translation is not as convenient as a native XPL debugger would be.<br>
<br>
The principal difficulty in debugging the code in C vs in XPL is that <b>XCOM-I</b> doesn't model XPL variables as C variables, but rather as numerical locations in an array called <font color="#663300"><code>memory</code></font>.&nbsp;
 Moreover, the format of this data in "memory" is that of the IBM 
System/360 rather than the native format of the computer on which 
debugging is being performed.&nbsp; While in my opinion, these design 
choices for <b>XCOM-I</b> were are all necessary and unavoidable, 
there's no denying that they make it trickier to use a debugger to see 
the how the values of variable change during execution.&nbsp; <br>
<br>
I have, however, provided a few C functions in the runtime library to make it a <i>little</i> less painful to examine XPL variables within a debugger.&nbsp; You can also use the XPL <font color="#663300"><code>CALL INLINE</code></font>
 feature to directly embed calls to these functions within your program,
 without running a debugger at all, if it's more convenient for you to 
do so.<br>
<br>
The debugging functions are:<br>
<ul>
  <li><font color="#663300"><code>void printMemoryMap(char *heading)</code></font>
 — This function prints out the entire current state of the memory map. 
 I.e., the addresses of all variables, including dynamically-allocated 
ones, and the contents of all of those variables.  Of course, for an XPL
 program any complexity, the printout is quite long, so this function is
 presumably used sparingly.  The <font color="#663300"><code>heading</code></font> parameter is simply a message printed at the top, which can be helpful if you call <font color="#663300"><code>printMemoryMap</code></font> several times (perhaps via <font color="#663300"><code>CALL INLINE</code></font>) in the same program run.  In a <b>gdb</b> console, you could run it via the command <font color="#663300"><code>call printMemoryMap("...")</code></font>, whereas you could instead embed it in your XPL source code via <font color="#663300"><code>CALL INLINE('</code><code>printMemoryMap("...")</code><code>');</code></font>.<br></li>
  <li><font color="#663300"><code>char *getXPL(char *identifier)</code></font> — Returns (as a C string) the value of a single XPL variable whose name is given by the <font color="#663300"><code>identifier</code></font>.  The <font color="#663300"><code>identifier</code></font>
 string can be any identifier expression that's syntactically correct in
 XPL/I, provided that subscripts consist entirely of decimal digits, 
possibly with a leading minus sign.  This includes expressions like <font color="#663300"><code>"V"</code></font>, <font color="#663300"><code>"V(5)"</code></font>, <font color="#663300"><code>"B(3).V"</code></font>, or <font color="#663300"><code>"B(3).V(-5)"</code></font>.  Recall that in XPL/I, subscripts can be applied to scalar variables.  If you are querying a <font color="#663300"><code>BASED RECORD</code></font>, then be sure to include the desired field, since while <font color="#663300"><code>getXPL</code></font> knows how to print an individual field of a <font color="#663300"><code>RECORD</code></font>, it does not know how to print a <i>collection</i> of fields such as a <font color="#663300"><code>RECORD</code></font>.  In a <b>gdb</b> console, you could use <font color="#663300"><code>getXPL</code></font> with a command like <font color="#663300"><code>print getXPL(...)</code></font>.   For example, <font color="#663300"><code>print getXPL("C1(4)")</code></font>. <br></li>
  <li><font color="#663300"><code>void printXPL(char *identifier)</code></font> — This provides the same functionality as <font color="#663300"><code>getXPL</code></font>, except that it prints its output to <font color="#663300"><code>stdout</code></font> rather than returning it as a string.  In a <b>gdb</b> console, you could run it via the command <font color="#663300"><code>call printXPL("...")</code></font>, or you could instead embed it in your XPL source code via <font color="#663300"><code>CALL INLINE('</code><code>printXPL("...")</code><code>');</code></font>.</li>
  <li><font color="#663300"><code>int bitBits</code></font> — By default, <font color="#663300"><code>getXPL</code></font> and <font color="#663300"><code>printXPL</code></font> print the data of a <font color="#663300"><code>BIT</code></font> variable in hexadecimal notation.  In contrast, legacy XPL source code has often logically partitioned the data in <font color="#663300"><code>BIT</code></font>
 strings into subgroupings of 1, 2, or 3 bits (rather than 4 as for 
hexadecimal), thus using literal constants (such as initializers in 
declarations) that are in binary, base-4, or octal notation.  In those 
cases, it's difficult to relate hexadecimal strings returned by <font color="#663300"><code>getXPL</code></font> with the literals shown in the XPL source code.  The global variable <font color="#663300"><code>bitBits</code></font> addresses this by allowing you to change the radix used for the <font color="#663300"><code>BIT</code></font> data.  By default <font color="#663300"><code>bitBits</code></font> is 4 (hexadecimal), but can be changed to 1 (binary), 2 (base-4), or 3 (octal)<font color="#663300"><code></code></font>.  In a <b>gdb</b> console, you could change via a command like <font color="#663300"><code>set bitBits=2</code></font>.</li>
</ul>
<p>In using these debugging functions, note that they all require <i>mangled</i> forms of variable names and parameters of <code>PROCEDURE</code>s.  Mangled names consist of the names of the variables or parameters as <font color="#663300"><code>DECLARE</code></font>d in the XPL source code, but <i>prefixed</i> by the names of all of the parent <font color="#663300"><code>PROCEDURE</code></font>s.  Perhaps an example would make this clearer.  Suppose your XPL source code looked like the following:<br></p>
<blockquote>
  <pre><font color="#663300">DECLARE X FIXED, Y FIXED, Z FIXED;<br></font></pre>
  <pre><font color="#663300">PROC1:<br>PROCEDURE(X, Y);<br>   DECLARE X FIXED, Y FIXED, Z FIXED;<br><br>   PROC2:<br>   PROCEDURE(X, Y);<br>      DECLARE X FIXED, Y FIXED, Z FIXED;<br>      ...<br>   END PROC2;<br><br>END PROC1;</font><br></pre>
</blockquote>
<p>Then the mangled variable and parameter names we'd find in our memory map (and just for reference, <font color="#663300"><code>PROCEDURE</code></font> names), as well as being used in our debugging functions, would be:<br></p>
<blockquote>
  <pre><font color="#663300">X<br>Y<br>Z<br>PROC1<br>PROC1xX<br>PROC1xY<br>PROC1xZ<br>PROC1xPROC2<br>PROC1xPROC2xX<br>PROC1xPROC2xY<br>PROC1xPROC2xZ</font><br></pre>
</blockquote>
Thus while we have lots of global and local variables and function parameters named <font color="#663300"><code>X</code></font>, <font color="#663300"><code>Y</code></font>, and <font color="#663300"><code>Z</code></font>, their mangled names are all distinct. <br>
<blockquote><font size="-1"><b>Aside:</b> By the way, the lower-case '<font color="#663300"><code>x</code></font>' characters appearing in the mangled names have nothing to do with the fact that one of our identifiers is '<font color="#663300"><code>X</code></font>'.&nbsp; That's a coincidence.&nbsp; Rather, they're just convenient separators <b>XCOM-I</b> conventionally uses between scope names and the variable names.&nbsp; Recall that XPL identifiers are case-insensitive.&nbsp; <b>XCOM-I</b> translates them all internally to upper case.&nbsp; Hence, lower-case 'x' is not a character that can appear in <i>un</i>mangled identifiers or names of scopes.</font><br>
</blockquote>
<h1>


  <a name="hooks"></a>Patches for Basic Assembly Language Code<br>
</h1>A serious difficulty in working with XPL/I code is that the Space Shuttle <b>PASS</b> programs were not 
written entirely in XPL/I, but also have insertions of inline IBM System/360 basic
 assembly-language (BAL) code at various junctures.&nbsp; However good 
<b>XCOM-I</b> may (or may not) be at translating XPL or XPL/I to C, it is <i>not</i> capable of inferring the intent of arbitrary BAL code, nor of translating such code into C.<br>
<br>
Moreover, there is a second problem associated with BAL code that has 
been inlined into XPL/I code, which is that while I can imagine 
replacing such BAL code by C-language code that provides the same 
functionality, I do <i>not</i> want to do it in a way that necessitates 
altering the original XPL/I source code!&nbsp; Why is that?&nbsp; The simplest answer to that is that the Virtual AGC Project's <i>raison d'être</i>
 is to present the demonstrably authentic contemporary software for 
now-classic space missions such those of Apollo and the Space 
Shuttle.&nbsp; And <i>the less you change the source code</i>, the 
easier it is to be demonstrably authentic.&nbsp; In fact, there's hardly
 any leeway to change the source code at all, from that perspective. 
Guaranteed authenticity may not be something you care about personally, 
but then on the other hand, <i>you're</i> free to make whatever changes 
you like to XPL source code you have on hand, as long as you don't 
insist that I follow your lead.<br>
<br>
Don't worry!&nbsp; <b>XCOM-I</b> lets us satisfy these criteria.&nbsp; But to understand <i>how</i>, you need to know a 
little more about this BAL source code that's causing the problem.<br>
<br>
Let's let a real-life example guide the discussion.&nbsp; The XPL source-code for SUNY's <b>XCOM4</b>
 program — which as you'll recall is an XPL compiler from the State 
University of New York in the mid-1970's  — contains a single block of 
19 consecutive <font color="#663300"><code>CALL INLINE</code></font> statements that we need to work around if we want to compile <i>and run</i> a version of <b>XCOM4</b> with <b>XCOM-I</b>:<br>
<blockquote>
  <pre><font color="#663300">SCAN_FINDS_END_OF:<br>   PROCEDURE(TABLE) BIT(1);<br>      DECLARE TABLE FIXED;<br>      DECLARE TRT(1) FIXED INITIAL("DD003000", "10000000");<br><br>      /* THIS PROCEDURE ASSUMES CP = 0 WHEN IT IS CALLED */<br>      CALL INLINE("58", 3, 0, TEXT);     /* LOAD STRING DESCRIPTOR */<br>      CALL INLINE("1B", 2, 2);           /* CLEAR REG. 2 */<br>      CALL INLINE("19", 3, 2);           /* CHECK FOR TEXT = NULL STRING */<br>      CALL INLINE("07", 8, 12);          /* RETURN FALSE IF TEXT IS NULL */<br>      CALL INLINE("8D", 2, 0, 0, 8);     /* SHIFT LENGTH FIELD TO REG. 2 */<br>      CALL INLINE("88", 3, 0, 0, 8);     /* RESTORE STRING ADDRESS  */<br>      CALL INLINE("58", 1, 0, TABLE);    /* LOAD BASE ADDRESS OF TRANS_TABLE */<br>      CALL INLINE("41", 12, 0, TRT);     /* LOAD ADDRESS OF TRT INSTRUCTION */<br>      CALL INLINE("44", 2, 0, 12, 0);    /* EXECUTE TRT INSTRUCTION */<br>      CALL INLINE("05", 12, 0);          /* LOAD BRANCH REGISTER  */<br>      CALL INLINE("47", 7, 0, 12, 18);   /* BRANCH ON CC~=0  */<br>      CALL INLINE("18", 1, 2);           /* LOAD REG. 1 WITH LENGTH(\) - 1 */<br>      CALL INLINE("41", 0, 0, 0, 1);     /* LOAD REG. 0 WITH 1  */<br>      CALL INLINE("1A", 1, 0);           /* ADD TO OBTAIN IDENTIFIER LENGTH */<br>      CALL INLINE("1B", 3, 3);           /* PUT 0 INTO RETURN REGISTER */<br>      CALL INLINE("47", 15, 0, 12, 24);  /* BRANCH AROUND NEXT TWO INSTR*/<br>      CALL INLINE("1B", 1, 3);        /* SUBTRACT TO OBTAIN IDENTIFIER LENGTH */<br>      CALL INLINE("41", 3, 0, 0, 1);     /* LOAD 1 INTO RETURN REGISTER */<br>      CALL INLINE("50", 1, 0, CP);       /* STORE IDENTIFIER LENGTH */<br>   END SCAN_FINDS_END_OF;</font><br></pre>
</blockquote>
Actually, to be clear, <b>XCOM-I</b> will <i>compile</i> <b>XCOM4</b> 
just fine, whether we work around this embedded assembly-language stuff 
or not; the compiled program simply won't run correctly.&nbsp; As it 
happens, though, part of the process of creating the workaround <i>depends</i> on us compiling <b>XCOM4</b> in advance, without any workarounds in place.&nbsp; So let's just do that.&nbsp; In the compilation process, the XPL procedure <font color="#663300"><code>SCAN_FINDS_END_OF</code></font> turns into a C file called SCANxSCAN_FINDS_END_OF.c that contains the following harmless but useless C representation of it:<br>
<blockquote>
  <pre><font color="#663300">/*<br>  File SCANxSCAN_FINDS_END_OF.c generated by XCOM-I, 2024-05-19 12:14:14.<br>*/<br><br>#include "runtimeC.h"<br>#include "procedures.h"<br><br>bit_t *<br>SCANxSCAN_FINDS_END_OF(void)<br>{<br>  ; // (0) CALL INLINE( 88, 3, 0, TEXT);<br>  ; // (1) CALL INLINE( 27, 2, 2);<br>  ; // (2) CALL INLINE( 25, 3, 2);<br>  ; // (3) CALL INLINE( 7, 8, 12);<br>  ; // (4) CALL INLINE( 141, 2, 0, 0, 8);<br>  ; // (5) CALL INLINE( 136, 3, 0, 0, 8);<br>  ; // (6) CALL INLINE( 88, 1, 0, TABLE);<br>  ; // (7) CALL INLINE( 65, 12, 0, TRT);<br>  ; // (8) CALL INLINE( 68, 2, 0, 12, 0);<br>  ; // (9) CALL INLINE( 5, 12, 0);<br>  ; // (10) CALL INLINE( 71, 7, 0, 12, 18);<br>  ; // (11) CALL INLINE( 24, 1, 2);<br>  ; // (12) CALL INLINE( 65, 0, 0, 0, 1);<br>  ; // (13) CALL INLINE( 26, 1, 0);<br>  ; // (14) CALL INLINE( 27, 3, 3);<br>  ; // (15) CALL INLINE( 71, 15, 0, 12, 24);<br>  ; // (16) CALL INLINE( 27, 1, 3);<br>  ; // (17) CALL INLINE( 65, 3, 0, 0, 1);<br>  ; // (18) CALL INLINE( 80, 1, 0, CP);<br>  return 0;<br>}</font><br></pre>
</blockquote>


Basically, <b>XCOM-I</b> has simply commented out each <font color="#663300"><code>CALL INLINE</code></font>
 statement, while replacing it with an empty statement.&nbsp; So why did
 we bother compiling it at all?&nbsp; The answer is that we want the 
parenthesized numbers that have been added to the comments!&nbsp; The 
parenthesized numbers will be the same every time we compile <b>XCOM4</b>, unless you take it upon yourself to mess us up by removing some of the <font color="#663300"><code>CALL INLINE</code></font> statements or adding new ones in the meantime.&nbsp; <b>Pro tip:</b>&nbsp; Don't do that!<br>
<br>
In this particular example, since <b>XCOM4</b> has a single block of <font color="#663300"><code>CALL INLINE</code></font> statements, we were guaranteed in advance that the block would start with number 0.&nbsp; In a more-complex example like <b>HAL/S-FC</b>, there would be a number of blocks of inlines, strewn throughout the source code, and lieu of <b>XCOM-I</b>
 printing them all out for us the numbering would be 
unpredictable.&nbsp; But because the numbers never change, we can use 
them as unique, persistent identifiers for the <font color="#663300"><code>CALL INLINE</code></font> statements.&nbsp; <br>
<br>
Why is that important?&nbsp; The way we're going to work around the <font color="#663300"><code>CALL INLINE</code></font>
 statements is to create a series of numbered "patch files", written in 
C:&nbsp; patch0.c, patch1.c, patch2.c, and so on.&nbsp; The patch files 
are placed in the same folder that contains the source code of the XPL 
program being compiled, though <b>XCOM-I</b> does have a command-line 
option (<font color="#663300"><code>--patch=<i>PATHNAME</i></code></font>)
 that allows a different folder to be specified.&nbsp; When <b>XCOM-I</b> encounters a <font color="#663300"><code>CALL INLINE</code></font> statement, it looks for a patch file with the same number, and <i>if</i>
 it finds one, it directly inserts the contents of the patch file into 
the object code. &nbsp; If there's no matching patch file, then the <font color="#663300"><code>CALL INLINE</code></font> simply remains a comment.&nbsp; In principle, you could have a different patch file for each <font color="#663300"><code>CALL INLINE</code></font>, but it's usually more practical and more aesthetically pleasing to have a single patch file for each contiguous block of <font color="#663300"><code>CALL INLINE</code></font> statements.&nbsp; <br>
<br>
In this real-life example, since there's a single block of <font color="#663300"><code>CALL INLINE</code></font> statements, we need a single patch file, patch0.c:<br>
<blockquote>
  <pre><font color="#663300">/*<br> * This is a C-language "patch" for CALL INLINE #0 in xcom4.xpl, as compiled<br> * by XCOM-I.py.<br> *<br> * The patch spans the entirety of the `SCAN_FINDS` procedure embedded in<br> * the `SCAN` procedure.  This comprises every `CALL INLINE` statement in<br> * the entire xcom4 program.<br> *<br> * What the procedure does is this:  It's given the address of a "translation<br> * table" of one of the following types:<br> *      `BLANKTABLE`  (Blanks)<br> *      `ALPHATABLE`  (Identifier)<br> *      `STRINGTABLE` (Quoted string)<br> *      `COMMENTABLE` (Comment)<br> * Starting at position `CP=0` (already set up upon entry so that we know the<br> * first character is of the asked-for type) in the string `TEXT`, searches<br> * for the end of the pattern of the selected type, and updates `CP` to the<br> * length of the found string.  It returns 0 on failure and 1 on success.  An<br> * empty string counts as a failure.<br> *<br> * This was apparently coded in BAL because the IBM 360 has a translation-table<br> * instruction, TRT, that does this efficiently.  But from my perspective,<br> * considering that there's no other embedded BAL code in the entire program,<br> * it seems as though it's a big price to pay, maintenance-wise and<br> * portability-wise, for a pretty small gain in efficiency.  Yes, you can<br> * always make assembly-language go faster than a high-level language; this is<br> * news?<br> */<br><br>static memoryMapEntry_t *mapCP = NULL, *mapTEXT = NULL, *mapTABLE,<br>      *mapBLANKTABLE, *mapALPHATABLE, *mapSTRINGTABLE, *mapCOMMENTABLE;<br>char *s, *TEXT;<br>uint32_t TABLE;<br><br>if (mapCP == NULL)<br>  {<br>    mapCP = lookupVariable("CP");<br>    mapTEXT = lookupVariable("TEXT");<br>    mapTABLE = lookupVariable("SCANxSCAN_FINDS_END_OFxTABLE");<br>    mapBLANKTABLE = lookupVariable("BLANKTABLE");<br>    mapALPHATABLE = lookupVariable("ALPHATABLE");<br>    mapSTRINGTABLE = lookupVariable("STRINGTABLE");<br>    mapCOMMENTABLE = lookupVariable("COMMENTABLE");<br>  }<br><br>TABLE = getFIXED(mapTABLE-&gt;address);<br>TEXT = descriptorToAscii(getCHARACTER(mapTEXT-&gt;address));<br><br>if (*TEXT == 0)<br>  return fixedToBit(1, 0);<br>if (TABLE == mapBLANKTABLE-&gt;address)<br>  {<br>    for (s = TEXT; *s == ' ' || *s == '\t'; s++);<br>  }<br>else if (TABLE == mapALPHATABLE-&gt;address)<br>  {<br>    for (s = TEXT;<br>         isalnum(*s) || *s == '_' || *s == '@' || *s == '#' || *s == '$';<br>         s++);<br>  }<br>else if (TABLE == mapSTRINGTABLE-&gt;address)<br>  {<br>    for (s = TEXT; *s &amp;&amp; *s != '\''; s++);<br><br>  }<br>else if (TABLE == mapCOMMENTABLE-&gt;address)<br>  {<br>    for (s = TEXT; *s &amp;&amp; *s != '*' &amp;&amp; *s != '$'; s++);<br>  }<br>else<br>  abend("Requested translation table for SCAN_FINDS_END_OF not found");<br>if (*s == 0)<br>  {<br>    putFIXED(mapCP-&gt;address, s + 1 - TEXT);<br>    return fixedToBit(1, 0);<br>  }<br>putFIXED(mapCP-&gt;address, s - TEXT);<br>return fixedToBit(1, 1);<br></font><br></pre>
</blockquote>
<blockquote><font size="-1"><b>Aside:</b>&nbsp; I'm not here to claim 
that it's easy to come up with C replacement code like this for IBM 
Basic Assembly Language inlined code, nor even that it's necessarily 
obvious that C code like this actually is a suitable replacement.&nbsp; 
At least it wasn't easy for me.&nbsp; But then, I don't understand IBM 
360 assembly language.&nbsp; Anybody who does understand it is going to 
find this process much easier.&nbsp; But regardless, the ease (or not) 
of developing the patch isn't at issue in this discussion.&nbsp; What's 
at issue is how to deliver that patch code to <b>XCOM-I</b> for incorporation into the XPL program being compiled.</font><br>
</blockquote>
Now that we actually have a patch file, when <b>XCOM-I</b> again compiles <b>XCOM4</b>, the <font color="#663300"><code>SCAN_FINDS_END_OF</code></font> procedure is now translated to the following C code:<br>
<blockquote>
  <pre><font color="#663300">/*<br>  File SCANxSCAN_FINDS_END_OF.c generated by XCOM-I, 2024-05-25 14:05:21.<br>*/<br><br>#include "runtimeC.h"<br><br>descriptor_t *<br>SCANxSCAN_FINDS_END_OF(void)<br>{<br><br>  { // (0) CALL INLINE ( 88, 3, 0,TEXT);<br>    /*<br>     * This is a C-language "patch" for CALL INLINE #0 in xcom4.xpl, as compiled<br>     * by XCOM-I.py.<br>     *<br>     * The patch spans the entirety of the `SCAN_FINDS` procedure embedded in<br>     * the `SCAN` procedure.  This comprises every `CALL INLINE` statement in<br>     * the entire xcom4 program.<br>     *<br>     * What the procedure does is this:  It's given the address of a "translation<br>     * table" of one of the following types:<br>     *      `BLANKTABLE`  (Blanks)<br>     *      `ALPHATABLE`  (Identifier)<br>     *      `STRINGTABLE` (Quoted string)<br>     *      `COMMENTABLE` (Comment)<br>     * Starting at position `CP=0` (already set up upon entry so that we know the<br>     * first character is of the asked-for type) in the string `TEXT`, searches<br>     * for the end of the pattern of the selected type, and updates `CP` to the<br>     * length of the found string.  It returns 0 on failure and 1 on success.  An<br>     * empty string counts as a failure.<br>     *<br>     * This was apparently coded in BAL because the IBM 360 has a translation-table<br>     * instruction, TRT, that does this efficiently.  But from my perspective,<br>     * considering that there's no other embedded BAL code in the entire program,<br>     * it seems as though it's a big price to pay, maintenance-wise and<br>     * portability-wise, for a pretty small gain in efficiency.  Yes, you can<br>     * always make assembly-language go faster than a high-level language; this is<br>     * news?<br>     */<br>    <br>    static memoryMapEntry_t *mapCP = NULL, *mapTEXT = NULL, *mapTABLE,<br>          *mapBLANKTABLE, *mapALPHATABLE, *mapSTRINGTABLE, *mapCOMMENTABLE;<br>    char *s, *TEXT;<br>    uint32_t TABLE;<br>    <br>    if (mapCP == NULL)<br>      {<br>        mapCP = lookupVariable("CP");<br>        mapTEXT = lookupVariable("TEXT");<br>        mapTABLE = lookupVariable("SCANxSCAN_FINDS_END_OFxTABLE");<br>        mapBLANKTABLE = lookupVariable("BLANKTABLE");<br>        mapALPHATABLE = lookupVariable("ALPHATABLE");<br>        mapSTRINGTABLE = lookupVariable("STRINGTABLE");<br>        mapCOMMENTABLE = lookupVariable("COMMENTABLE");<br>      }<br>    <br>    TABLE = getFIXED(mapTABLE-&gt;address);<br>    TEXT = descriptorToAscii(getCHARACTER(mapTEXT-&gt;address));<br>    <br>    if (*TEXT == 0)<br>      return fixedToBit(1, 0);<br>    if (TABLE == mapBLANKTABLE-&gt;address)<br>      {<br>        for (s = TEXT; *s == ' ' || *s == '\t'; s++);<br>      }<br>    else if (TABLE == mapALPHATABLE-&gt;address)<br>      {<br>        for (s = TEXT;<br>             isalnum(*s) || *s == '_' || *s == '@' || *s == '#' || *s == '$';<br>             s++);<br>      }<br>    else if (TABLE == mapSTRINGTABLE-&gt;address)<br>      {<br>        for (s = TEXT; *s &amp;&amp; *s != '\''; s++);<br>    <br>      }<br>    else if (TABLE == mapCOMMENTABLE-&gt;address)<br>      {<br>        for (s = TEXT; *s &amp;&amp; *s != '*' &amp;&amp; *s != '$'; s++);<br>      }<br>    else<br>      abend("Requested translation table for SCAN_FINDS_END_OF not found");<br>    if (*s == 0)<br>      {<br>        putFIXED(mapCP-&gt;address, s + 1 - TEXT);<br>        return fixedToBit(1, 0);<br>      }<br>    putFIXED(mapCP-&gt;address, s - TEXT);<br>    return fixedToBit(1, 1);<br>  }<br>  ; // (1) CALL INLINE ( 27, 2, 2);<br>  ; // (2) CALL INLINE ( 25, 3, 2);<br>  ; // (3) CALL INLINE ( 7, 8, 12);<br>  ; // (4) CALL INLINE ( 141, 2, 0,0,8);<br>  ; // (5) CALL INLINE ( 136, 3, 0,0,8);<br>  ; // (6) CALL INLINE ( 88, 1, 0,TABLE);<br>  ; // (7) CALL INLINE ( 65, 12, 0,TRT);<br>  ; // (8) CALL INLINE ( 68, 2, 0,12,0);<br>  ; // (9) CALL INLINE ( 5, 12, 0);<br>  ; // (10) CALL INLINE ( 71, 7, 0,12,18);<br>  ; // (11) CALL INLINE ( 24, 1, 2);<br>  ; // (12) CALL INLINE ( 65, 0, 0,0,1);<br>  ; // (13) CALL INLINE ( 26, 1, 0);<br>  ; // (14) CALL INLINE ( 27, 3, 3);<br>  ; // (15) CALL INLINE ( 71, 15, 0,12,24);<br>  ; // (16) CALL INLINE ( 27, 1, 3);<br>  ; // (17) CALL INLINE ( 65, 3, 0,0,1);<br>  ; // (18) CALL INLINE ( 80, 1, 0,CP);<br>  return 0;<br>}<br></font><br></pre>
</blockquote>
Notice that the patch is automatically placed within a C <font color="#663300"><code>{...}</code></font> block, which is important if the <font color="#663333"><code>CALL INLINE(...)</code></font> happens to have been preceded by something like <code><font color="#663300">IF ... THEN</font></code> or <font color="#663300"><code>ELSE</code></font>. <br>
<br>Finally in <b>XCOM-I</b>, if <font color="#663333"><code>CALL INLINE(...) </code></font>is
 used with a <i>single</i> parameter that's a string, then no patch file is 
sought.&nbsp; Rather, <b>XCOM-I</b> treats that single string parameter as a 
line of C code, and inserts the line directly into the output C 
code.&nbsp; Thus if you were willing to modify the original XPL source 
code rather than leaving it unchanged and using the patch-file 
technique, you might be able to do so just by altering the parameters of
 the <font color="#663333"><code>CALL INLINE(...) </code></font>statements to contain C source code rather than BAL source code.<br>
<br>


    
<hr style="width: 100%; height: 2px;">
    
<center><br>
      <span style="color: rgb(84, 89, 93); font-family: sans-serif;
        font-size: 11.05px; font-style: normal; font-variant: normal;
        font-weight: normal; letter-spacing: normal; line-height:
        16.575px; orphans: auto; text-align: center; text-indent: 0px;
        text-transform: none; white-space: normal; widows: 1;
        word-spacing: 0px; -webkit-text-stroke-width: 0px; display:
        inline !important; float: none; background-color: rgb(255, 255,
        255);"> This page is available under the <a href="https://creativecommons.org/publicdomain/zero/1.0/">
          Creative Commons No Rights Reserved License</a> </span><br>
      <i><font size="-1">Last modified by <a href="mailto:info@sandroid.org">Ronald Burkey</a> on
          2024-05-25<br>
          <br>
          <a href="https://www.ibiblio.org"> <img style="border: 0px
              solid ; width: 300px; height: 100px;" alt="Virtual AGC is
              hosted by ibiblio.org" src="hosted.png" width="300" height="100"></a><br>
        </font></i></center>


    <br>


  

</body></html>