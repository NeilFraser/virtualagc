<!DOCTYPE doctype PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
    
<title>Virtual AGC Document Library Page</title>


    
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">


    
<meta name="Author" content="Ronald Burkey">


    
<link rel="icon" type="image/png" href="favicon.png">


    
<meta name="author" content="Ronald S. Burkey">


    
<script type="text/javascript" src="Header.js"></script>
  </head>
  <body style="background-image: url(gray3.jpg);">
    
<script type="text/javascript">
document.write(headerTemplate.replace("@TITLE@","Space Shuttle").replace("@SUBTITLE@","XPL/I Compiler XCOM-I"))
</script><br>


    
<div align="center"><i>(This page is under construction.)</i><br>
    </div>


    
<h1>Table of Contents </h1>


    
<ul>


      <li><a moz-do-not-send="true" href="#Introduction">Introduction to XPL/I</a></li>
<li><a moz-do-not-send="true" href="#compiling">Processing a Program Written in XPL, Using <b>XCOM-I</b>
</a></li>
<ul>
  <li><a moz-do-not-send="true" href="#installation">Installation of <b>XCOM-I</b></a></li>
  <li><a moz-do-not-send="true" href="#xpl">Compiling and Running XPL Programs</a></li></ul>
<li><a moz-do-not-send="true" href="#xpli">A Primer for Standard XPL and Intermetrics XPL/I</a>
</li>
<ul>

  
</ul>

<li><a moz-do-not-send="true" href="#hooks">Patches for Basic Assembly Language Code</a>
</li>
</ul>


    
<h1><a name="Introduction"></a>Introduction to XPL/I<br>
</h1>Keep in mind that the Virtual AGC Project is devoted to onboard guidance 
software used aboard space vehicles such as those of the Apollo and 
Space Shuttle projects, thus most of what I have to say on the topic of 
XPL is from that point of view.&nbsp; But that doesn't mean it isn't applicable for general purposes as well.<br>
<br>
For the purpose of thinking about XPL, 
what you need to know to follow the discussion herein is this:<br>
<ul>
  <li>Flight software for the Space Shuttle was primarily written in a computer language called <i>HAL/S</i>, created by Intermetrics, Inc.&nbsp; That flight software was called <i>PASS</i>, and that's what I'll refer to it as from now on.<br></li>
  <li>To compile PASS source code, you therefore need a compiler for HAL/S, and more-specifically for Intermetrics's specific variation of HAL/S.&nbsp; Intermetrics's HAL/S compiler, called <b>HAL/S-FC</b>, was primarily written in a computer language they called <i>XPL</i>.</li>
  <li>Thus to compile the original compiler for PASS, you first need a compiler for the XPL language.<br></li>
</ul>
Well, that's certainly a mouthful of words!&nbsp; The point is that 
having an XPL compiler is just one item — though an important one! —  in
 a 
chain of things that are helpful in the process of 
resurrecting PASS for modern audiences. XPL used to be a computer language (<a moz-do-not-send="true" href="https://en.wikipedia.org/wiki/XPL">see the Wikipedia article</a>) in the 1960's and 1970's that was defined by a book called <i>A Compiler Generator</i>,
 by William M. McKeeman, James J. Horning, and David B. Wortman.&nbsp; 
Today, the language is deader than ancient Sumerian.&nbsp; Worse, the 
internals of the language relied heavily on the fact that the compiled 
XPL 
programs would run on IBM System/360 mainframes.&nbsp; While you can 
write an XPL compiler that will run on a different type of computer 
system, or to compile programs that will run on a different kind of 
computer system, doing so in a way that such programs, as-is, would 
produce the same results is problematic.
In practical terms, the book is the sole documentation for the standard
 XPL language, and is available neither for free, nor in digital form 
online.&nbsp; For brevity, I'll refer to that book from now on simply as
 <i>McKeeman</i>.<br>
<br>
Alas, it's even a bit more complicated than what I just said.&nbsp; For 
one thing, Intermetrics did not write its HAL/S compiler in <i>standard</i>
 XPL as defined by McKeeman.&nbsp; Rather, they extended the language 
with new features, occasionally changing the existing features in an 
incompatible way.&nbsp; From now on, I'll
 refer to Intermetrics's variant of XPL as <i>XPL/I</i> to distinguish it from the standard.<br>
<br>
In short, if you actually had a compiler for standard XPL that you could
 use on (say) a Windows, Mac OS, or Linux computer, it would most likely neither 
compile most XPL/I programs, nor would most of those compiled programs 
run correctly afterwards if you were able to do so.&nbsp; Consider the 
following brief example of a program:<br>
<blockquote>
  <pre><font color="#663333">declare x fixed, y fixed, z fixed;<br>x(0) = 1;<br>x(1) = 2;<br>x(2) = 3;<br>output = x(0) || ' ' || x(1) || ' ' || x(2);<br></font><font color="#663333">output = x || ' ' || y || ' ' || z;</font><br></pre>
</blockquote>
What is this little example supposed to do?&nbsp; First, it declares 3 variables of the <font color="#663333"><code>fixed</code></font> datatype; <font color="#663333"><code>fixed</code></font> means that <font color="#663333"><code>x</code></font>, <font color="#663333"><code>y</code></font>, and <font color="#663333"><code>z</code></font> are 32-bit signed integers.&nbsp; It then proceeds to use <font color="#663333"><code>x</code></font>
 <i>as if</i> it were a three-element array, though <font color="#663333"><code>x</code></font> wasn't declared that 
way, assigning values to each of its elements.&nbsp; In other words, the program assumes that <font color="#663333"><code>x(0)</code></font> corresponds to <font color="#663333"><code>x</code></font>, <font color="#663333"><code>x(1)</code></font> corresponds to <font color="#663333"><code>y</code></font>, and <font color="#663333"><code>x(2)</code></font> corresponds to <font color="#663333"><code>z</code></font>.&nbsp; Finally, the program "prints out" both the elements of <font color="#663333"><code>x</code></font> (as an array) and the values of <font color="#663333"><code>x</code></font> (as a non-array), <font color="#663333"><code>y</code></font>, and <font color="#663333"><code>z</code></font>.&nbsp; Naturally, those two lines of printout are identical.<br>
<br>
In case you're wondering, we <i>could</i> have used <font color="#663300"><code>z(-1)</code></font> as an equivalent to <font color="#663300"><code>y</code></font>, or <font color="#663300"><code>z(-2)</code></font> as <font color="#663300"><code>x</code></font>.&nbsp; For that matter, we could have used this feature to read or write areas of memory in which no 
variables at all had been declared.&nbsp; Or if we had declared 
variables of some other datatype than <font color="#663333"><code>FIXED</code></font>, we could have used this same trick to access them as if they were <font color="#663333"><code>FIXED</code></font>.<br>

<blockquote>
  <font size="-1"><b>Aside:</b> When I originally wrote about the 
example above, it was intended as a warning about XPL/I extensions to 
XPL, since there is no statement in McKeeman that partakes in this 
subscripting sloppiness. But no!&nbsp; Subscripting sloppieness is 
allowed in standard XPL after all.&nbsp; I belatedly I noticed the 
following comment on p. 137 of McKeeman:&nbsp; "Assignments to 
subscripted variables are not checked against the array bounds; thus 
every memory location is accessible through subscripting," although 
admittedly it takes a bit of imagination to claim that this ratifies the
 example given above.&nbsp; More compelling is the source code:&nbsp; 
The central feature of McKeeman is an Appendix containing the entire 
source code for their XPL compiler, <b>XCOM</b>, and if you dig into it deeply enough you do find places where <b>XCOM</b> itself <i>does</i> make casual use of sloppy subscripting.&nbsp; And worse!&nbsp; For example, there is a <font color="#663300"><code>PROCEDURE</code></font> in <b>XCOM</b>, <font color="#663300"><code>ERROR(MSG,SEVERITY)</code></font>, whose purpose is to print error messages.&nbsp; In </font><font size="-1"><font size="-1"><font color="#663300"><code>ERROR</code></font></font>, the parameter <font color="#663300"><code>SEVERITY</code></font> (a scalar) is used with a subscript, <font color="#663300"><code>SEVERITY(-1)</code></font>, in what the authors' comments call "A PORNOGRAPHIC WAY OF OBTAINING THE RETURN ADDRESS [of <font color="#663300"><code>ERROR</code></font>]".&nbsp; Well, the comment is certainly worth a laugh!&nbsp; And the idea behind it was to allow <font color="#663300"><code>ERROR</code></font>
 to print the address at which the error had occurred, which indeed 
makes some sense.&nbsp; I would question its sensibility, however.&nbsp;
 Sense and sensibility don't always go together.</font><br>

</blockquote>
<blockquote><font size="-1"><b>Aside:</b>&nbsp; Incidentally, <a moz-do-not-send="true" href="https://sourceforge.net/projects/xpl-compiler/">Daniel 
Weaver has written an XPL-to-C translator</a>, which as far as I know is
 the
 only existing generally-available standard XPL compiler (prior to the present Virtual AGC 
development effort).&nbsp; 
The first thing anyone suggests to me when this topic is discussed is 
"Why don't you just use it?"&nbsp; The subscripting sloppiness inherent in 
actual usage of XPL/I is one good reason.&nbsp; As you might expect, 
Daniel's translator cannot
 compile the XPL/I example program above.&nbsp; And why in the world 
would anybody expect it to?&nbsp; Here's a fun printout of the very-sensible error messages you get 
if you try to do so:<br>
  </font>
  <blockquote>
    <pre><font size="-1">XPL to C language translator -- version 1.1<br>2    |x(0) = 1;                                                                       |<br>           |<br>*** Error, Identifier is not an array (detected at line 5741 in xcom). ***<br>3    |x(1) = 2;                                                                       |<br>           |<br>*** Error, Identifier is not an array (detected at line 5741 in xcom). ***<br>*** Last previous error was detected on line 2. ***<br>4    |x(2) = 3;                                                                       |<br>           |<br>*** Error, Identifier is not an array (detected at line 5741 in xcom). ***<br>*** Last previous error was detected on line 3. ***<br>5    |output = x(0) || ' ' || x(1) || ' ' || x(2);                                    |<br>                    |<br>*** Error, Identifier is not an array (detected at line 5741 in xcom). ***<br>*** Last previous error was detected on line 4. ***<br>5    |output = x(0) || ' ' || x(1) || ' ' || x(2);                                    |<br>                                   |<br>*** Error, Identifier is not an array (detected at line 5741 in xcom). ***<br>*** Last previous error was detected on line 5. ***<br>5    |output = x(0) || ' ' || x(1) || ' ' || x(2);                                    |<br>                                                 |<br>*** Error, Identifier is not an array (detected at line 5741 in xcom). ***<br>*** Last previous error was detected on line 5. ***<br>6 cards containing 7 statements were compiled.<br>6 errors (0 severe) were detected.<br>The last detected error was on line 5.</font><br></pre>
  </blockquote>
</blockquote>That's just <i>one</i> example of the difficulties.&nbsp; To be fair, I'll admit that it's 
hard to make a full list of all the difficulties of XPL or all of the differences between XPL and XPL/I, because 
neither is McKeeman a full and accurate description of XPL, nor is 
Intermetrics documentation a full description of XPL/I.&nbsp; Nor did 
Intermetrics use the term "XPL/I", simply calling their language "XPL", and 
making it hard to be entirely sure what's supposed to be different between them and what's not.&nbsp; <br>
<br>
By the way, I recognize that it's very dangerous to make claims about what other people <i>haven't</i>
 accomplished, so you have to take it with a grain of salt when I say 
that you're not going to find any existing compiler for Windows, Mac, or
 Linux that can compile and run XPL/I programs.&nbsp; If you find out 
that I don't know what I'm talking about, by all means let me 
know!&nbsp; <br>
<blockquote><font size="-1"><b>Aside:</b> In point of fact, I do know of another XPL/I compiler currently under
 development, though not yet fully ready for use.&nbsp; Indeed, it was a discussion with the author of that compiler, </font><font size="-1"><font size="-1">Don Schmidt, </font>prior to the start of his own work, which motivated me to look into this topic to begin with.</font><br>
</blockquote>
With that said, 
as far as I can tell, if you want to compile
 Intermetrics's HAL/S compiler, you're going to have to rely on a 
newly-written XPL compiler having XPL/I support baked into it from the 
ground up, rather than hoping to somehow tack XPL/I capabilities onto 
some existing XPL compiler.&nbsp; And that's what's discussed below.&nbsp; I call the new compiler <b>XCOM-I</b>, for <b>XCOM</b> (the name of McKeeman's original XPL compiler) and "I" (for "Intermetrics").<br>
<br>
Like Daniel Weaver's XPL translator, and Don Schmidt's compiler in development, <b>XCOM-I</b> is actually an XPL/I-to-C translator, though it is entirely new and is 
not based on Daniel's work nor on any of the original XPL 
compilers. In most cases, <b>XCOM-I</b> should work for standard XPL programs too, but not always.<br>
<blockquote><font size="-1"><b>Aside:</b> And in case you wonder, <b>XCOM-I</b>
 does translate the sample XPL/I program given above to C without error;
 the C program it creates also compiles without errors; and if you run the compiled C 
program you get what you might expect:<br>
  </font>
  
<blockquote>
  <pre><font size="-1">PAGE 1<br><br><br>1 2 3<br>1 2 3</font><br></pre>
</blockquote>

</blockquote>
However ... there's one final complication:&nbsp; Another thing the 
original Intermetrics authors did in the XPL/I source code they wrote 
was to intersperse it (thankfully, sparingly!) with code written in IBM 
System/360 Basic Assembly
 Language (BAL).&nbsp; Alas, <b>XCOM-I</b> cannot translate BAL into 
anything meaningful.&nbsp; But <b>XCOM-I</b> does provide hooks so that you can 
patch in replacement code, written in C, for the embedded BAL 
code.&nbsp; 
Those hooks will be discussed later on.<br>
<h1><a name="compiling"></a>Processing a Program Written in XPL, Using XCOM-I<br>
</h1>
<p>Despite the title of this section, there's actually no difference between how to build and run XPL/I programs than XPL programs.&nbsp; Once you know how to build and run an XPL program, you'll automatically know how to build and run an XPL/I program.  (Oh, there's an extra command-line switch you can use to specify that you really, truly want XPL rather than XPL/I, namely <font color="#663300"><code>--xpl</code></font>, but all it does is to remove some reserved words and runtime-library functions specific to XPL/I, allowing your XPL program to use those words as names of variables or procedures.  Which surprisingly, does turn out to be necessary occasionally.)<br></p>
<p>With that said, the XPL/I source code available to us dwarfs the XPL source code we have for any standard XPL programs we have.&nbsp; Moreover, those XPL/I programs are much larger and more complex than the XPL programs.&nbsp; This means that there are differences in how the source code for the two is organized and maintained.&nbsp; In that sense we find differences in how to deal with the two.&nbsp; That's why I concentrate at first on compiling standard XPL programs, and defer some discussion of XPL/I compilation until later.
</p>

<h2><a name="installation"></a>Installation of XCOM-I<br>
</h2><b>XCOM-I</b> is a program written in the Python 3 language.&nbsp; To install <b>XCOM-I</b> on your system, you simply need to copy <a moz-do-not-send="true" href="https://github.com/virtualagc/virtualagc/tree/XCOM-I/XCOM-I">the folder called "XCOM-I" from the "XCOM-I" branch of the Virtual AGC software repository</a>
 onto your computer, and add that directory to your PATH.&nbsp; Running <b>XCOM-I</b> requires Python 3.7 or later, but I don't think it requires additional 
installation of any Python modules not present in a normal Python 
distribution.&nbsp; <br>
<br>
Compiling the C programs created by running <b>XCOM-I</b> using the 
simplest variation of the instructions given below assumes that the GNU <b>gcc</b> C compiler and the GNU <b>make</b>
 program are also installed on your computer.&nbsp; Using alternatives 
to those is possible, probably easily, and will be briefly discussed, 
but I 
have no way to personally survey every possible combination of 
development tools. <br>
<h2><a name="xpl"></a>Compiling and Running XPL Programs<br>
</h2>
There are several standard XPL programs present in the folder 
XCOM-I/Tests/.&nbsp; It would be a mistake to think any of them are 
user-friendly.&nbsp; But they do illustrate the principles involved.<br>
<blockquote><font size="-1"><b>Aside:</b> You'd also be very mistaken to
 imagine that <b>XCOM-I</b> itself is user-friendly.&nbsp; I fear that there will be a
 lot of work involved before the error messages <b>XCOM-I</b> spits out upon 
occasion can be mistaken for anything <i>other</i> than spit.&nbsp; Until then, try not to make any errors in your XPL programming.</font><br>
</blockquote>

<blockquote><font size="-1"><b>Aside:</b>&nbsp; Throughout this 
discussion, I use the Linux/Mac convention that the symbol '/' is used 
to separate the components of a filename and the path to the folder 
containing it.&nbsp; Windows uses the separator '\' instead, so in some 
places you may find that you need to replace '/' by '\'.</font><br>

</blockquote>
<ul></ul>
<p>For the sake of discussion, suppose we wish to compile and run the sample program called Example-6.18.6.xpl.&nbsp; The first step is to use <b>XCOM-I</b> to translate Example-6.18.6.xpl into C source code:
</p>

<blockquote>
  <pre><font color="#663300">cd XCOM-I<br>XCOM-I.py Tests/Example-6.18.6.xpl<br></font></pre><font color="#663300">
</font></blockquote><font color="#663300">
</font>This will create a sub-folder called Example-6.18.6/ of the current
 working folder, and put all of the files of the C translation into that
 folder.&nbsp; <br>
<blockquote><font size="-1"><b>Aside:</b>&nbsp; XCOM-I.py has various 
allowable command-line options, though none were needed in the 
invocation shown above.&nbsp; You can see a list of XCOM-I.py's 
command-line options with
 the command "</font><code><font size="-1" color="#663300">XCOM-I.py --help</font></code><font size="-1">".</font><br>

</blockquote>
<blockquote>
</blockquote>
I won't bore you with a lengthy description of the C files output by <b>XCOM-I</b>, 
but it might be mildly instructive to glance briefly at a couple of 
them.&nbsp; For this example, the principal outputs are the files 
RANDOM.c and main.c, and here you can see a comparison of the original 
XPL file (left) to the C translation of them (right):<br>
<table align="center" cellspacing="40" cellpadding="2" border="1">
  <tbody>
    <tr>
      <td valign="middle">
        <pre><font color="#663300">/* This is example XPL program 6.18.6 from McKeeman p. 157.<br>   The book only provides PROCEDURE RANDOM, which is transcribed as-is.<br>   The top-level code that exercises RANDOM is new. */<br>   <br>RANDOM:<br>  procedure(range) fixed;<br>    /*  Returns a random integer in the range 0 to range - 1  */<br>    <br>    declare range fixed, rbase fixed initial(1),<br>      rmult literally '671297325';<br>      <br>    rbase = rbase * rmult;<br>    <br>    return shr(shr(rbase, 16) * range, 16);<br>    <br>  end RANDOM;<br><br>declare i;<br><br>do i = 1 to 100;<br>  output = RANDOM(100000);<br>end;<br><br>eof</font><br></pre>
      </td>
      <td valign="top">
        <pre><font color="#663300">/*<br>  File RANDOM.c generated by XCOM-I, 2024-04-16 08:46:47.<br>*/<br><br>#include "runtimeC.h"<br>#include "procedures.h"<br><br>int32_t<br>RANDOM(void)<br>{<br><br>  // rbase = rbase * rmult; (2)<br>  {<br>    int32_t numberRHS = xmultiply(getFIXED(8), 671297325);<br>    putFIXED(8, numberRHS);<br>  }<br>  // return shr(shr(rbase, 16) * range, 16); (3)<br>  return SHR(xmultiply(SHR(getFIXED(8), 16), getFIXED(4)), 16);<br>}<br><br>/*<br>  File main.c generated by XCOM-I, 2024-04-16 08:46:47.<br>  XPL/I source-code file used: Example-6.18.6.xpl.<br>  To build the program from the command line, using defaults:<br>          cd Example-6.18.6/<br>          make<br>  View the Makefile to see different options for the `make`<br>  command above.  To run the program:<br>          Example-6.18.6 [OPTIONS]<br>  Use `Example-6.18.6 --help` to see the available OPTIONS.<br>*/<br><br>#include "runtimeC.h"<br>#include "procedures.h"<br><br>/*<br>  Memory Map:<br>           Address (Hex)        Data Type        Variable<br>           -------------        ---------        --------<br>              0 (000000)        FIXED            I<br>              4 (000004)        FIXED            RANDOMxRANGE<br>              8 (000008)        FIXED            RANDOMxRBASE<br>*/<br><br>int<br>main(int argc, char *argv[])<br>{<br><br>  if (parseCommandLine(argc, argv)) exit(0);<br><br>  // do i = 1 to 100; (0)<br>  {<br>    int32_t from0, to0, by0;<br>    from0 = 1;<br>    to0 = 100;<br>    by0 = 1;<br>    for (putFIXED(0, from0);<br>         getFIXED(0) &lt;= to0;<br>         putFIXED(0, getFIXED(0) + by0)) {<br>      // output = RANDOM(100000); (1)<br>      {<br>        int32_t numberRHS = ( putFIXED(4, 100000), RANDOM() );<br>        string_t stringRHS;<br>        strcpy(stringRHS, fixedToCharacter(numberRHS));<br>        OUTPUT(0, stringRHS);<br>      }<br>    }<br>  } // End of DO for-loop block<br><br>  if (LINE_COUNT)<br>    printf("\n"); // Flush buffer for OUTPUT(0) and OUTPUT(1).<br>  return 0; // Just in case ...<br>}<br></font><br></pre>
      </td>
    </tr>
  </tbody>
</table>
The comparison, I think, is both tantalizing and mysterious.&nbsp; Tantalizing, because you can <i>almost</i> see how it works.&nbsp; And mysterious, because you can't <i>quite</i> see it.&nbsp; But I digress!<br>
<br>
The next step, of course, is to compile the C programs.&nbsp; If your 
setup is like mine, namely a Linux system with <b>gcc</b> as the default C 
compiler, then compilation can be accomplished like this, assuming that you're still in the XCOM-I/ working directory:<font color="#663300"><code></code></font><br>
<font color="#663300"><code></code></font><blockquote><font color="#663300"><code>
make -C Example-6.18.6</code><br>


</font></blockquote><font color="#663300">
</font>This produces an executable program within the Example-6.18.6/ folder that's also called <b>Example-6.18.6</b>.<br>
<br>
But the world being what it is, you most likely <i>don't</i> have a 
setup like mine, so some alterations in the instructions above may be 
needed in your situation.&nbsp; For one thing, your C compiler may not 
be <b>gcc</b>.&nbsp; 
Actually, the default assumption isn't that the compiler is <b>gcc</b>, but 
rather that the shell's environment variable <font color="#663300"><code>CC</code></font> holds the 
name of the compiler.&nbsp; But if that's not true, or if you're not using <b>gcc</b>, then it's a trifle harder to accomplish the compilation.&nbsp; <br>
<blockquote><font size="-1"><b>Note:</b> I've tried to make <b>XCOM-I</b>
 use C that's pretty generic, in order to avoid the very problem of 
being limited in the choice of C compilers.&nbsp; But there are some C 
features used, such as "designated initializers", which I believe aren't
 quite as commonly supported.</font> <br>
</blockquote>
For example, suppose you use <b>clang</b> instead of <b>gcc</b>.&nbsp; Just change the build commands to read:<br>
<blockquote><font color="#663300"><code>cd XCOM-I</code><br>

  <code>
make -C Example-6.18.6 CC=clang</code></font><br>
</blockquote>


Or if you're on Windows — and who isn't, really? — then you'd want to 
add the filename extension ".exe" to your executable.&nbsp; That could be done 
like so:<br>
<blockquote><font color="#663300"><code>cd XCOM-I</code><br>

  <code>
make -C Example-6.18.6 TARGET=Example-6.18.6.exe</code></font><br>
</blockquote>
<blockquote>
  <font size="-1"><b>Aside:</b>&nbsp; The Makefile itself lists other 
possible alterations, any or all of which can be used in combination 
with the others.&nbsp; For example, one thing you may encounter if using
 a compiler other than <b>gcc</b>, or even a different version of <b>gcc</b>,
 is an increased likelihood of seeing compile-time warnings that I don't
 see myself.&nbsp; Even if such warnings don't affect your ability to 
compile and run the software, they may be annoying and hence you might 
like to use compiler switches to turn them off.&nbsp; For example, with <b>clang</b>
 15, I see irritating (and incidentally, incorrect!) warnings about 
"dangling elses".&nbsp; Those warning messages are supposedly (though 
not actually) disabled with:<br>
  </font>
  <blockquote>
    <pre><font size="-1" color="#663300">make -C Example-6.18.6 CC=clang EXTRA="-Wdangling-else"</font></pre>
  </blockquote>
</blockquote>

Finally, you can now run the now-fully-compiled program:<br>
<blockquote>
  <pre><font color="#663300">Example-6.18.6/Example-6.18.6</font></pre>
</blockquote>What this particular sample program does is just to print 
100 random numbers, so that's what should happen.&nbsp; (I say they're 
"random", but the seed for the random-number generator is hard-coded and
 always the same as 1, so you'll get the same 100 numbers every time you
 run the program.)<br>
<blockquote><font size="-1"><b>Aside:</b> Just like <b>XCOM-I</b>, the compiled
 application also has a variety of command-line options that may affect 
how it runs.&nbsp; None of them are really applicable to this particular
 sample program, but you could see them with the command "</font><code></code><code><font size="-1" color="#663300">Example-6.18.6/Example-6.18.6 --help</font></code><font size="-1">".</font><br>
</blockquote>If you want to see a much meatier sample program than <b>Example-6.18.6</b> that's written in standard XPL, you 
can look instead at the <b>ANALYZER</b> program (Tests/ANALYZER.xpl).&nbsp; <br>
<blockquote><font size="-1"><b>Aside:</b>&nbsp; I originally found the source code presented for <b>ANALYZER</b>
 online, and don't actually know if it's precisely the same source code 
as given in McKeeman.&nbsp; At least, not without much more-detailed 
checking than I have any desire to do.&nbsp; I have definitely seen <i>some</i>
 differences from the book, but suspect that the book may have errors 
(gasp!) due to typesetting process.&nbsp; Whether there are differences 
not accounted for by typesetting, I cannot say.</font><br>
</blockquote>
If you have a copy, McKeeman (see Section 7.1, Chapter 10, and Appendix 
6) provides reasonably-detailed operating instructions and theory of 
operation for the program.&nbsp; Basically, <b>ANALYZER</b> is used for 
analyzing a given BNF grammar and printing a report about it.&nbsp; Thus McKeeman recommends <b>ANALYZER</b>
 for 
developing BNF grammars and debugging them.&nbsp; There's an associated 
data file as well, SKELETON.xpl, which contains the BNF description for a
 very simple language (called "SKELETON", of course) that's the basis 
for some of the discussion in the book.&nbsp; The steps for compiling 
and running <b>ANALYZER</b> with SKELETON.bnf as input are just what you'd expect from the discussion earlier:<br>
<blockquote>
  <pre><font color="#663300">cd XCOM-I<br>XCOM-I.py --xpl Tests/ANALYZER.xpl
make -C ANALYZER
ANALYZER/ANALYZER &lt;Tests/SKELETON.bnf<br></font></pre></blockquote>
<blockquote>
</blockquote>
If you're interested, you can compare <a moz-do-not-send="true" href="SKELETON-XCOM-I.pdf">the report on the SKELETON grammar produced by the steps above,</a> versus <a moz-do-not-send="true" href="SKELETON-McKeeman.pdf">the report printed in Figure 7.1.6 of McKeeman</a><a moz-do-not-send="true" href="file:///home/rburkey/git/virtualagc-web/SKELETON-McKeeman.pdf"> in 1969</a>.&nbsp;
 You will notice slight differences between the two, but not (I think) 
anything substantive.&nbsp; Remember that the report printed in the book
 would have been <i>manually</i> typeset, always with the possibility of
 human error, and with editorial decisions having been made to affect 
the aesthetics and publishing cost, possibly to the detriment of literal
 100% accuracy.<br>
<blockquote><font size="-1"><b>Aside:</b> Reducing discussion of <b>ANALYZER</b> to just whether or not it works the same today as it did back in 1970 is doing it a injustice, because <b>ANALYZER</b>
 has interesting capabilities in its own right.&nbsp; If you look at the
 reports I mentioned above, you'll notice that one thing <b>ANALYZER</b> includes in these reports is a large section consisting of XPL <font color="#663300"><code>DECLARE</code></font> statements.&nbsp; These </font><font size="-1"><font size="-1"><font color="#663300"><code>DECLARE</code></font></font>
 statements, if plugged into the template XPL code provided elsewhere in
 McKeeman, are what's needed to create a compiler (written in XPL, of 
course) for the grammar being analyzed.&nbsp; In other words, the title 
of the book (<i>A Compiler Generator</i>) isn't a misnomer.&nbsp;&nbsp; 
This XPL code in the report isn't incredibly useful as-is, because it's 
formatted in a manner that's not immediately compilable.&nbsp; However, 
ANALYZER also allows you to "punch" separate punch-cards that do contain
 immediately-compilable XPL.&nbsp; More on that in a moment.&nbsp; </font><br>
</blockquote>
One of the legacy XPL programs provided for demonstration purposes is 
actually a compiler for the SKELETON language, though calling it a 
"compiler" is a bit of a stretch, since all it does is analyze 
statements in the SKELETON language for correctness, and doesn't produce
 any object code.&nbsp; The idea behind the <b>SKELETON</b> program was 
that since it's such a small program (~300 lines of XPL), it would be 
easy to experiment with.&nbsp; The SKELETON language itself is very 
bare-bones, in that it only has assignment statements in it, and those 
assignment statements have the form <code><font color="#663300">IDENTIFIER</font></code><font color="#663300"><code> = EXPRESSION;</code></font>.&nbsp;
 Identifiers follow the same rules in XPL, except that lower-case 
letters aren't supported.&nbsp; There are no declarations, no arrays, no
 strings, and "expressions" are basically whatever normal arithmetical 
expressions you can form from just identifiers, literal decimal numbers,
 and the tokens <font color="#663300"><code>+</code></font> <font color="#663300"><code>-</code></font> <font color="#663300"><code>*</code></font> <font color="#663300"><code>/</code></font> <font color="#663300"><code>(</code></font> and <font color="#663300"><code>)</code></font>.&nbsp; Anyway, you can compile and run it like so:<br>
<blockquote>
  <pre><font color="#663300">cd XCOM-I<br>XCOM-I.py --xpl Tests/SKELETON.xpl
make -C SKELETON
</font><font color="#663300"><font color="#663300">SKELETON</font>/</font><font color="#663300"><font color="#663300">SKELETON</font></font></pre>
</blockquote>
SKELETON being relatively uninteresting, the Tests/ folder also contains
 a similar but more-complex BNF grammar for XPL itself.&nbsp; Analyzing 
the XPL grammar with <b>ANALYZER</b> is very slightly more complex than analyzing the SKELETON grammar was. That's because the XPL grammar file used as input for <b>ANALYZER</b> contains a directive which the SKELETON grammar did not.&nbsp; The culprit is <font color="#663300"><code>$PUNCH</code></font>, which directs <b>ANALYZER</b>
 to output the XPL code it generates to a "punch device".&nbsp; 
Technically, that means a file has to be "attached" to the punch device,
 or else the data has nowhere to go.&nbsp; But by default <b>ANALYZER</b>
 doesn't attach any file to the punch device.&nbsp; On an IBM 
System/360, this would have been handled by means of separately-provided
 Job Control Language (JCL), and in particular by <font color="#663300"><code>DD</code></font> statements in the JCL.&nbsp; Naturally, we have no JCL in our <b>XCOM-I</b> based system, but the equivalent to JCL would be <b>ANALYZER</b>'s command-line switches. The command-line switches for simulating <font color="#663300"><code>DD</code></font> statements are <font color="#663300"><code>--ddi</code></font> and <font color="#663300"><code>--ddo</code></font>.&nbsp;
 Putting that all together, we can analyze the XPL grammar, with the 
punch device attached to a file called PUNCH.txt, using the following 
command:<br>
<blockquote>
  <pre><font color="#663300">ANALYZER/ANALYZER --ddo=2,PUNCH.txt &lt;Tests/XPL.bnf</font></pre>
</blockquote>
Or since ANALYZER accepts the input grammar it analyzes on "device 0" (attached by default to <font color="#663300"><code>stdin</code></font>, which is why we usually pipe in the input via <font color="#663300"><code>&lt;</code></font>), we could even run it instead as:<br>
<blockquote>
  <pre><font color="#663300">ANALYZER/ANALYZER --ddi=0,Tests/XPL.bnf --ddo=2,PUNCH.txt &lt;Tests/XPL.bnf</font></pre>
</blockquote>

For a <i>still meatier</i> sample program, we can turn to the source code of the original XPL compiler itself, <b>XCOM</b>.&nbsp; <b>XCOM</b> was itself written in XPL, so perhaps we can compile it using <b>XCOM-I</b>.&nbsp; Like <b>ANALYZER</b>, the source code for <b>XCOM</b> is in McKeeman (Appendix 3), but also like <b>ANALYZER</b>, the source code <i>we</i> have is something I found online, and I cannot guarantee it's identical to the book.&nbsp; Having compiled <b>XCOM</b>,
 we'll have the dubious pleasure of being able to use it to compile 
standard XPL programs and produce object code in IBM System/360 machine 
code.&nbsp; <br>
<br>
As usual, we compile <b>XCOM</b> itself like so:<br>
<blockquote>
  <pre><font color="#663300">cd XCOM-I<br>XCOM-I.py --xpl Tests/XCOM.xpl
make -C XCOM
</font></pre>
</blockquote>

But then compiling an XPL program using <b>XCOM</b> involves a little JCL <font color="#663300"><code>DD</code></font>
 trickery, similar to some we saw above: There's an extra file which 
needs to be attached as an input.&nbsp; That's because when <b>XCOM</b> compiles an XPL file, it expects also always to need the source code for something called <font color="#663300"><code>COMPACTIFY</code></font>.&nbsp;
 That happens to be contained in a file called XPL.LIBRARY.xpl, so we 
have to attach that file. Also, XCOM wants to use several "random-access
 files" for storing object code and what not, and we have to attach 
those files.&nbsp; (Refer to <a moz-do-not-send="true" href="#file">the <font color="#663300"><code>FILE</code></font> entry in the section on XPL's built-in library functions</a>.)<br>
<ul>
  <li><font color="#663300"><code>FILE(1)</code></font> — The compiled object code.</li>
  <li><font color="#663300"><code>FILE(2)</code></font> — A scratch file (i.e., temporary working space) for data.</li>
  <li><font color="#663300"><code>FILE(3)</code></font> — A scratch file for strings.</li>
</ul>
<b>XCOM</b> uses a hard-coded constant to determine the record sizes for
 these random-access files, which happens to have the default value of <font color="#663300"><code>DISKBYTES=3600</code></font>.&nbsp; Compiling an XPL program called (say) "<i>Program</i>.xpl" with <b>XCOM</b> could thus look something like this:<br>
<blockquote>
  <pre><font color="#663300">XCOM/XCOM --ddi=0,Tests/</font><font color="#663300"><font color="#663300"><i>Program</i>.xpl</font> --ddi=2,Tests/XPL.LIBRARY.xpl --raf=B,3600</font><font color="#663300"><font color="#663300">,1</font>,<i>Program</i>.obj --raf=B,3600</font><font color="#663300"><font color="#663300">,2</font>,<i>Program</i>.dat --raf=B,3600</font><font color="#663300"><font color="#663300">,3</font>,<i>Program</i>.str</font></pre>
</blockquote>

Just to reiterate, the object code produced by this process will be 
useless to you, since it will consist of IBM System/360 machine 
code.&nbsp; But that doesn't detract from it as a demonstration of <b>XCOM-I</b>.&nbsp; McKeeman provides source code for two sample XPL programs, <b>Example-6.18.1</b> and <b>Example-6.18.2</b>,
 which we duplicate in the Tests/ folder.&nbsp; The former demonstrates 
object-code production, while the latter demonstrates error 
handling.&nbsp; The complete <b>XCOM</b>
 reports for these programs are given in the book as well, so it's
 possible to compare the original reports from McKeeman's <b>XCOM</b>, 
including the interspersed IBM System/360 assembly language produced by 
the compiler, versus the corresponding reports created by our 
newly-compiled <b>XCOM</b>:<br>
<br>
<table align="center" cellspacing="2" cellpadding="2" border="1">
  <tbody>
    <tr>
      <th valign="bottom" align="center">XPL Source-Code File<br>
      </th>
      <th valign="bottom">Compiled by XCOM for <br>
        <i>A Compiler Generator</i> (1970)<br>
      </th>
      <th valign="bottom">Compiled by XCOM-I.py for <br>
The Virtual AGC Project (2024)<br>
      </th>
    </tr>
    <tr>
      <td valign="top">Tests/Example-6.18.1.xpl<br>
      </td>
      <td valign="top" align="center"><a moz-do-not-send="true" href="Example-6.18.1-McKeeman.pdf">Report</a><br>
      </td>
      <td valign="top" align="center"><a moz-do-not-send="true" href="Example-6.18.1-XCOM-I.pdf">Report</a><br>
      </td>
    </tr>
    <tr>
      <td valign="top">Tests/Example-6.18.2.xpl<br>
      </td>
      <td valign="top" align="center"><a moz-do-not-send="true" href="Example-6.18.2-McKeeman.pdf">Report</a><br>
      </td>
      <td valign="top" align="center"><a moz-do-not-send="true" href="Example-6.18.2-XCOM-I.pdf">Report</a><br>
      </td>
    </tr>
  </tbody>
</table>
<br>
Which is all very well and good, but the jackpot will be compilation via <b>XCOM-I</b> of <b>HAL/S-FC</b>, and subsequently being able to successfully run <b>HAL/S-FC</b> afterward.&nbsp; Just as there was a big leap in complexity from being able to compile <b>ANALYZER</b> (~1500 lines of XPL) to being able to compile <b>XCOM</b> (~4200 lines of XPL), there's a much larger leap to being able to compile <b>HAL/S-FC</b> (&gt;30,000 lines of XPL).<br>
<br>
TBD<br>
<h1><a name="xpli"></a>A Primer for Standard XPL and Intermetrics XPL/I</h1>


<p>It is a truth universally acknowledged that there is no satisfactory introductory information available concerning programming in XPL.&nbsp; Or at least, it <i>would</i> be universally acknowledged if anybody had ever heard of XPL and wanted to use it for anything.&nbsp; <br></p>
<p>The best you can do, generally speaking, is to purchase a used copy of McKeeman (i.e., <i>A Compiler Generator</i>).&nbsp; If you do, you'll find a book that's densely packed with information, but that information is the source code for an XPL compiler (written in XPL), lots of BNF descriptions of the language, lots of theory on how to write a compiler-generator program, and very little of direct interest to a programmer who wants to come up to speed quickly on how to write or understand a program written in XPL.  Not to mention the fact — though I <i>am</i> mentioning it! — that some of the most-critical counter-intuitive information is buried in easy-to-miss, easy-to-misunderstand comments made in passing, rather than as big, bold-face warnings. &nbsp; And as a bonus, the book provides an index of almost no use at all to a newby XPL programmer.&nbsp; Besides which, most <i>online</i> information about XPL, in my experience, is a simple abridgement or other rehashing of <i>A Compiler Generator</i>, and adds little extra of value in a tutorial sense, since it's almost never written by anybody actually working with XPL.&nbsp; With that said, you may find some useful online information in a couple of places:<br></p>

<ul>
  <li>&nbsp;<a moz-do-not-send="true" href="https://sourceforge.net/projects/xpl-compiler/">Daniel Weaver provides some documentation (in particular, his xpl.pdf) with his XPL-to-C translator program</a>.</li>
  <li>The <a moz-do-not-send="true" href="https://www.cs.toronto.edu/XPL/ldindex.html">University of Toronto XPL website has a page</a> with a small but useful transcription of some material from <i>A Compiler Generator</i> — albeit with unfortunate HTML formatting that make some of it almost unreadable.</li>
</ul>
<p>And as for Intermetrics XPL/I ... well, from a tutorial perspective, it's orders of magnitude worse.  Perhaps later, non-surviving documentation did a better job.&nbsp; Enough said!
</p>

<p>Taking all of that into account, it might be reasonable to provide a full tutorial here how to write XPL or XPL/I programs.&nbsp; Perhaps I'll do that sometime.&nbsp; It turns out that that's easier said than done, since as you may have noticed, simplification for beginners is not really my personal strong suit.  Which is ironic, considering my strong criticism of <i>A Compiler Generator above</i>!  For now, I'll just cover some of the basics and quirks of the language(s).  Send in suggestions for improvement, if you like; I'm sure I can use them somehow to make the discussion even worse.
</p>
<h2><a name="basics"></a>The Basics</h2>
<h3>Character Set</h3>
<p>The most basic characteristic of a language is the character set in which the language is expressed.&nbsp; Neither McKeeman nor Intermetrics specifies the character set.&nbsp; I've given it a lot of thought, and my conclusion is that the originally-supported character set was:
</p>
<p align="center">&lt;space&gt;<br>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z<br>a b c d e f g h i j k l m n o p q r s t u v w x y z<br>0 1 2 3 4 5 6 7 8 9<br>_ % + - * . / | &amp; = &lt; &gt; # @ $ , ; : ( ) ' " ! ? <br>¢ ¬</p>
<p>You'll notice that several characters common today were not originally supported, including:</p>
<p align="center">` ~ ^ [ ] { }</p>

<p>Contrariwise, there are two characters (¢ and ¬) that don't exist at all in the 7-bit ASCII character set that's the common core for the character sets typically used today when writing software source code.&nbsp; Therefore, when working with <b>XCOM-I</b>, we use the characters ~ and ^ interchangeably with ¬ (but prefer ~).&nbsp; Similarly, we use ` in preference to ¢.&nbsp; These substitutions allow us to completely translate the original XPL or XPL/I source code back-and-forth between the original EBCDIC and ACII without any loss of information, and without insisting that you adopt any specific "locale" like ISO-8859-15 or UTF-8 for your computer that's not optimal for your other (non-XPL'ing) activities.&nbsp; With that said, I <i>hope</i> that you could use ¢ and ¬ in your XPL/I source code, if you insist on doing so, but I do not guarantee it.<br></p>
<blockquote>
  <p><font size="-1"><b>Aside:</b> All previously-existing XPL or XPL/I source code I've found, or HAL/S source code for that matter, has already substituted ~ or ^ for ¬ anyway.  And indeed, some early HAL/S documentation suggests this very substitution.  I suspect that's because some IBM printers at the time printed ~ in place of </font><font size="-1"><font size="-1">¬</font>.  But whatever the explanation, the substitutions I'm suggesting are not exactly daring in their originality.  As far as the </font><font size="-1">¢ symbol is concerned, it's not actually used in active XPL or XPL/I code, as such, but can be used in program comments to toggle various compiler options on and off, or in principle could appear within quoted strings.</font></p>
</blockquote>

<h3>Case Sensitivity</h3>
<p>XPL programs are <i>not</i> case-sensitive, except in so far as the contents of quoted strings are concerned.&nbsp; E.g., lower-case or mixed-case symbols are treated as being identical to their upper-case correspondents, but quoted strings are case-sensitive.
</p>
<h3>Identifiers</h3>
<p>Identifiers cannot begin with a digit, but otherwise consist of any sequence of upper- or lower-case alphanumeric characters, <i>or</i> any of the characters @ _ # $.&nbsp; For example, @_26$8ab# is a legal name for a variable.
</p>
<p>Identifiers cannot exceed 256 characters in length.
</p>
<h3>Datatypes, Declarations, and Literals<br>
</h3>
<p>There are only three basic datatypes:<br></p>
<ul>

  <li><font color="#663333"><code>FIXED</code></font> is a 32-bit signed integer.&nbsp; (Stored as 2's-complement, in big-endian byte order, vs the little-endian byte order used in most personal computers today.)<br></li><li><font color="#663333"><code>CHARACTER</code></font> is a variable-width character string, with a string-length limited to 256 or less.&nbsp; Strings are stored as a 32-bit unsigned integer known as a <i>descriptor</i>, paired with a separate area from 1 to 256 bytes containing the individual characters of the string, encoded in EBCDIC.&nbsp; The descriptor has 8 bits specifying the string length (minus 1) and 24-bits providing the starting memory-address of the character data.</li><li><font color="#663333"><code>BIT(n)</code></font>, where <font color="#663333"><code>n</code></font> is from 1 to 2048, is an <font color="#663333"><code>n</code></font>-bit object.&nbsp; The amount of storage varies by the precision:</li><ul><li><font color="#663333"><code>BIT(1)</code></font> through <font color="#663333"><code>B(8)</code></font> are stored in memory as single bytes.</li><li><font color="#663333"><code>BIT(9)</code></font> through <font color="#663333"><code>BIT(16)</code></font> are stored as 2-byte "half-words".</li><li><font color="#663333"><code>BIT(17)</code></font> through <font color="#663333"><code>BIT(32)</code></font> are stored as 32-bit words.</li>
  <li><font color="#663300"><code>BIT(33)</code></font> through <font color="#663300"><code>BIT(2048)</code></font> are stored similarly to <font color="#663300"><code>CHARACTER</code></font> variables: There's a 32-bit "descriptor", of which 8 bits is the number of bytes needed to store all of the bits, minus 1, and 24 bits area pointer to elsewhere in memory, where the bytes themselves are stored.  Thus, a long <font color="#663300"><code>BIT(n)</code></font> like this uses up 4 bytes for the descriptor, plus ⌊(n+7)/8⌋ bytes (5 for n=33 through 256 for n=2048) for the data. </li>
</ul>
</ul>

<blockquote>
  <p><font size="-1"><b>Aside:</b> The method for storing </font><font size="-1"><font color="#663333"><code>CHARACTER</code></font> data described above leaves no room for 0-length "empty" strings.  But the XPL and XPL/I languages <i>do</i> allow for empty strings; the documentation simply doesn't tell us how to encode the empty strings in memory!  Nor do the memories of individual developers I've consulted provide any clue on the matter.  Thus for empty strings, <b>XCOM-I</b> uses its own custom approach that may not quite match the original implementations. Specifically, <b>XCOM-I</b> uses a string descriptor with a value of 0 to represent an empty string, and does not allocate any additional storage beyond the descriptor in that case.  This isn't ambiguous, by the way, because for technical reasons I won't get into right here, a string descriptor of 0 wouldn't have been valid otherwise in XPL. </font><br></p>
</blockquote>
<ul>

</ul>

<p>The storage formats in memory duplicate those that would have been expected on an IBM System/360 computer, within the limits of my ability to infer what those formats were.&nbsp; While the storage formats are not significant in abstract terms, they'll be seen to be <i>quite</i> significant in dealing with certain aspects of <b>HAL/S-FC</b>'s source code, such as its so-called "virtual memory" system, and indeed I think it would be impossible to run <b>HAL/S-FC</b> unless these underlying IBM 360 storage formats were used.<br></p>You'll notice that there is no floating-point datatype, a fact which will be discussed in some detail later. <br>
<br>

The three basic datatypes can also be incorporated into single-dimension arrays. 
Multi-dimensional arrays are not allowed.&nbsp; There is no maximum 
array length beyond the available memory.&nbsp; Array indices start at 
0.&nbsp; Indices (or "subscripts") are enclosed in parentheses, as in <font color="#663300"><code>A(3)</code></font> or <font color="#663300"><code>B(N)</code></font>.&nbsp; <br>
<blockquote><font size="-1"><b>Aside:</b> It's easy to become confused and to imagine (incorrectly!) that you can treat a <font color="#663333"><code>CHARACTER</code></font> variable (as opposed to an array of <font color="#663333"><code>CHARACTER</code></font>
 variables) as an array itself, in order to access its individual 
characters.&nbsp; You cannot!&nbsp; In fact, the XPL language does not 
provide <i>any</i> syntactical means to access individual characters of a
 string.&nbsp; For that, you must rely on built-in functions provided by
 the runtime library.&nbsp; The most-direct method is to use the <font color="#663300"><code>BYTE</code></font> function, which can either retrieve the EBCDIC numerical encoding of an individual character in a <font color="#663333"><code>CHARACTER</code></font> variable, or else to store a new EBCDIC numerical value at a given position in a <font color="#663333"><code>CHARACTER</code></font> variable.&nbsp; Thus if we had a <font color="#663333"><code>CHARACTER</code></font> variable <font color="#663300"><code>C</code></font> which held the value 'HELLO!', then <font color="#663300"><code>BYTE(C, 3)</code></font> would return 211 (the EBCDIC encoding for the letter 'L'), while the assignment statement "<font color="#663300"><code>BYTE(C, 3) = 198;</code></font>" would change the contents of <font color="#663300"><code>C</code></font>
 to 'HELFO' since 198 is the EBCDIC code for the letter 'F'.&nbsp; That 
sounds cumbersome, since very few of us have memorized the EBCDIC table,
 but it's really not.&nbsp; You generally don't have to look up the 
EBCDIC encoding for anything, because you would actually have programmed
 operations such as this as "<font color="#663300"><code>BYTE(C, 3) = BYTE('F');</code></font>".&nbsp; Another, less-generally-useful method would be to use the built-in <font color="#663300"><code>SUBSTR</code></font> function to retrieve a specific character position as a new <font color="#663300"><code>CHARACTER</code></font> object of length 1.<br></font></blockquote><font size="-1">
    </font>The <font color="#663333"><code>BIT(N)</code></font> datatype is actually quite problematic.&nbsp; It would be reasonable to assume that since <font color="#663333"><code>BIT(N)</code></font>
 seems to represent support for collections of bits, then XPL should 
provide some syntactical sugar for reading the values of these bits or 
modifying them.&nbsp; For <font color="#663333"><code>BIT(1)</code></font> through <font color="#663333"><code>BIT(32)</code></font>, you'd be somewhat correct, in that XPL largely treats these as being interchangeable with integers (i.e., <font color="#663333"><code>FIXED</code></font>), and automatically converts them back and forth between <font color="#663333"><code>FIXED</code></font>.&nbsp; The runtime library's built-in logical-shift-left and logical-shift-right functions (<font color="#663300"><code>SHL</code></font> and <font color="#663300"><code>SHR</code></font>) work just as easily with them as with the <font color="#663333"><code>FIXED</code></font>, as do the logical operators <font color="#663300"><code>&amp;</code></font>, <font color="#663300"><code>|</code></font>, and <font color="#663300"><code>¬</code></font> (<font color="#663300"><code>~</code></font>), and the relational operators <font color="#663300"><code>&lt;</code></font>, <font color="#663300"><code>&gt;</code></font>, <font color="#663300"><code>=</code></font>, <font color="#663300"><code>!=</code></font>, <font color="#663300"><code>&gt;=</code></font>, and <font color="#663300"><code>&lt;=</code></font>.&nbsp; Swell!<br>
<br>
But once you advance to <font color="#663333"><code>BIT(32)</code></font> through <font color="#663333"><code>BIT(2048)</code></font>, you are cruelly disappointed. &nbsp; XPL provides <i>no</i> built-in methods of working with this data, beyond the ability to initialize <font color="#663333"><code>BIT(N)</code></font>
 variables with data when they're declared.&nbsp; (More on that 
later.)&nbsp; As far as actually using this data for anything, there are
 no built-in means to do anything at all with that data.&nbsp; While you
 <i>can</i> manipulate the data by cobbling together various 
runtime-library memory-access functions, McKeeman gives none of the 
technical information about the storage format that would allow you to 
do so, in so far as I was able to discover.<b>&nbsp; </b>What do I mean about cobbling together memory-access functions?&nbsp; Well, suppose that you want to access bit 43 of a <font color="#663300"><code>BIT(86)</code></font> variable called <font color="#663300"><code>B</code></font>.&nbsp; First, you must know where the data for <font color="#663300"><code>B</code></font>
 is located in memory.&nbsp; There's a function that can tell you 
that.&nbsp; Then you must know which byte in that block contains bit 
43.&nbsp; There's no function that tells you that, but if you <i>do</i> 
know it somehow then there's a function that gives you the value of a 
byte at that address.&nbsp; Then you must know which bit in the byte 
corresponds to bit 43.&nbsp; Again, there's no function for that, but if
 you know it, then you can use library functions like <font color="#663300"><code>SHL</code></font> or <font color="#663300"><code>SHR</code></font>, probably in conjunction with a logical operator like <font color="#663300"><code>&amp;</code></font>,
 to isolate the value of that bit.&nbsp; If you wanted to change the 
value of that bit, different but similar awfulness is involved.<br>
<br>
But doing any of that requires that you have intimate knowledge of how such <font color="#663333"><code>BIT</code></font>
 data is packed into memory.&nbsp; It's hard to write unambiguously 
about these matters, but I'll try to do so using the following 
concepts:&nbsp; An <i>n</i>-bit value, when written out in human-readable form has a <i>leftmost</i> bit and a <i>rightmost</i> bit; meanwhile, a block of <i>m</i> bytes in memory has a byte that's at the <i>lowest</i> address, a byte at the <i>highest</i> address, and within each byte has a <i>most-significant</i> bit and a <i>least-significant</i> bit.&nbsp; With those ideas in mind, here's how XPL packs <font color="#663333"><code>BIT</code></font> data into memory:<br>
<ul>
  <li><font color="#663333"><code>BIT(1)</code></font> through <font color="#663333"><code>BIT(32)</code></font>:  The rightmost bit corresponds to the least-significant bit in the byte at the highest address.</li>
  <li><font color="#663333"><code>BIT(32)</code></font> through <font color="#663333"><code>BIT(2048)</code></font>:  The leftmost bit corresponds to the most-significant bit in the byte at the lowest address.</li>
</ul>
Or to put it concisely if ambiguously, short bit strings are right justified, while long bit strings are left justified.<br>
<blockquote><font size="-1"><b>Aside:</b>&nbsp; Since I say that the 
bit-packing is undocumented, what's my justification for claiming that 
what I said just above is true?&nbsp; The short answer is 
trial-and-error!&nbsp; The longer answer is that one of the intermediate
 milestones in trying to get <b>XCOM-I</b> to the point of being able to compile the original source code for <b>HAL/S-FC</b> was first to be able to compile McKeeman's original <b>XCOM</b>
 and run it with a verifiably correct result.&nbsp; But I couldn't get 
it to work!&nbsp; After messing with it for days on end, I eventually 
got the answer in a dream, and then experimented with a couple of 
different bit-packing schemes before finally getting <b>XCOM</b> to run properly.&nbsp; The packing scheme I describe above is the one that worked.</font><br>
</blockquote>
<font size="-1"></font>
<blockquote><font size="-1">
    <b>Aside:</b> If all that wasn't bad enough, there's also a trap waiting for you if you're already used to doing bit manipulations 
with logical operators and shifts in other computer languages.&nbsp; This trap is in the behavior of 
conditional tests in XPL's <font color="#663300"><code>IF</code></font> and <font color="#663300"><code>DO WHILE</code></font> statements.&nbsp; Conditional tests in these statements depend only on the <i>least significant</i> bit; i.e., it as if any conditional test involves an extra "<font color="#663300"><code>&amp; 1</code></font>" operation that you can't see.&nbsp; Thus if you wanted to detect (say) that bit 3 of the <font color="#663300"><code>BIT(5)</code></font> variable <font color="#663300"><code>A</code></font> was set, a statement like "<code><font color="#663300">IF A &amp; 8 THEN ...;</font></code>" wouldn't help you at all, since the implicit </font><font size="-1"> "<font color="#663300"><code>&amp; 1</code></font>" in the conditional would cause the test always to fail!&nbsp; You would instead need to use a shift-right operation, such as </font><font size="-1"><font size="-1">"<code><font color="#663300">IF SHR(A, 3) THEN ...;</font></code>". </font></font><font size="-1"><font size="-1"><br>
    </font></font></blockquote>


But enough of these measly <font color="#663333"><code>BIT</code></font>-based frustrations!<br>
<br>
Variables in general are <i>supposedly</i> strictly typed, and every variable used 
must have an associated declaration statement, though we've already seen
 examples of the casual way XPL/I treats XPL's strict typing with subscripting sloppiness.<br>
<br>
Here are a few examples of declarations of variables, both scalar and array:<br>
<blockquote>
  <pre><font color="#663300">DECLARE F FIXED, C CHARACTER, B BIT(5);<br>DECLARE FS(10) FIXED, CS(10) CHARACTER, BS(10) BIT(5);</font><br></pre>
</blockquote>

These are pretty self-explanatory in most ways, so I won't dissect them 
for you in detail.&nbsp; What's perhaps most confusing is that the three
 arrays declared here (<font color="#663300"><code>FS</code></font>, <font color="#663300"><code>CS</code></font>, and <font color="#663300"><code>BS</code></font>) each have <i>eleven</i>
 elements in them, because the number 10 in their declarations is not 
the number of elements, but rather the highest legal index.&nbsp; As 
mentioned above, indices start at 0, so the total number of elements in 
each is 11. <br>
<br>
There are additional attributes which can be applied to such declarations, of which the most important is probably <code><font color="#663300">INITIAL</font></code>.&nbsp; This attribute allows you to supply an initial value for the variable, such as:<br>
<blockquote>
  <pre><font color="#663300">DECLARE F FIXED INITIAL(22), F2 FIXED INITIAL("22"), F3 FIXED INITIAL("(8) 22");<br>DECLARE C CHARACTER INITIAL('Hello!');<br>DECLARE B BIT(5) INITIAL("(1) 10100");<br>DECLARE FS(10) FIXED INITIAL(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11);</font><br></pre>
</blockquote>
It's important to understand that the initializer has its affect only at
 compile-time, and is not applied at run-time.&nbsp; That means that if 
you declare variables within <font color="#663300"><code>PROCEDURE</code></font>s, they're <i>not reinitialized</i> each time the <font color="#663300"><code>PROCEDURE</code></font> is executed.<br>
<br>
You may have been confused by the initializers shown above for the variables <font color="#663300"><code>F2</code></font>, <font color="#663300"><code>F3</code></font>, and <font color="#663300"><code>B</code></font>,
 since they naively appear to be strings instead of numbers; but the 
naive interpretation is wrong.&nbsp; Which brings up the nature of <i>literals</i> in XPL:<br>
<ul>
  <li><code><font color="#663300">CHARACTER</font></code> literals — i.e., text strings — are enclosed in single-quote (') characters.  If a single-quote itself must appear within the string, you use two single-quotes in succession.  For example: <font color="#663300"><code>'I am the ''king'' of the world!'</code></font>.</li>
  <li>Integer literals for <font color="#663300"><code>FIXED</code></font> or <font color="#663300"><code>BIT(N)</code></font> have one of several forms:</li>
  <ul>
    <li>A sequence of decimal digits is interpreted as a non-negative number in base-10 in the usual way.  Note that a leading minus sign (-) or plus sign (+) is <i>not</i> part of a numeric literal!  In XPL, minus signs are only <i>operators</i>, and thus something like <font color="#663300"><code>-10</code></font> is not a literal for the number -10, but is instead the minus operator followed by the literal for the number 10.  In most cases this is a distinction without significance, because <b>XCOM-I</b> (or the original <b>XCOM</b>) automatically tries to perform all computations that are possible at compile time.  Nevertheless, this distinction does cause some arithmetically-satisfactory expressions to be syntactically illegal in XPL.  For example, the expression <font color="#663300"><code>5 + -5</code></font> isn't legal in XPL.</li>
    <li>A sequence of hexadecimal digits enclosed in double-quote (") characters represents a hexadecimal number.  Spaces are ignored within literals like this, and hence can be added at will for improved human readability.</li>
    <li>If a double-quoted string is preceded (within the quotes) by a parenthesized decimal number, then that number indicates the number of bits represented by each digit.  <b>XCOM-I</b> supports only the following cases:</li>
    <ul>
      <li>"(1) ..." (with digits 0-1 and spaces) is a binary number.</li>
      <li>"(2) ..." (with digits 0-3 and spaces) is a base-4 number.</li>
      <li>"(3) ..." (with digits 0-7 and spaces) is an octal number.</li>
    </ul>
  </ul>
</ul>

These numeric literals are the only syntactical reason that the double-quote character (") appears in XPL source code.<br>
<br>
Another important attribute is <font color="#663300"><code>LITERALLY</code></font>. It's not strictly related to declaration of variables, even though appearing in <font color="#663300"><code>DECLARE</code></font> statements and so it's discussed in the next section instead.<br>
<br>
XPL/I provides a separate kind of statement which can declare arrays, which syntactically differs only in that the keyword <font color="#663300"><code>ARRAY</code></font> is used in place of the keyword <font color="#663300"><code>DECLARE</code></font>, and in that it can only be used for arrays of <font color="#663300"><code>FIXED</code></font> or <font color="#663300"><code>BIT</code></font>, and not for <font color="#663300"><code>CHARACTER</code></font>.<br>
<blockquote><font size="-1"><b>Aside:</b> For the original XPL/I compiler, there was a distinction in the way <font color="#663300"><code>ARRAY</code></font> variables were stored in memory vs <font color="#663300"><code>DECLARE</code></font> variables.&nbsp; At the present time, I don't see this distinction as being operationally significant, so <b>XCOM-I</b>
 treats the two keywords identically.&nbsp; This is subject to change, 
if I discover my thinking was in error.&nbsp; As, unfortunately, I often
 do. </font><br>
</blockquote>

XPL/I adds an additional kind of datatype that it calls a <font color="#663300"><code>BASED</code></font> variable.&nbsp; These are basically <i>pointers</i> to arrays of <font color="#663300"><code>FIXED</code></font>, <font color="#663300"><code>BIT</code></font>, or <font color="#663300"><code>CHARACTER</code></font>.&nbsp; By changing the address stored in the <font color="#663300"><code>BASED</code></font>
 variable's pointer, you can instantly interpret an entirely different 
chunk of memory as the array.&nbsp; Moreover, besides the basic types 
just mentioned, the <font color="#663300"><code>BASED</code></font> variable can point to an array of "records", where each "record" is a collection of the basic 
datatypes.&nbsp; I.e., a record can hold any combination of <font color="#663300"><code>FIXED</code></font>, <font color="#663300"><code>BIT</code></font>, or <font color="#663300"><code>CHARACTER</code></font> fields, or arrays thereof.&nbsp; Using the <font color="#663300"><code>BASED</code></font>
 mechanism, XPL/I can thus mimic both pointers and primitive types of 
structures, neither of which is available in XPL proper.&nbsp; I say 
that the structures are "primitive", because <font color="#663300"><code>BASED</code></font> variables cannot themselves be fields of <font color="#663300"><code>BASED</code></font> variables, hence only structures that are a single-level deep are available.&nbsp; <br>
<br>
Here are a couple of examples of declarations of <font color="#663300"><code>BASED</code></font> variables:<br>
<blockquote>
  <pre><font color="#663300">BASED FB FIXED;<br>BASED RB RECORD:<br>    F FIXED,<br>    C CHARACTER,<br>    A(10) BIT(5),<br>END;</font><br></pre>
</blockquote>

Although <font color="#663300"><code>BASED</code></font> variables are always (or almost always) arrays, you'll note that the declarations of <font color="#663300"><code>FB</code></font> and <font color="#663300"><code>RB</code></font>
 don't indicate any dimensional information.&nbsp; That's because no 
memory for them, other than for the pointer, is allocated at 
compile-time.&nbsp; Space is instead explicitly allocated at runtime by 
user code.&nbsp; Thus <b>XCOM-I</b> has knowledge of the <i>size</i> of each array entry, but not of the <i>number of elements</i> in the array.&nbsp; <br>
<br>
To actually allocate the space at runtime, you have to know the sizes of the array entries, which in this case is 4 bytes for <font color="#663300"><code>FB</code></font> (because the entry is a <font color="#663300"><code>FIXED</code></font>, which is 32 bits long) and 19 bytes for <font color="#663300"><code>RB</code></font> (4 bytes for <code>FIXED</code> field <code>F</code>, 4 bytes for <code>CHARACTER</code> field <code>C</code>, and 11 bytes for the 11-element <code>BIT(5)</code> array <code>A</code>).&nbsp; And yes, you <i>do</i>
 have to explicitly perform this size calculation for yourself, because
XPL/I won't help you do it!&nbsp; Blame Intermetrics for that, not <b>XCOM-I</b>.&nbsp; (At least, as far as I know.)&nbsp; Suppose, for example, that we wanted <font color="#663300"><code>FB</code></font> and <font color="#663300"><code>RB</code></font> to each have 101 elements.&nbsp; The allocation process at runtime involves the XPL/I built-in <font color="#663300"><code>MONITOR</code></font> function.&nbsp; Here's what the XPL/I code looks like:<br>
<blockquote>
  <pre><font color="#663300">CALL MONITOR(6, ADDR(FB), 101 * 4);<br>CALL MONITOR(6, ADDR(RB), 101 * 19);</font><br></pre>
</blockquote>
<blockquote><font size="-1"><b>Aside:</b> <font color="#663300"><code>ADDR</code></font> is an XPL built-in that returns the memory address associated with any identifier or array reference.</font><br>
</blockquote>
There's <a moz-do-not-send="true" href="#builtin">an entire section below devoted to built-in library functions</a> like <font color="#663300"><code>ADDR</code></font>, and <a moz-do-not-send="true" href="#monitor">another section devoted to the <font color="#663300"><code>MONITOR</code></font> function</a>.<br>
<br>
Having allocated the space, you can now use <font color="#663300"><code>FB</code></font> just like any other array of <font color="#663300"><code>FIXED</code></font>, such as in assignments like "<font color="#663300"><code>FB(27) = 6;</code></font>" or "<font color="#663300"><code>X = FB(N) + 12;</code></font>".&nbsp; Accessing <font color="#663300"><code>RB</code></font>,
 on the other hand, uses the dotted style often used these days for 
accessing fields of structures.&nbsp; Some examples include:<br>
<blockquote>
  <pre><font color="#663300">RB(6).F = 12;<br>RB(10).C = 'XPL is where it is at!';<br>RB(20).A(6) = 15;<br>X = RB(6).F;</font><br></pre>
</blockquote>
and so on.<br>
<br>
The <font color="#663300"><code>CALL MONITOR(6, ...)</code></font> statements sampled above allocate space for the <font color="#663300"><code>BASED</code></font> variables from the pool of free memory.&nbsp; There's another possibility with <font color="#663300"><code>BASED</code></font>
 variables, though, and that's to alias them to previously-allocated 
memory, or even to static memory spaces allocated at compile-time by <b>XCOM-I</b>.&nbsp;
 The virtual memory system in <b>HAL/S-FC</b> uses this capability, I believe, 
to swap blocks of data in memory with blocks in random-access 
files.&nbsp; Suppose, for example, that you wanted to alias <font color="#663300"><code>RB</code></font> with the pre-existing array called <font color="#663300"><code>BUFFER</code></font>, rather than allocating any new memory for it.&nbsp; The syntax for that is:<br>
<blockquote>
  <pre><font color="#663300">COREWORD(ADDR(RB)) = ADDR(BUFFER);</font><br></pre>
</blockquote>
<blockquote><font size="-1"><b>Aside:</b> <font color="#663300"><code>COREWORD</code></font> is another XPL built-in, which returns the <font color="#663300"><code>FIXED</code></font> value stored at a given address in memory, or allows modification of that value.<br>
  </font></blockquote>
You may not like this too much.&nbsp; I don't, myself.&nbsp; But I 
reiterate, this is the documented mechanism invented by Intermetrics, 
and used in XPL/I source code like <b>HAL/S-FC</b>.&nbsp; It's not my invention
 or some wacky innovation in <b>XCOM-I</b>.<br>
<h3>LITERALLY and Macros</h3>
TBD<br>
<h3><a name="common"></a>COMMON Memory</h3>
XPL/I also introduces the notion of <font color="#663300"><code>COMMON</code></font> memory, not present in XPL.&nbsp; The notion behind <font color="#663300"><code>COMMON</code></font>
 memory is that a very large application program like <b>HAL/S-FC</b> won't be 
loaded entirely in memory at once, but will instead be run as a sequence
 of "passes".&nbsp; <br>
<br>
Thus, <b>HAL/S-FC</b> isn't a single application program, but rather a set of 
them:&nbsp; PASS1, FLO, OPT, AUX, PASS2, PASS3, and PASS4.&nbsp; Each of
 these applications is loaded, run, and unloaded from memory, in succession.<br>
<br>
But!&nbsp; Each of these application programs may receive some kind of 
input data or state data from the preceding application program, and 
transmit output data or state data to the next application program in 
succession.&nbsp; In XPL/I's visualization, <i>some</i> of that data is 
passed in files.&nbsp; But other of that data is instead just assumed to
 remain in computer memory, unchanged from whatever the preceding 
application has left behind.&nbsp; The term XPL/I applies to this 
leftover memory is <font color="#663300"><code>COMMON</code></font>.&nbsp; It's formalized when you explicitly declare variables as being in <font color="#663300"><code>COMMON</code></font>.&nbsp; Variables declared to be in <font color="#663300"><code>COMMON</code></font>
 are not initialized by an XPL/I program, but are simply assumed to 
already contain the data needed.&nbsp; On the other hand, variables <i>not</i> declared <font color="#663300"><code>COMMON</code></font>
 are up for grabs, and no assumption can be made about their initial 
contents other than whatever initialization their declarations 
explicitly provide.<br>
<br>
Syntactically, <font color="#663300"><code>COMMON</code></font> data is declared in XPL/I by three methods:<br>
<ul>
  <li>Using the keyword <font color="#663300"><code>COMMON</code></font> in place of the keyword <font color="#663300"><code>DECLARE</code></font>.</li>
  <li>Using the keyword-pair <font color="#663300"><code>COMMON ARRAY</code></font> in place of the keyword <font color="#663300"><code>ARRAY</code></font>.</li>
  <li>Using the keyword-pair <font color="#663300"><code>COMMON BASED</code></font> in place of the keyword <font color="#663300"><code>BASED</code></font>.</li>
</ul>
<p>Another distinction is that <font color="#663300"><code>CHARACTER</code></font> variables cannot declared in <font color="#663300"><code>COMMON</code></font>, though <font color="#663300"><code>CHARACTER</code></font> variables can appear as fields in <font color="#663300"><code>COMMON BASED RECORD</code></font> variables.  <b>XCOM-I</b> actually relaxes this restriction.<br></p>
<p>It's not documented anywhere, as far as I know, but I would <i>assume</i> that there was originally an expectation that each cooperating application running in succession needed to declare <font color="#663300"><code>COMMON</code></font> in exactly the same way, using exactly the same ordering of variables and the same datatypes.  <b>XCOM-I</b> relaxes this restriction as well.  <br></p>
<p>Of course, <b>XCOM-I</b> makes no effort at all to pass <font color="#663300"><code>COMMON</code></font> data from one application to another using actual memory.  Rather, each XPL/I application program compiled by <b>XCOM-I</b> optionally (depending on its command-line options) can load a file of data into its <font color="#663300"><code>COMMON</code></font> area, and automatically writes out its <font color="#663300"><code>COMMON</code></font> area into a file upon termination.  By using the <font color="#663300"><code>--commoni</code></font> and <font color="#663300"><code>--commono</code></font> command-line switches of the application, a close degree of control can be exercised over which previously-saved <font color="#663300"><code>COMMON</code></font> blocks, if any, are passed to which application programs.<br></p>
<blockquote>
</blockquote>
<h3><a name="MemoryModel"></a>Memory Model for a Compiled XPL Program<br>
</h3>
<p>The theoretical memory space at runtime for a compiled XPL program is 2<sup>24</sup>=16,777,216 bytes in size, although the Wikipedia article on IBM System/360 tells us that the actual physical maximum was only 8 MB.&nbsp; I presume that for the original XPL and XPL/I compilers, a contiguous partition in this (theoretical) 16 MB space was dedicated to storing just the program's variables, whereas the rest was presumably devoted to the operating system and program's executable code.&nbsp; For XCOM/I, such a partitioning is not necessary, and the entire 16MB space can be used for the compiled program's variables.<br></p>
<p>In <b>XCOM-I</b>, the lowest addresses of memory are filled with static data defined at compile-time:  <font color="#663300"><code>FIXED</code></font> and <font color="#663300"><code>BIT</code></font> variables and arrays, the string-descriptors for <font color="#663300"><code>CHARACTER</code></font> variables and arrays, the pointers for <font color="#663300"><code>BASED</code></font> variables.  None of the allocations in this area change at runtime, though the contents of the variables residing there may change during a run.  Above that static partition we dynamic allocations which may grow or shrink, or even move to other addresses entirely.  In particular, we have all of the string data for <font color="#663300"><code>CHARACTER</code></font> values and any allocations of memory made at runtime (for example, for <font color="#663300"><code>BASED</code></font> variables).  <b>XCOM-I</b> and its runtime library do not use any of this dynamic partition (or indeed any of the simulated memory model at all) for data of their own, so all of it is available for the XPL or XPL/I program. <br></p>

<p>Unfortunately, we have to stick pretty closely to the memory-space behavior as conceived by Intermetrics for it's XPL/I compiler, however poorly documented it may be, and however irrelevant it seems to a "modern" implementation, because <b>HAL/S-FC</b> source code sometimes relies on their hidden knowledge of that behavior.&nbsp; 
</p>
<blockquote>
  
<p><font size="-1"><b>Aside:</b> There are plenty of examples in <b>HAL/S-FC</b> source code where the source code exploits hidden knowledge of the internals of the compiler implementation.&nbsp; Here's one from the <font color="#663333"><code>SCAN</code></font> procedure of <b>HAL/S-FC</b>.&nbsp; In two of its sub-procedures, <font color="#663333"><code>BUILD_BCD</code></font> and <font color="#663333"><code>BUILD_INTERNAL_BCD</code></font>, it builds a string (<font color="#663333"><code>BCD</code></font>), character by character, whose length it does not know in advance.&nbsp; You'd think it could simply repeatedly convert each character to a string, and then use the string-concatenation operator (<font color="#663333"><code>||</code></font>) to append the new string to the old one.&nbsp; But you'd be wrong, since for some reason there's actually no way in XPL or XPL/I to convert  a character to a string.&nbsp; So instead, it:<br></font></p>

  <ul>
    <li><font size="-1">Uses an undocumented trick (namely concatenating a constant string which contains a single character to </font><font size="-1"><font size="-1"><font color="#663333"><code>BCD</code></font></font>), which forces </font><font size="-1"><font size="-1"><font size="-1"><font color="#663333"><code>BCD</code></font></font></font> to be moved to the top of allocated memory, and be followed by free memory.</font></li>
    <li><font size="-1">Uses the <font color="#663300"><code>COREBYTE</code></font> built-in function to write the character to the address just preceding the start of free memory.</font></li>
  </ul>
  
</blockquote>

<p>As mentioned before, variables of the <font color="#663333"><code>FIXED</code></font> and <font color="#663333"><code>BIT</code></font> datatypes, or arrays thereof, have sizes that are set at compile-time, and do not change thereafter.&nbsp; Moreover, the storage for the descriptors for the <font color="#663333"><code>CHARACTER</code></font> datatype and the pointers for the <font color="#663333"><code>BASED</code></font> variables are fixed at compile time as well.&nbsp; <i>However</i>, the character strings associated with the string descriptors for the <font color="#663333"><code>CHARACTER</code></font> variables, and the number of records associated with the <font color="#663333"><code>BASED</code></font> variables, can change during execution of the compiled XPL program, and in particular can increase in size.&nbsp; When the latter happens, it is necessary for such data to be moved into a previously-free area of the 16 MB memory, leaving unused holes in the memory.&nbsp; <br></p>
<p>The holes in memory don't directly cause a problem, but the ever-decreasing range of contiguous free memory at the end of the memory space may cause a problem eventually.&nbsp; The garbage-collection procedure called <font color="#663333"><code>COMPACTIFY</code></font> is called under these circumstances to repack the memory space, correct all pointers into the memory space, and thus increase the range of contiguous free memory.&nbsp; McKeeman (p. 140) lists <font color="#663333"><code>COMPACTIFY</code></font> among the built-in functions of XPL, but in defiance of that, explicitly provides an XPL <font color="#663333"><code>PROCEDURE</code></font> for it, whose source code is required to be included in other XPL programs; in fact, McKeeman's <b>XCOM</b> includes it <i>automatically</i>.&nbsp; Similarly, in the original XPL/I compiler, it was a user function provided by the <b>HAL/S-FC</b> source code file HALINCL/SPACELIB.&nbsp; <b>XCOM-I</b> takes a different approach: It provides its own implementation of <font color="#663333"><code>COMPACTIFY</code></font> in its runtime library, and it is a true built-in written in C rather than in XPL.&nbsp; <font size="-1">
</font></p>
<blockquote>
  <p><font size="-1"><b>Aside:</b>&nbsp; In case you're wondering why we don't simply use the </font><font size="-1"><font color="#663333"><code>COMPACTIFY</code></font> supplied in HALINCL/SPACELIB?&nbsp; It's a good question, which I elect not to answer. </font><br></p>
</blockquote>



<h3>Structure of an XPL Program vs XPL/I<br>
</h3>
<p>An XPL program consists of any sequence of XPL <i>statements</i>, followed by the token <font color="#663333"><code>EOF</code></font>.&nbsp; In particular:<br></p>
<ul>
  <li>Declarations of variables can be intermixed with active statements such as assignments.</li>
  <li>Active code can exist at the global level, outside of any <font color="#663300"><code>PROCEDURE</code></font>s. <br></li>
</ul>

<blockquote>
  <p><font size="-1"><b>Note:</b>&nbsp; The original XPL compiler, which was called XCOM, performed a single pass.&nbsp; It required that the declaration of any particular identifier as an object (such as a variable) had to precede the use of that identifier, although there were provisions for making a forward declaration for a </font><font size="-1"><font color="#663333"><code>PROCEDURE</code></font>, so that the </font><font size="-1"><font color="#663333"><code>PROCEDURE</code></font> could be used before it was defined.&nbsp; <b>XCOM-I</b> relaxes this requirement.<br></font></p></blockquote><font size="-1"></font>
<p>Each of the sample programs I've encountered in standard XPL so far has been contained in a single <i>relatively</i>-small file.  For example, <b>ANALYZER</b> has a little over 1500 lines of source code, while <b>XCOM</b> has a little over 4200 lines.   <br></p>
<p>In contrast, the XPL/I source code for Intermetrics's HAL/S compiler <b>HAL/S-FC</b> has over 120,000 lines of source code spread across over 600 files.  This huge size, along with the huge difference from programs in standard XPL, necessitates different methods for managing that source-code base, and some of those methods are reflected by compiler directives embedded within the source code.  Insofar as <b>HAL/S-FC</b> and its related applications are concerned, the top-level source-code file  (##DRIVER.xpl) for each application always contains all of the necessary directives for compiling the other source-code files needed, in the correct order, so in using XCOM-I to compile these applications you don't need to worry about any file other than ##DRIVER.xpl itself.<br></p>
<blockquote>
  <p><font size="-1"><b>Aside:</b> Due to the lack of relevant Intermetrics documentation, what I'm about to describe is not only speculative on my part, but also represents certain pragmatic compromises that I don't believe literally existed in Intermetrics' XPL compiler or development procedures.  But if it will work for us using <b>XCOM-I</b> on <b>HAL/S-FC</b> and if there are no other lurking XPL/I programs that we need to worry about, why complain?</font><br></p>
</blockquote>
Compiler directives in XPL/I are comments or comment-like constructions 
which aren't documented in McKeeman and have no other obvious 
purpose.&nbsp; The specifics are covered by the subsections below.<br>
<h4>Compiler Directive Type:&nbsp; <font color="#663300"><code>/?<i>c</i> ... XPL/I source code ... ?/</code></font></h4>
This type of compiler directive is a conditional inclusion of source 
code.&nbsp; The particular type of condition is represented by the <font color="#663300"><i><code>c</code></i></font>; the XPL/I source code is included if condition <font color="#663300"><i><code>c</code></i></font>
 is satisfied, and transparently discarded otherwise.&nbsp; There are 4 
possible conditions I'm aware of, represented by 4 possible 
single-letter replacements for <font color="#663300"><i><code>c</code></i></font>:<br>
<ul>
  <li><font color="#663300"><i><code>c</code></i></font> is P:  This condition is that compilation for the Primary Flight Software (PFS) is being performed.  It is satisfied if <b>XCOM-I</b> is run with the <font color="#663300"><code>--pfs</code></font> command-line switch.  (This is the default.)</li>
  <li><font color="#663300"><i><code>c</code></i></font> is B:  This condition is that compilation for the Backup Flight Software (BFS) is being performed.  It is satisfied if <b>XCOM-I</b> is run with the <font color="#663300"><code>--bfs</code></font> command-line switch.  Note that <font color="#663300"><code>--bfs</code></font> and <font color="#663300"><code>--pfs</code></font> are mutually exclusive.</li>
  <li><font color="#663300"><i><code>c</code></i></font> is A:  This condition is satisfied if <b>XCOM-I</b> is run with the <font color="#663300"><code>--condA</code></font> command-line switch, but I don't know what its interpretation is.</li>
  <li><font color="#663300"><i><code>c</code></i></font> is C:  This condition is satisfied if <b>XCOM-I</b> is run with the <font color="#663300"><code>--condC</code></font> command-line switch, but I don't know what its interpretation is.</li>
</ul>
<blockquote>
  <p><font size="-1"><b>Aside:</b> This implies that you don't just compile <b>HAL/S-FC</b>.  Rather, you compile <b>HAL/S-FC</b> <i>twice</i>, once to get a HAL/S compiler for the primary flight software, and once to get a compiler for the backup flight software. I suspect that in the original Intermetrics system, the choice between PFS and BFS was made with options for <b>HAL/S-FC</b> rather than with options for <b>XCOM</b>.  Alas, I don't presently know any way to support it in that way.</font><br></p>
</blockquote>
<h4>Compiler Directive Type:&nbsp; <font color="#663300"><code>/%INCLUDE <i>module</i> %/</code></font></h4>
This type of compiler directive inserts an entire XPL/I source-code file, <i>module</i>.xpl, at the current point.&nbsp; It is used for importing <font color="#663300"><code>COMMON</code></font>-block
 declarations or macros which are used identically by all source-code 
files.&nbsp; By default, the included module is taken from the folder 
../HALINCL/.&nbsp; As far as I know this covers every use in <b>HAL/S-FC</b> source code.&nbsp; However, if necessary, <b>XCOM-I</b> has a command-line option (<font color="#663300"><code>--include=<i>folder</i></code></font>) which can be used to change the folder containing the modules.<br>
<h4>Compiler Directive Type:&nbsp; <font color="#663300"><code>/* ...comment... <i>$%module</i> */</code></font></h4>
This is a variant of the<font color="#663300"><code> /%INCLUDE <i>module</i> ...comment... %/</code></font>
 directive, which acts the same way, and for which my comments are otherwise the same.<br>
<h4>Compiler Directive Type:&nbsp; <font color="#663300"><code>/**MERGE <i>module</i> <i>procedure</i> */</code></font></h4>
This is yet another directive for including an XPL/I source-code file in
 the current XPL/I source-code file, but it differs from the other 
include-directives described above in that instead of importing 
definitions used in common by multiple source-code files, it instead is 
typically used for importing the source code for a single <font color="#663300"><code>PROCEDURE</code></font>.&nbsp; As above, <i>module</i>.xpl is the source-code file to include, while <i>procedure</i> is the name of the <font color="#663300"><code>PROCEDURE</code></font> contained in that file.&nbsp; In point of fact, <b>XCOM-I</b> simply ignores the procedure name.<br>
<blockquote><font size="-1"><b>Aside:</b> Procedure names don't match 
the filenames, usually, because the naming conventions for System/360 
files were severely limited vs identifiers in XPL.&nbsp; Thus the 
filenames were normalized, truncated forms of the procedure names.</font><br>
</blockquote>
Also, <i>module</i>.xpl is expected to be within the same folder as the 
source-code file being compiled; no other folders are searched for it, 
and there are no command-line switches to alter this behavior.<br>
<blockquote>
</blockquote>

<h3>PROCEDUREs, RETURNs, and Their Peculiarities<br>
</h3>
<p>In a view from a height, an XPL program consists of <font color="#663333"><code>PROCEDURE</code></font> definitions and of code that uses those definitions.<br></p>
<p><font color="#663333"><code>PROCEDURE</code></font> definitions in the source code can be nested, to any desired depth. 
</p>
<p>A <font color="#663333"><code>PROCEDURE</code></font> may be invoked in two different ways.&nbsp; If it returns a value via a <font color="#663300"><code>RETURN</code></font> statement, it can be used in an arithmetical expression or a string expression.&nbsp; If it doesn't return a value, or if it does return a value and you simply want to ignore the value, a <font color="#663333"><code>CALL</code></font> statement can be used to invoke the <font color="#663333"><code>PROCEDURE</code></font> but to discard any returned value.<br></p>
<p><b>Important:</b>&nbsp; All variables local to a <font color="#663333"><code>PROCEDURE</code></font> definition retain their values after the <font color="#663333"><code>PROCEDURE</code></font> returns.&nbsp; If the <font color="#663333"><code>PROCEDURE</code></font> is re-executed, those local variables retain the values they previously had in the prior invocation of the <font color="#663333"><code>PROCEDURE</code></font>.&nbsp; The values of those local variables, though retained, are inaccessible to code outside of the <font color="#663333"><code>PROCEDURE</code></font>, because the compiler enforces scopes of variables. (In C code, this would be the same thing as saying that every local variable of every function is automatically declared as <font color="#663333"><code>static</code></font>.)
</p>
<p><b><i>Very</i> important:</b> Any <i>parameter</i>s at the end of the calling list of a <font color="#663333"><code>PROCEDURE</code></font> can be omitted from when calling the <font color="#663333"><code>PROCEDURE</code></font>, and if omitted, they retain the same values as the last time the <font color="#663333"><code>PROCEDURE</code></font> was invoked <i>or</i> the values previously assigned to those parameters from within the <font color="#663333"><code>PROCEDURE</code></font> itself!&nbsp; (In essence, this is like saying that parameters of a <font color="#663333"><code>PROCEDURE</code></font> are not passed to the <font color="#663333"><code>PROCEDURE</code></font>, but rather that they are just aliases for some set of global variables dedicated to the <font color="#663333"><code>PROCEDURE</code></font>.)&nbsp; That's so weird that we need to see an example.&nbsp; Consider the following XPL <font color="#663333"><code>PROCEDURE</code></font> definition, and <font color="#663333"><code>CALL</code></font>s to it:
</p>
<blockquote>
  <pre><font color="#663333">weirdo: <br>procedure(x, y, z);<br>    declare (x, y, z) fixed;		/* Declare x,y,z as integers */<br>    output = x || ' ' || y || ' ' || z; /* Print out x,y,z */<br>    x = 29;<br>    y = y + 1;<br>end weirdo;<br><br>call weirdo(1, 2, 3);<br>call weirdo(4, 5);<br>call weirdo(6);<br>call weirdo();<br>call weirdo;</font><br></pre>
</blockquote>
<p>The five calls successively print out the following:
</p>
<blockquote>
  <pre>1 2 3<br>4 5 3<br>6 6 3<br>29 7 3<br>29 8 3<br></pre>
</blockquote>
<p><font color="#663333"><code>PROCEDURE</code></font>s cannot be recursive, either directly or indirectly.<br></p>
<p>Taking these facts altogether, <b>XCOM-I</b> implements both parameters and local variables of <font color="#663333"><code>PROCEDURE</code></font>s essentially as global variables in they way they are stored:&nbsp; i.e., each parameter and each local variable of each <font color="#663333"><code>PROCEDURE</code></font> has its own <i>static</i> address (in the global memory model), assigned at compile time and unchanging thereafter.&nbsp; The compiler enforces the logical scoping of these variables.<br></p>
<p>Regarding the <font color="#663300"><code>RETURN</code></font> statement, McKeeman explains that it is used to exit from a <font color="#663333"><code>PROCEDURE</code></font> and optionally to return a value.  Furthermore, the calling code can either use that return value or else ignore it.  Which makes perfect sense.  But  as usual, there are some documented and undocumented peculiarities to the <font color="#663300"><code>RETURN</code></font> statement as well:<br></p>
<ul>
  <li>McKeeman explains (p. 146) that calling code can <i>use</i> returned values from <font color="#663300"><code>PROCEDURE</code></font>s even if the <font color="#663300"><code>PROCEDURE</code></font> has no <font color="#663300"><code>RETURN</code></font> statement, or the <font color="#663300"><code>RETURN</code></font> statement specifies no value.  In this case, we are told, the return value is simply some unpredictable value from some unspecified System/360 register.  Which is rotten, of course, but so what?  This is never going to happen, right?  Wrong!  Actual XPL code does this from time to time.  <b>XCOM-I</b>, on the other hand, <i>always</i> returns a value from a <font color="#663300"><code>PROCEDURE</code></font>, whether or not there are any <font color="#663300"><code>RETURN</code></font> statements specifying a return value; the returned value in this case is 0 if <font color="#663300"><code>FIXED</code></font>, a <font color="#663300"><code>BIT</code></font> value of the appropriate width evaluating to 0, or else the empty string for a <font color="#663300"><code>CHARACTER</code></font>.</li>
  <li>McKeeman does not mention that <font color="#663300"><code>RETURN</code></font> statements may exist at the global level, outside of the scope of any procedure, and may return a value when they do.  <b>XCOM-I</b> treats these as exits from the program back to the operating system, with the returned value being the program's exit code.  It thus expects the return value to be a program status code.<br></li>
</ul>
<h3><a name="builtin"></a>Built-In Runtime-Library Functions</h3>
<p>Standard XPL has a variety of so-called "built-ins", comprising runtime-library functions callable from XPL code.  Some of these bullt-ins can appear on either the right-hand or left-hand side of assignments, and some have to be <font color="#663300"><code>CALL</code></font>'d like user-defined <font color="#663300"><code>PROCEDURE</code></font>s. XPL/I has roughly the same built-ins, plus-or-minus a few, mostly (but not entirely) defined to have the same functionality.  The compiler recognizes these built-ins, and there is no need for them to be declared in any way prior to use.  Since these built-ins were mostly written originally in IBM System/360 basic assembly language, the runtime library supplied with XCOM-I has been entirely written in C, without any reference to the original runtime-library source code.<br></p>
<p>The list below is from McKeeman (p. 140-142), with some alterations due to XPL/I, and some hopefully-helpful notes from me.  The parameter descriptions in the list below identify the datatypes of parameters by the following convention:<br></p>
<ul>
  <li><font color="#663300"><code>FIXED</code></font> — <code><font color="#663300">NE</font></code><font color="#663300"><code><sub>x</sub></code></font></li>
  <li><font color="#663300"><code>CHARACTER</code></font> descriptor — <font color="#663300"><code></code><code>DE<sub>x</sub></code></font></li>
  <li>Symbolic name of a variable, with or without a subscript — <font color="#663300"><code></code><code>V</code></font></li>
</ul>
<table align="center" cellspacing="2" cellpadding="2" border="1">
  <tbody>
    <tr>
      <th valign="bottom" align="center">Library Function<br>
      </th>
      <th valign="bottom">Description From Original Documentation<br>
      </th>
      <th valign="bottom">Additional Notes<br>
      </th>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>ABS(NE)</code><code><br>
          </code></font></td>
      <td valign="middle">This function returns the absolute value of <font color="#663300"><code>NE</code></font>.&nbsp;
 (Note: "80000000", the maximum negative number, has no representable 
absolute value and returns "7FFFFFFF", the maximum positive number.)<br>
      </td>
      <td valign="middle">(XPL/I only.)<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>ADDR(V)</code></font></td>
      <td valign="middle">A function with numeric value which is the (at most) 24-bit absolute address of the variable (subscripted or not) <font color="#663300"><code>V</code></font>.&nbsp; Mostly used in conjunction with <font color="#663300"><code>COREWORD</code></font> or <font color="#663300"><code>COREBYTE</code></font>.<br>
      </td>
      <td valign="middle">If the variable has a subscript, then the 
returned address is that of a specific array element, rather than of the
 beginning of the array.&nbsp; For a <font color="#663300"><code>CHARACTER</code></font> or long <code><font color="#663300">BIT</font></code> string (i.e., for <font color="#663300"><code>BIT(33)</code></font> through <font color="#663300"><code>BIT(2048)</code></font> datatypes), the returned address is that of the <i>descriptor</i>
 for the variable, and if you want to find the actual data, you then 
must first fetch the value of the descriptor and then massage it 
further.&nbsp; For XPL/I's <font color="#663300"><code>BASED</code></font> variables (see IR-182-1 p. 13-3), using the unsubscribed name of the variable for <code><font color="#663300">V</font></code><font color="#663300"><code></code></font> will return the address in memory where the pointer to the <font color="#663300"><code>BASED</code></font> variable's data is stored; whereas adding the subscript <font color="#663300"><code>(0)</code></font> to <code><font color="#663300">V</font></code><font color="#663300"><code></code></font> returns the address of the variable's data itself.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>BYTE(DE,NE)<br>
          </code></font></td>
      <td valign="middle">A function with numeric value given by the <font color="#663300"><code>NE</code></font><font size="-1"><sup>th</sup></font> 8 bits of the string described <font color="#663300"><code>DE</code></font>.<br>
      </td>
      <td valign="middle">By "string", McKeeman means either <font color="#663300"><code>CHARACTER</code></font> data or <font color="#663300"><code>BIT</code></font> data.&nbsp; As far as <font color="#663300"><code>BIT</code></font> data is concerned, this function works for any data-width; i.e., for <font color="#663300"><code>BIT(1)</code></font> through <font color="#663300"><code>BIT(2048)</code></font>, and not just for "long" <font color="#663300"><code>BIT</code></font> string.&nbsp; However, there's some difference between how <font color="#663300"><code>CHARACTER</code></font> and <font color="#663300"><code>BIT</code></font> data is treated.&nbsp; <font color="#663300"><code>BIT</code></font> data is retrieved from memory as-is, whereas <font color="#663300"><code>CHARACTER</code></font>
 data is transparently translated between EBCDIC encoding (in memory) vs
 ASCII encoding (for manipulation) by the software.&nbsp; The latter 
behavior is specific to <b>XCOM-I</b>, and wouldn't have been needed by the original <b>XCOM</b>, since back then, all <font color="#663300"><code>CHARACTER</code></font>
 data was encoded in EBCDIC all the time, whether or not it resided in 
"memory".&nbsp; Moreover, if you try to do so, it is possible to fool <b>XCOM-I</b>'s <font color="#663300"><code>BYTE</code></font>
 function into thinking an area of memory is a different datatype than 
it really is, thus defeating the translation mechanism ... so please 
don't try to do that.<br>
        <br>
Note that <font color="#663300"><code>BYTE</code></font> can appear 
either in an expression (such as on the right-hand side of an assignment), in which case it returns a value as just 
described, or else on the left-hand side of an assignment, in which case
 it modifies the value stored in memory.&nbsp; McKeeman recommends not using <font color="#663300"><code>BYTE</code></font> on the left-hand side of an assigment, due to the possibility of unintended consequences.<br>
        <br>
The documentation does not explain what's supposed to happen if <font color="#663300"><code>NE</code><code>&lt;0</code></font> or <font color="#663300"><code>NE</code><code>&gt;=len(</code><code>DE</code><code>)</code></font>.&nbsp; Alas, that's not a theoretical question, because such uses of <font color="#663300"><code>BYTE</code></font> really appear in legacy XPL code.&nbsp; Given the sloppy subscripting accepted by XPL, my guess is that <font color="#663300"><code>BYTE</code></font> just grabs whatever happens to reside wherever <font color="#663300"><code>NE</code></font>
 leads it.&nbsp; Unlike the usual sloppy subscripting in XPL code, this 
would almost certainly be a mistake by the programmer, because the 
location of string data in memory is dynamically assigned and liable to 
change during the course of execution, so the programmer can't really 
know reliable what lies beyond the bounds of a string.&nbsp; Thus my 
guess is that when <font color="#663300"><code>NE</code></font> is out 
of bounds for the string size, it's probably a mistake on the part of 
the program that was never detected because it never produced any error 
messages.<br>
        <blockquote><font size="-1"><b>Aside:</b> For example, it happens in the <font color="#663300"><code>SCAN</code></font> procedure of <b>XCOM</b>, in the vicinity of line 835 at this writing,<br>
          </font>
          <blockquote>
            <pre><font size="-1" color="#663300">CP = 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>DO WHILE BYTE(TEXT, CP) = BYTE(' ') &amp; CP &lt;= TEXT_LIMIT;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>   CP = CP + 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>END;&nbsp;&nbsp;</font><font size="-1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font></pre>
          </blockquote>
          <font size="-1">where <font color="#663300"><code>TEXT</code></font> happens to be a string with <font color="#663300"><code>LEN(TEXT)=1</code></font> containing a single blank space, and <font color="#663300"><code>TEXT_LIMIT=0</code></font>.&nbsp; Here, <font color="#663300"><code>BYTE(TEXT,CP)</code></font> is out of bounds on the very first iteration of the loop.&nbsp; In C, if the operands of the <font color="#663300"><code>&amp;</code></font> operator were reversed, then <font color="#663300"><code>BYTE(TEXT,CP)</code></font> would never be executed, and the problem would be avoided.&nbsp; But <i>if</i>
 that kind of optimization of conditionals is a feature of XPL, it's not
 a feature that's mentioned anywhere to my knowledge, and <b>XCOM-I</b> does not attempt it.</font><br>
        </blockquote>
Whether or not that's a true in interpretation, in <b>XCOM-I</b> the <font color="#663300"><code>BYTE</code></font> function returns a value of 0 (corresponding to an EBCDIC <font color="#663300"><code>NUL</code></font>) if <font color="#663300"><code>NE</code></font> is out of bounds, or else silently does nothing at all if on the left-hand side of an assignment.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>BYTE(DE)<br>
          </code></font></td>
      <td valign="middle">Same as <font color="#663300"><code>BYTE(DE,0)</code></font></td>
      <td valign="middle"><br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>CLOCK_TRAP<br>
          </code></font></td>
      <td valign="middle">Not supported in <b>XCOM</b>.</td>
      <td valign="middle">And it's not supported in <b>XCOM-I</b> either.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>COMPACTIFY<br>
          </code></font></td>
      <td valign="middle">A procedure called automatically to repack the free storage 
area when it is exhausted. Calls can be triggered by <font color="#663300"><code>||</code></font>, <font color="#663300"><code>INPUT</code></font>, number-to-string conversions, or an explicit call:<br>
        <blockquote><font color="#663300"><code>CALL COMPACTIFY;<br>
            </code></font></blockquote>
        <font color="#663300"><code></code></font>The variables <font color="#663300"><code>FREEBASE</code></font>, <font color="#663300"><code>FREELIMIT</code></font>, <font color="#663300"><code>FREEPOINT</code></font>, <font color="#663300"><code>DESCRIPTOR</code></font>, and <font color="#663300"><code>NDESCRIPT</code></font> are used by <font color="#663300"><code>COMPACTIFY</code></font>.<br>
        <font color="#663300"><code></code></font></td>
      <td valign="middle">The "free storage area" is where the data for <font color="#663300"><code>CHARACTER</code></font>, long <font color="#663300"><code>BIT</code></font>, and <font color="#663300"><code>BASED</code></font> variables are stored.<br>
        <br>
        <a moz-do-not-send="true" href="#MemoryModel">See the earlier discussion of this</a>.<br>
        <br>
Actually, not all of the variables mentioned are necessarily meaninful in XCOM-I.&nbsp; <font color="#663300"><code>FREEBASE</code></font> and <font color="#663300"><code>FREELIMIT</code></font> are certainly "used", and <font color="#663300"><code>FREEPOINT</code></font> is certainly altered.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>COREBYTE(NE)<br>
          </code></font></td>
      <td valign="middle">A byte array identical to the IBM System/360 
memory.&nbsp; The subscript is the absolute byte address of the byte 
selected.&nbsp; <font color="#663300"><code>COREBYTE</code></font> may be used on either side of the replacement operator (i.e., <font color="#663300"><code>=</code></font>).<br>
      </td>
      <td valign="middle">The function returns a <font color="#663300"><code>FIXED</code></font>
 value, if used in an expression, but only the least-significant 8 bits 
contain the value.&nbsp; Similarly, if used on the left-hand side of an 
assignment, it receives a <font color="#663300"><code>FIXED</code></font> value from the right-hand side, but only stores the least-significant 8 bits at the specified memory address.&nbsp; The <b>XCOM-I</b> version of this function performs no EBCDIC translation as <font color="#663300"><code>BYTE</code></font> (see above) does, so it does not expect the data in memory to be <font color="#663300"><code>CHARACTER</code></font> data.&nbsp; Whether this will turn out to be an issue remains to be seen.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>COREWORD(NE)<br>
          </code></font></td>
      <td valign="middle">Like <font color="#663300"><code>COREBYTE</code></font>, except the subscript corresponds to the word address in memory.&nbsp; Thus an assignment to <font color="#663300"><code>COREBYTE(4)</code></font> can change <font color="#663300"><code>COREWORD(1)</code></font>.<br>
      </td>
      <td valign="middle">Since XPL has only a 24-bit address space, only the least-significant 3 bytes of the "4-byte word address" <font color="#663300"><code>NE</code></font> are used.&nbsp; According to IR-182-1 (p. 13-3), this function <i>differs</i> in XPL/I as follows:<br>
        <blockquote><font size="-1">According to "<i>A COMPILER GENERATOR</i>", <font color="#663300"><code>NE</code></font> is a word index, or word-aligned address. However, in the Intermetrics version, <font color="#663300"><code>NE</code></font> must be a byte address, and the user must himself guarantee that the lower-most two bits are 0's (full word aligned).</font><br>
        </blockquote>
I <i>think</i> that what's being implied by this cryptic comment is that McKeeman's <font color="#663300"><code>COREWORD</code></font> in XPL worked like this:<br>
        <ul>
          <li><font color="#663300"><code>COREWORD(0)</code></font> consists of <font color="#663300"><code>COREBYTE(0)</code></font> through <font color="#663300"><code>COREBYTE(3)</code></font>.</li>
          <li><font color="#663300"><code>COREWORD(1)</code></font> consists of <font color="#663300"><code>COREBYTE(4)</code></font> through <font color="#663300"><code>COREBYTE(7)</code></font>.</li>
          <li><font color="#663300"><code>COREWORD(2) </code></font>consists of <font color="#663300"><code>COREBYTE(8)</code></font> through <font color="#663300"><code>COREBYTE(11)</code></font>.</li>
          <li>and so on.</li>
        </ul>
        <p>whereas Intermetrics's <font color="#663300"><code>COREWORD</code></font> in XPL/I worked like this:<br></p>
        <ul>
<li><font color="#663300"><code>COREWORD(0)</code></font> consists of <font color="#663300"><code>COREBYTE(0)</code></font> through <font color="#663300"><code>COREBYTE(3)</code></font>.</li>
          <li><font color="#663300"><code>COREWORD(1)</code></font> is illegal.</li>
          <li><font color="#663300"><code>COREWORD(2)</code></font> is illegal.</li>
          <li><font color="#663300"><code>COREWORD(3)</code></font> is illegal.</li>
<li><font color="#663300"><code>COREWORD(4)</code></font> consists of <font color="#663300"><code>COREBYTE(4)</code></font> through <font color="#663300"><code>COREBYTE(7)</code></font>.</li>
          <li><font color="#663300"><code>COREWORD(5)</code></font> is illegal.</li>
          <li><font color="#663300"><code>COREWORD(6)</code></font> is illegal.</li>
          <li><font color="#663300"><code>COREWORD(7)</code></font> is illegal.</li>
<li><font color="#663300"><code>COREWORD(8) </code></font>consists of <font color="#663300"><code>COREBYTE(8)</code></font> through <font color="#663300"><code>COREBYTE(11)</code></font>.</li>
          <li><font color="#663300"><code>COREWORD(9)</code></font> is illegal.</li>
<li>and so on.</li>
        </ul>
        <p>To my way of thinking, McKeeman's description doesn't say what IR-182-1 says it says, and unfortunately, McKeeman's clarification that "an assignment to <font color="#663300"><code>COREBYTE(4)</code></font> can change <font color="#663300"><code>COREWORD(1)</code><font color="#000000">", does not in fact clarify it very much either.<br></font></font></p>
        <p><font color="#663300"><font color="#000000"><b>XCOM-I</b> conforms to the latter (Intermetrics) usage, with the exception that addresses like 1, 2, 3, 5, 6, 7, 9, ... are perfectly fine:  </font></font><font color="#663300"><code>COREWORD(1)</code></font> consists of <font color="#663300"><code>COREBYTE(1)</code></font> through <font color="#663300"><code>COREBYTE(4)</code></font>, and so on.  Which conforms just fine to the description in McKeeman as well, if not necessarily to McKeeman's actual usage.<br></p>
        <blockquote><font size="-1"><b>Aside:</b>&nbsp; In point of fact, </font><font size="-1"><font color="#663300"><code>COREWORD</code></font>
 is not used in any software written in standard XPL that's available to
 me, so I cannot determine empirically which of these choices (if 
either) is correct.&nbsp; If it is somehow discovered later that 
McKeeman's <b>XCOM</b> really does need to behave in the manner Intermetrics claimed that it did, then <b>XCOM-I</b>'s <font color="#663300"><code>--xpl</code></font>
 command-line switch will be extended to select between the two 
behaviors.&nbsp; But I don't intend to waste any effort implementing 
that until/unless I have enough evidence to justify it.&nbsp; For now, 
it's a moot point.</font><br>
        </blockquote>

      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>DATE<br>
          </code></font></td>
      <td valign="middle">A function with the numeric value of the date, coded as<br>
        <blockquote>(day of year) + 1000 * (year - 1900)<br>
        </blockquote>
      </td>
      <td valign="middle">McKeeman doesn't inform us of anything so mundane as the time zone to which this relates.&nbsp; <b>XCOM-I</b> assumes UTC.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>DATE_OF_GENERATION<br>
          </code></font></td>
      <td valign="middle">A word variable initialized with the value of <font color="#663300"><code>DATE</code></font> during compilation of the program being run.<br>
      </td>
      <td valign="middle">See the comments for <font color="#663300"><code>DATE</code></font>.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>DESCRIPTOR(NE)<br>
          </code></font></td>
      <td valign="middle">The description of the <font color="#663300"><code>NE</code></font><font size="-1"><sup>th</sup></font> string as a numeric value.<br>
      </td>
      <td valign="middle">McKeeman's description is puzzling; what does "the <font color="#663300"><code>NE</code></font><font size="-1"><sup>th</sup></font> string" mean?&nbsp; As far as I can tell, this library function is used only by the original McKeeman <font color="#663300"><code>COMPACTIFY</code></font> procedure (see above), and in low-level code of <b>HAL/S-FC</b> (where it magically tells where the boundary between <font color="#663300"><code>COMMON</code></font> and non-<font color="#663300"><code>COMMON</code></font> memory is).&nbsp; This is fortunate, because neither of those uses mean anything whatsoever to us in <b>XCOM-I</b>.&nbsp; I therefore choose not to implement this library function in <b>XCOM-I</b>.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>EXIT</code><code><br>
          </code></font></td>
      <td valign="middle">A procedure<br>
        <blockquote><font color="#663300"><code>CALL EXIT;</code></font><br>
        </blockquote>
which causes an abnormal exit form XPL execution. <br>
      </td>
      <td valign="middle">In fact, <b>XCOM-I</b> models this a C-language <font color="#663300"><code>exit(1)</code></font>.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>FILE(NE<sub>1</sub>,NE<sub>2</sub>)</code><code><br>
          </code></font></td>
      <td valign="middle">An array-valued pseudovariable for manipulation of random-access bulk storage.&nbsp; Examples of its use are<br>
        <blockquote><font color="#663300"><code>DECLARE BUFF(3600) BIT(8);</code><code><br>
            </code><code>BUFF = FILE(I, J);</code><code><br>
            </code><code>FILE(I-1, J) = BUFF;</code></font><br>
        </blockquote>
One record is transferred into or out of the buffer array by the 
assignments shown above.&nbsp; FILE cannot appear on both sides of the 
same assignment.&nbsp; <br>
      </td>
      <td valign="middle"><a name="file"></a>I've actually truncated McKeeman's 
description of <font color="#663300"><code>FILE</code></font>, because it is so long and so much of it is specific to IBM 
System/360, while being quite irrelevant to us.&nbsp; The key facts are 
these:<br>
        <ul>
          <li>"Random access files" may be attached to the running program.&nbsp; <br></li>
          <li>Once attached, they are identified by a "device number" that ranges from 1 to 9.&nbsp; <br></li>
          <li>Each attached random-access file may be for input-only, output-only, or both.&nbsp; <br></li>
          <li>Each of the attached files consists of records of a fixed size.</li>
          <li>Different files may have different record sizes.</li>
          <li>These random-access files, and the associated <font color="#663300"><code>FILE</code></font> operations, are <i>completely distinct</i> from the "sequential files" (numbered 0 through 9) accessed via the <font color="#663300"><code>INPUT</code></font> and <font color="#663300"><code>OUTPUT</code></font> functions (see below).</li>
<li>Record sizes <i>typically</i> do not change during program execution.  (But see the continued comments below.)</li>
        </ul>
By default, no random-access files are attached to programs.&nbsp; 
Originally (back in 1970), they were attached at runtime via Job Control
 Language (JCL) <font color="#663300"><code>DD</code></font> 
cards.&nbsp; But with programs compiled via XCOM-I, files are attached 
at program startup by using the program's command-line switches.&nbsp; 
The relevant switch is <font color="#663300"><code>--raf</code></font>, and multiple instances can be used on the same command line.<br>
        <blockquote><font color="#663300"><code>--raf=<i>I,R,N,F</i></code></font><br>
        </blockquote>
The parameters of the <font color="#663300"><code>--raf</code></font> switch are:<br>
        <ul>
          <li><font color="#663300"><code>I</code></font> is either a literal I (for "input"), a literal O (for "output"), or a literal B (for "both input and output").  Note that for O, an empty file will always be created by the program; for B, if there's an existing file of the specified name, then it will be used, but an empty file will be created otherwise.</li>
          <li><font color="#663300"><code>R</code></font> is the record size associated with the file.  3600 and 7200 are typical values, but not the only ones in use.  They must match the expectations of the program's XPL code for using the data.</li>
          <li><font color="#663300"><code>N</code></font> is the device number, from 1 through 9, to which the file should be attached.</li>
          <li><font color="#663300"><code>F</code></font> is the relative or absolute path to the file.</li>
        </ul>
        
<p>In spite of what I said above, the XPL/I documentation (IR-182-1, p. 13-5) does describe one way to change the record size of a random-access file once the program has begun operation, and that is via a call to <font color="#663300"><code>MONITOR(4,R,N)</code></font> (see below), where <font color="#663300"><code>R</code></font> and <font color="#663300"><code>N</code></font> have the same meanings as for <font color="#663300"><code>--raf</code></font>.  It also tells us that such a call must precede the first use of <font color="#663300"><code>FILE(N)</code></font>.  <b>XCOM-I</b> relaxes this restriction, though it seems that the original restriction should be treated as very good advice to follow.  Note, by the way, that the call to <font color="#663300"><code>MONITOR(4,R,N)</code></font> has no way to distinguish between input files and output files, so its record-size manipulation is applied simultaneously to input file <font color="#663300"><code>N</code></font> and output file <font color="#663300"><code>N</code></font>, if they differ.<br></p>

      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>FREEBASE</code><code><br>
          </code></font></td>
      <td valign="middle">A word variable containing the absolute address of the top of constant strings and thus the bottom of the repackable area.<br>
      </td>
      <td valign="middle">In <b>XCOM-I</b>, this is implemented as a function rather than a variable, and is not directly modifiable by user code.&nbsp; <br>
        <br>
What the description from the original documentation is trying to say is that most kinds of variables — such as <font color="#663300"><code>FIXED</code></font> or <font color="#663300"><code>BIT(1)</code></font> types, or descriptors for <font color="#663300"><code>CHARACTER</code></font> or long <font color="#663300"><code>BIT</code></font>-string types, or arrays thereof, or pointers to <font color="#663300"><code>BASED</code></font>
 variables — are stored in memory at low addresses determined at compile
 time, and remain unchanged in address thereafter.&nbsp; In contrast, 
data for <font color="#663300"><code>CHARACTER</code></font> variables can grow or shrink or move at runtime.&nbsp; <font color="#663300"><code>FREEBASE </code></font>is the boundary between those regions of memory.<br>
        <br>
In <b>XCOM-I</b>, data allocated at runtime via the <font color="#663300"><code>MONITOR(6,...)</code></font> or <font color="#663300"><code>MONITOR(19,...)</code></font> function (see below), sometimes for storing data of for <font color="#663300"><code>BASED</code></font> variables,  also appears above the <font color="#663300"><code>FREEBASE</code></font> boundary.<font color="#663300"><code></code></font></td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>FREELIMIT</code><code><br>
          </code></font></td>
      <td valign="middle">A word variable containing the absolute address of the last usuable byte in the string-data area.<br>
      </td>
      <td valign="middle">In <b>XCOM-I</b>, this is implemented as a function rather than a variable, and always returns 0x1000000.&nbsp; I.e., all memory from <font color="#663300"><code>FREEBASE</code></font> to the end of the 24-bit address space is available for dynamic data.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>FREEPOINT</code><code><br>
          </code></font></td>
      <td valign="middle">A word variable containing the absolute address of the next free byte in the string-data area.&nbsp; When <font color="#663300"><code>FREEPOINT</code></font> passes <font color="#663300"><code>FREELIMIT</code></font>, <font color="#663300"><code>COMPACTIFY</code></font> must be called.<br>
      </td>
      <td valign="middle">In other words, at any given time, only the memory region between <font color="#663300"><code>FREEPOINT</code></font> and <font color="#663300"><code>FREELIMIT</code></font> is available for dynamically-allocating new free memory for <font color="#663300"><code>BASED</code></font> variables or <font color="#663300"><code>CHARACTER</code></font> variables.&nbsp; as the program continues to execute, dynamic memory allocation and subsequent memory-freeing may cause <font color="#663300"><code>FREEPOINT</code></font> to steadily creep upward, and the area from <font color="#663300"><code>FREEBASE</code></font> to <font color="#663300"><code>FREEPOINT</code></font> to become increasingly fully of unusable holes.&nbsp; Eventually, <font color="#663300"><code>COMPACTIFY</code></font> will be <i>automatically</i> called, repacking the data to eliminate the holes, and moving <font color="#663300"><code>FREEPOINT</code></font> downward in memory once again.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>INLINE(NE<sub>1</sub>,...)<br>
          </code></font></td>
      <td valign="middle">Inserts arbitrary IBM System/360 machine code directly into the instruction stream.<br>
      </td>
      <td valign="middle">I've replaced McKeeman's lengthy description 
with a short synopsis, because the applicability of the original 
functionality has change drastically in the 55 years (as of this 
writing) since <i>A Compiler Generator</i> was written.<br>
        <br>
        <b>XCOM-I</b> does <i>not</i> support the originally-described functionality as-is.&nbsp; Instead, you can use <br>
        <blockquote><font color="#663300"><code>CALL INLINE(DE);</code></font><br>
        </blockquote>
to perform the conceptually-similar task of inserting an arbitrary 
string of C-language code directly into the instruction stream.&nbsp; If
 the string contains newline characters (<font color="#663300"><code>'\n'</code></font>), then a single <font color="#663300"><code>INLINE</code></font> can insert multiple lines of C code.&nbsp; (But recall, an XPL string can be no longer than 256 characters.)<br>
        <br>
More-importantly, in <b>XCOM-I</b>, there is also a different mechanism for using legacy <font color="#663300"><code>CALL INLINE</code></font> statements to patch lengthy C-language replacements for the original BAL code represented by the <font color="#663300"><code>INLINE</code></font>s into the instruction stream, while leaving the original XPL/I source code unchanged.&nbsp; <a moz-do-not-send="true" href="#hooks">This important but far from automatic mechanism is the topic of a later section</a>.<br>
        <br>
Thankfully, no available legacy standard XPL program contains any <font color="#663300"><code>CALL INLINE</code></font> statements, so the difficulties presented by them are limited to XPL/I code such as <b>HAL/S-FC</b>.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>INPUT(NE)</code><code><br>
          </code></font></td>
      <td valign="middle">A function with descriptor value specifying the next record on input file <font color="#663300"><code>NE</code></font>.<br>
      </td>
      <td valign="middle">I've truncated McKeeman's rather roundabout description, because I don't find it very informative as-is to more-modern readers.<br>
        <br>
What McKeeman is trying to say is that any given program can have several files attached to it for so-called <i>sequential</i>
 input.&nbsp; You can think of these files as consisting of lines of 
text, and you can read them, one text-line at a time, by using the <font color="#663300"><code>INPUT</code></font> built-in function.&nbsp; For the original McKeeman <b>XCOM</b> (or the Intermetrics version of <b>XCOM</b>), the text in the sequential files would have been encoded in EBCDIC, but for use with <b>XCOM-I</b> they are encoded in ASCII.<br>
        <br>
Because XPL comes from the era and computing environment it did, it 
expects input to be supplied on computer punch cards.&nbsp; As such, it 
expects lines of input to actually be 80 columns wide, even if they need
 to be padded by spaces to do so.&nbsp; Not all XPL programs have 
problems with lines of other lengths have a problem with lines of a 
different length, but some do.&nbsp; Notably, the original <b>XCOM</b> is one of the programs that behaves incorrectly unless it gets its way.&nbsp; Because of that, <b>XCOM-I</b>'s built-in <font color="#663300"><code>INPUT</code></font> function transparently truncates lines to 80 columns or pads them 80 columns as necessary.<br>
        <br>
        <br>
There are up to 9 input files attached to the program, numbered, 0 through 9 — yes, I <i>know</i> that's 10 files, but just keep reading — and you access them via those "device numbers".&nbsp; For example,<br>
        <blockquote><font color="#663300"><code>DECLARE CHARACTER C;</code><code><br>
            </code><code>C = INPUT(5);</code></font><br>
        </blockquote>
reads a single line from sequential file number 5 into the variable <font color="#663300"><code>C</code></font>.<br>
        <blockquote><font size="-1"><b>Important:</b> These "sequential files" and the <font color="#663300"><code>INPUT</code></font> mechanism are completely separate from the "random-access files" described in <font color="#663300"><code>FILE</code></font>'s notes earlier!</font><br>
        </blockquote>
By default, there is a single sequential file attached to the program, though it is attached to <i>both</i> device number 0 and device number 1.&nbsp; The default attached file is <font color="#663300"><code>stdin</code></font>, and thus any text piped into the program via a redirector (<font color="#663300"><code>&lt;</code></font>) on the program's command line will be available on both <font color="#663300"><code>INPUT(0)</code></font> and <font color="#663300"><code>INPUT(1)</code></font>.<br>
        <blockquote><font size="-1"><b>Aside:</b>&nbsp; In case you're wondering, I don't think that the reason two separate devices are associated with <font color="#663300"><code>stdin</code></font> is very deep or interesting.&nbsp; I imagine it's just kind of symmetric to the fact that <font color="#663300"><code>OUTPUT(0)</code></font> and <font color="#663300"><code>OUTPUT(1)</code></font> (see below) are both attached by default to <font color="#663300"><code>stdout</code></font>.&nbsp; In situations like this I'm tempted to quote Emerson</font> <font size="-1">— "a foolish consistency is the hobgoblin of little minds" — but I suspect the decision was pragmatic rather than foolish.</font><br>
        </blockquote>
There's no explanation or obvious provision in the documentation for what happens when an end-of-file is reached, and <b>XCOM-I</b>
 makes no particular provision for it either.&nbsp; I suppose it must 
depend on the particular program.&nbsp; For example, some XPL programs 
assume that a blank line terminates a file.&nbsp; Other programs may 
look for special patterns, such as the string "EOF".&nbsp; <b>XCOM-I</b> returns an empty string for reads past the end of the file.<br>
        <br>
Additional input files can be attached via the program's command-line switch <font color="#663300"><code>--ddi</code></font>:<br>
        <blockquote><font color="#663300"><code>--ddi=<i>N,F</i></code></font><br>
        </blockquote>
Here, <font color="#663300"><code><i>F</i></code></font> is the pathname to the file, and <font color="#663300"><i><code>N</code></i></font>
 is the device number to which it should be attached.&nbsp; By the way, 
if you want to debug your program once it has been translated by <b>XCOM-I</b>
 to C and then the C has been compiled to an exectuable, I've sometimes 
found piping input into the program via a command-line redirector (<font color="#663300"><code>&lt;</code></font>)
 to be somewhat problematic.&nbsp; It's handy in those situations to 
override the default attachment of stdin to device 0 by using <font color="#663300"><code>--ddi=0,<i>F</i></code></font> instead of piping.&nbsp; <br>
        <br>
There is no way to change the attachments once the program is running, although there are <font color="#663300"><code>MONITOR</code></font> calls (see below) which can close attached files at runtime.<br>
        <br>
In XPL/I, there's an additional alternative, in which <i>Partioned Data Set</i> (PDS) files can be attached for use by <font color="#663300"><code>INPUT</code></font>
 instead of sequential files. A PDS is partitioned into sections, each 
with its own 8-character identifying name (right-padded with blanks if 
necessary).&nbsp; An attempted read past the end of a partition returns 
an empty string.<br>
        <br>
Only one partition of the PDS is available via <font color="#663300"><code>INPUT</code></font> at any given time, but <br>
        <blockquote><font color="#663300"><code><i>F</i> = MONITOR(2, <i>N</i>, <i>NAME</i>);</code></font><br>
        </blockquote>
(see below) can be used at any time to switch device <font color="#663300"><code><i>N</i></code></font> to the partition whose name is contained in the string called <font color="#663300"><code><i>NAME</i></code></font>.&nbsp; The value returned, <font color="#663300"><code><i>F</i></code></font>, is 0 if the switch was successful, or 1 if there was no such partition.<br>
        <br>
A PDS is thus similar to a <i>folder</i> of sequential files, with the partition names corresponding to filenames within the folder.&nbsp; <br>
        <br>
By default, no there is no PDS attached to programs.&nbsp; However, a 
PDS can be attached for input via the program's command-line switch <font color="#663300"><code>--pdsi</code></font>:<br>
        <blockquote><font color="#663300"><code>--pdsi=<i>N</i>,<i>F</i></code></font><br>
        </blockquote>
Because of PDS similarity to folders, that's how they're implemented in <b>XCOM-I</b>. So <font color="#663300"><code><i>F</i></code></font> should be the pathname of a folder, and the partitions should be ASCII text files within the folder.&nbsp; <font color="#663300"><code><i>N</i></code></font>,
 of course, is the device number on which the attachment is to be 
made.&nbsp; However, no specific partition is selected for reading until
 the necessary <font color="#663300"><code>MONITOR(2, <i>N</i>, <i>NAME</i>)</code></font> call has been made.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>INPUT</code><code><br>
          </code></font></td>
      <td valign="middle">Same as <font color="#663300"><code>INPUT(0)</code></font><br>
      </td>
      <td valign="middle"><br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>INTERRUPT_TRAP</code><code><br>
          </code></font></td>
      <td valign="middle">Not supported in <b>XCOM</b>.<br>
      </td>
      <td valign="middle">Not supported in <b>XCOM-I</b>.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>LENGTH(DE)</code><code><br>
          </code></font></td>
      <td valign="middle">A function with the numeric value equal to the number of characters in the string denoted by the parameter.<br>
      </td>
      <td valign="middle"><br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>LINE_COUNT</code><code><br>
          </code></font></td>
      <td valign="middle">This function returns the number of lines which have been printed on the SYSPRINT file since the last page eject.<br>
      </td>
      <td valign="middle">(XPL/I only.)&nbsp; "SYSPRINT" refers to <font color="#663300"><code>OUTPUT(0)</code></font> and <font color="#663300"><code>OUTPUT(1)</code></font> (see below).<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>LINK</code><code><br>
          </code></font></td>
      <td valign="middle">This procedure performs the functions necessary to exit the current program phase and pass control to the next phase on the <font color="#663300"><code>PROGRAM DD</code></font> sequence, preserving <font color="#663300"><code>COMMON</code></font> data and any other dynamically allocated space which has not been deallocated.<br>
      </td>
      <td valign="middle">(XPL/I only.)&nbsp; This refers to the notion 
that a sequence of XPL/I programs is being run via Job Control Language 
(JCL), with each program passing data to the next program in 
sequence.&nbsp; However, this <font color="#663300"><code>LINK</code></font> built-in is specific to the original computing environment, and performs no function in <b>XCOM-I</b>, which has a different mechanism sharing data between program passes.&nbsp; <a moz-do-not-send="true" href="#common">Refer to the extensive discussion concerning <font color="#663300"><code>COMMON</code></font> memory</a>.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>MONITOR(NE<sub>1</sub>,...)</code><code><br>
          </code></font></td>
      <td valign="middle">Calls the "submonitor".<br>
      </td>
      <td valign="middle">The "submonitor" is a separate program from 
whatever XPL or XPL/I program is being compiled and run, providing some 
kine of system-specific functionality.&nbsp; In so far as McKeeman is 
concerned, the submonitor's functionality and even it calling sequence 
was unknowable, and thus the McKeeman <b>XCOM</b> system simply discarded all calls to the submonitor.<br>
        <br>
Not so with XPL/I: There is an extensive set of functions provided by the submonitor, and the XPL/I program <b>HAL/S-FC</b> uses them extensively as well, so <b>XCOM-I</b>
 needs to support them.&nbsp; Most (I hope!) but not all submonitor 
functions are known from their descriptions in section 13.3 of 
IR-182-1.&nbsp; Besides which, <b>HAL/S-FC</b> source code contains the source code for <font color="#663300"><code>MONITOR</code></font> (written in IBM 360 Basic Assembly Language), from which additional information can be obtained.<br>
        <br>
Because of the complexity of <font color="#663300"><code>MONITOR</code></font>, <a moz-do-not-send="true" href="#monitor">an entire separate section is devoted to explaining it</a>.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>MONITOR_LINK</code><code><br>
          </code></font></td>
      <td valign="middle">A fixed array which can be used for transmission of information between a program and the submonitor.<br>
      </td>
      <td valign="middle">This is implemented in neither McKeeman <b>XCOM</b> nor in <b>XCOM-I</b>.&nbsp; There are no instances of its use in any available legacy XPL or XPL/I program.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>NDESCRIPT(NE)</code><code><br>
          </code></font></td>
      <td valign="middle">A word variable containing the upper bound in the array <font color="#663300"><code>DESCRIPTOR</code></font> (see above) of the descriptions.<br>
      </td>
      <td valign="middle">In fact, this is a variable used only in McKeeman's <font color="#663300"><code>COMPACTIFY</code></font> (see above).&nbsp; It is not used in any other legacy XPL or XPL/I code, and has no relevance in <b>XCOM-I</b>.&nbsp; It is not implemented.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>OUTPUT(NE)</code><code><br>
          </code></font></td>
      <td valign="middle">This is the analog of <font color="#663300"><code>INPUT</code></font> (see above) but for outputting textual data rather than inputting it.<br>
      </td>
      <td valign="middle">Most of the comments concerning <font color="#663300"><code>INPUT</code></font> (see above) are directly applicable to <font color="#663300"><code>OUTPUT</code></font>, or else are analogous in a very obvious way, so I'll try to confine my remarks to the clear differences between the two.<br>
        <br>
The most common use of <font color="#663300"><code>OUTPUT</code></font> is to "print" to the "SYSPRINT" device.&nbsp; Unlike the original <b>XCOM</b> computing environment, in which SYSPRINT was an actual printer, in <b>XCOM-I</b> SYSPRINT by default refers to <font color="#663300"><code>stdout</code></font>.&nbsp; And by default, <font color="#663300"><code>stdout</code></font> is attached to both <font color="#663300"><code>OUTPUT(0)</code></font> and <font color="#663300"><code>OUTPUT(1)</code></font>. But there are differences between the two!&nbsp; Use of <font color="#663300"><code>OUTPUT(0)</code></font> is simpler, and therefore more common, but <font color="#663300"><code>OUTPUT(1)</code></font> is more flexible.&nbsp; Let's start with <font color="#663300"><code>OUTPUT(0)</code></font>.<br>
        <br>
Output statements via <font color="#663300"><code>OUTPUT(0)</code></font> might look something like this:<br>
        <blockquote><font color="#663300"><code>OUTPUT(0) = 'Hello, world!';</code><code><br>
            </code><code>OUTPUT(0) = 'Hello' || ',' || ' ' || 'world' || '!';</code><code><br>
            </code><code>OUTPUT(0) = 'This is OUTPUT statement number ' || 3;</code><code><br>
            </code><code>OUTPUT(0) = 25;</code></font><br>
        </blockquote>
Thus we can print any character strings or numbers we like, and can concatenate them using the string-concatenation operator (<font color="#663300"><code>||</code></font>), with <b>XCOM-I</b> doing the work of automatically converting numbers to strings where necessary.<br>
        <br>
Each use of <font color="#663300"><code>OUTPUT(0)</code></font> results in another physical line being printed.&nbsp; When printing messages with <font color="#663300"><code>OUTPUT</code></font>,
 since it is expected that the lines are being output to a physical 
printer, the system keeps track of the number of lines being printed, 
and automatically inserts page breaks in the output once a page has been
 filled up.&nbsp; At the tops of pages, a page number and optional 
headings and subheadings are also printed.&nbsp; The headings and 
subheadings, though, are simply whatever has been previously set up, and
 you can't change them or otherwise influence them using <font color="#663300"><code>OUTPUT(0)</code></font>.<br>
        <br>
With <font color="#663300"><code>OUTPUT(1)</code></font>, on the other 
hand, there's quite a bit of additional functionality.&nbsp; For 
example, it isn't necessarily true that each use of <font color="#663300"><code>OUTPUT(1)</code></font> prints another line.&nbsp; The <i>first</i> character of each <font color="#663300"><code>OUTPUT(1)</code></font> isn't directly printed, but instead is a "carriage-control character" (or "ANSI control character"), as follows:<br>
        <ul>
          <li>'<font color="#663300"><code> </code></font>' — Single-space the line and print.  This is the same behavior as <font color="#663300"><code>OUTPUT(0)</code></font>: i.e., any line you print to <font color="#663300"><code>OUTPUT(0)</code></font>, you could instead prefix it with a space character and send it to <font color="#663300"><code>OUTPUT(1)</code></font> instead.</li>
          <li>'<font color="#663300"><code>0</code></font>' — Double-space the line and print.</li>
          <li>'<font color="#663300"><code>-</code></font>' — Triple-space the line and print.</li>
          <li>'<font color="#663300"><code>+</code></font>' — Do <i>not</i> space the line at all, but print.  In other words, prints but doesn't advance to the next line.  It behaves like an ASCII carriage-return character (<font color="#663300"><code>'\r'</code></font>).  For a physical printer back in the day, this would allow you to overprint the line upon the next <font color="#663300"><code>OUTPUT</code></font>.  Unfortunately, for <font color="#663300"><code>stdout</code></font> on most computers, we can't emulate such overprinting in any meaningful way.  Thus in <b>XCOM-I</b>, the behavior is indistinguishable from the "single space and print" behavior.</li>
          <li>'<font color="#663300"><code>1</code></font>' — Form feed.  I.e., advance to the top of the next page, regardless of how many left-over lines remain on the current page.  In <b>XCOM-I</b>, this is accomplished by embedding the ASCII form-feed character (<font color="#663300"><code>'\l'</code></font>) in the output.</li>
          <li>'<font color="#663300"><code>H</code></font>' — Heading line.  This doesn't print anything, but takes the remainder of the line and sets it as the heading for subsequent pages.</li>
          <li>'<font color="#663300"><code>2</code></font>' — Subheading line.  This doesn't print anything, but takes the remainder of the line and sets it as the subheading for subsequent pages.</li>
        </ul>
If you experiment with <font color="#663300"><code>OUTPUT(1)</code></font>, and even to a certain extent with <font color="#663300"><code>OUTPUT(0)</code></font>, you may become very confused, because various things won't work as you expect.&nbsp; Or at least, <i>I</i> was very confused at first.&nbsp; To get past this confusion, you need to grasp the following<br>
        <blockquote><b>Very important point</b>:&nbsp; For the computer 
systems most people are familiar with today, when we print a line of 
text, we expect that line of text to end with an implicit advance to the
 next line; i.e., with a "newline" character, often signified in 
programming languages by <font color="#663300"><code>'\n'</code></font>.&nbsp; Whereas in System/360 (and therefore in XPL or XPL/I), the implicit newline occurs <i>prior</i> to the text being printed by the <font color="#663300"><code>OUTPUT</code></font> command.&nbsp; I.e., today we typically ask ourselves "what happens at the <i>end</i> of the line"", whereas for XPL you need to ask "what happens at the <i>beginning</i> of the line?".<br>
        </blockquote>
Similarly to <font color="#663300"><code>INPUT</code></font>, you can attach additional sequential output files (<font color="#663300"><code><i>F</i></code></font>) on device numbers (<font color="#663300"><code><i>N</i></code></font>),<br>

        <blockquote><font color="#663300"><code>--ddo=<i>N,F</i></code></font><br>
        </blockquote>

Or for Partitioned Data Sets,<br>
        <blockquote><font color="#663300"><code>--pdso=<i>N</i>,<i>F</i></code></font><br>
        </blockquote>
For selecting partitions of a PDS, you don't use the same <font color="#663300"><code>MONITOR</code></font> call as for <font color="#663300"><code>INPUT</code></font>, but instead use: <br>

        <blockquote><font color="#663300"><code><i>F</i> = MONITOR(1, <i>N</i>, <i>NAME</i>);</code></font><br>
        </blockquote>
        <font color="#663300"><code>OUTPUT</code></font> commands 
targets for a PDS don't immediately write data to the physical 
PDS.&nbsp; Rather, the data being output is buffered in memory until the
 <font color="#663300"><code>MONITOR(1, <i>N</i>, <i>NAME</i>)</code></font> call occurs, and the data is then written out to the selected partition in its entirety.&nbsp; The return value (<font color="#663300"><code><i>F</i></code></font>)
 is 0 if the partition is new (i.e., if it didn't previously exist in 
the PDS), while it is 1 if the partion previously existed but has now 
been overwritten with entirely new contents.</td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>OUTPUT</code><code><br>
          </code></font></td>
      <td valign="middle">The same as <font color="#663300"><code>OUTPUT(0)</code></font>.<br>
      </td>
      <td valign="middle"><br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>PARM_FIELD</code><code><br>
          </code></font></td>
      <td valign="middle">This function returns a character string which contains the entire parameter specification coded on the <font color="#663300"><code>PARM=</code></font> option on the <font color="#663300"><code>EXEC</code></font> card.&nbsp; If no <font color="#663300"><code>PARM</code></font> is specified, a null string will be returned.<br>
      </td>
      <td valign="middle">(XPL/I only.)&nbsp; A program of any 
complexity generally has a number of options selectable at 
runtime.&nbsp; For XPL/I programs like <b>HAL/S-FC</b>, the mechanism for selecting such options was originally a Job Control Language (JCL) card such as:<br>
        <blockquote><font color="#663300"><code>PARM='SYTSIZE=1800,REFSIZE=20000,LISTING2,$I,$V,$U,$W'</code></font><br>
        </blockquote>
Thus, <font color="#663300"><code>PARM_FIELD</code><code> </code></font>would have had the value <font color="#663300"><code>'SYTSIZE=1800,REFSIZE=20000,LISTING2,$I,$V,$U,$W'</code></font> in such a case.<br>
        <br>
In <b>XCOM-I</b>, <font color="#663300"><code>PARM_FIELD</code></font> 
is implemented as a function rather than a variable, but nevertheless 
returns data of the kind described.&nbsp; Of course, there is no JCL 
supplying such parameters, but the compiled program nevertheless has a 
command-line option that does the same job:<br>
        <blockquote><font color="#663300"><code>--parm='SYTSIZE=1800,REFSIZE=20000,LISTING2,$I,$V,$U,$W'<br>
</code></font></blockquote>
        <blockquote><b><font color="#663300"><code></code></font></b><font size="-1"><b>Aside:</b>
 Depending on your operating system, some trickery may be involved in 
correctly forming such a command-line option.&nbsp; In Linux or (I 
suppose) Mac OS, the command shell expects the dollar sign (<font color="#663300"><code>$</code></font>)
 to indicate that the value of an environment variable is desired.&nbsp;
 In other words, if the string in the command-line option shown above 
had no quotes, then (for example) <font color="#663300"><code>$I</code></font> would be replaced by the value of the environment-variable <font color="#663300"><code>I</code></font>
 ... probably a blank!&nbsp; And the same thing would happen if the 
option were enclosed in double-quotes.&nbsp; But by using single-quotes,
 we defeat that substitution, and <font color="#663300"><code>$I</code></font> is reported in </font><font size="-1"><font color="#663300"><code>PARM_FIELD</code></font> literally as <font color="#663300"><code>$I</code></font>.&nbsp; Alternate tricks to defeating substitution could include using the backslash (<font color="#663300"><code>'\'</code></font>) escape character in front of all dollar signs (<font color="#663300"><code>$</code></font>).&nbsp; <br>
            <br>
            <b>Aside:</b> It has been decades since I used Windows in 
any serious way, so I don't really know whether there's any similar 
problem with it.&nbsp; Probably not.</font><br>
        </blockquote>
        <font color="#663300"><code></code></font></td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>SET_LINELIM(NE)</code><code><br>
          </code></font></td>
      <td valign="middle">This procedure establishes the number of lines
 which will be printed on the SYSPRINT file before an automatic page 
eject and header line will be printed.<br>
      </td>
      <td valign="middle">(XPL/I only.)&nbsp; See <font color="#663300"><code>OUTPUT(NE)</code></font>.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>SHL(NE<sub>1</sub>,NE<sub>2</sub>)</code><code><br>
          </code></font></td>
      <td valign="middle">A function with the numeric value given by shifting the value of <font color="#663300"><code>NE<sub>1</sub></code></font> left (logical shift, zeroes appear in the least significant bit position) the number of positions indicated by the value of <font color="#663300"><code>NE<sub>2</sub></code></font>.<br>
      </td>
      <td valign="middle">One point I found confusing for quite a while is that you'd suppose that logical shifts would operate on <font color="#663300"><code>BIT</code></font> variables, and particularly on long-<font color="#663300"><code>BIT</code></font> variables, for which XPL provides no conveniences at all for accessing individual bits.&nbsp; Not so!&nbsp; <font color="#663300"><code>SHL</code></font> operates only on <font color="#663300"><code>FIXED</code></font> values, and can only shift by up to 32 positions.&nbsp; <font color="#663300"><code>BIT</code></font> variables are converted to <font color="#663300"><code>FIXED</code></font> if shift operations on them are needed.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>SHR(</code></font><font color="#663300"><code><font color="#663300"><code>NE<sub>1</sub>,NE<sub>2</sub></code></font>)</code><code><br>
          </code></font></td>
      <td valign="middle">Logical shift right.&nbsp; <font color="#663300"><code>SHL</code></font> and <font color="#663300"><code>SHR</code></font> are used in conjunction with <font color="#663300"><code>&amp;</code></font>, <font color="#663300"><code>|</code></font>, and <font color="#663300"><code>¬</code></font> for masking and data packing.<br>
      </td>
      <td valign="middle">But recall that it is preferable to use <font color="#663300"><code>~</code></font> rather than <font color="#663300"><code>¬</code></font> with <b>XCOM-I</b>. </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>STRING(NE)</code><code><br>
          </code></font></td>
      <td valign="middle">This function transforms the variable <font color="#663300"><code>NE</code></font> (which should be <font color="#663300"><code>FIXED</code></font> for proper usage) into a <font color="#663300"><code>CHARACTER</code></font> descriptor.&nbsp; <font color="#663300"><code>NE</code></font> should have the form:<br>
        <br>
        <table align="center" cellspacing="2" cellpadding="2" border="1">
          <tbody>
            <tr>
              <th valign="middle" align="center">Length - 1<br>
              </th>
              <th valign="middle" align="center">&nbsp;Data Address<br>
              </th>
            </tr>
            <tr>
              <td valign="middle" align="center">8 bits<br>
              </td>
              <td valign="middle" align="center">24 bits<br>
              </td>
            </tr>
          </tbody>
        </table>
        <br>
      </td>
      <td valign="middle">(XPL/I only.) In spite of the confusing 
description, which I took from IR-182-1 p. 13-4, I don't think there's 
any actual "transformation" going on here.&nbsp; I think that what it's 
trying to say is that if you have a <font color="#663300"><code>FIXED</code></font> variable <font color="#663300"><code>NE</code></font> which happens to contain this 8+24 bits style of descriptor information, then you can syntactically use <font color="#663300"><code>STRING(NE)</code></font> in any context where you would normally use a <font color="#663300"><code>CHARACTER</code></font> value, <i>without</i> any kind of conversion needed at compile-time by <b>XCOM-I</b> or at runtime by the compiled program.&nbsp; In C-language terms, it's a "cast" similar to <font color="#663300"><code>(char *) NE</code></font>.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>STRING_GT(DE<sub>1</sub>,DE<sub>2</sub>)</code><code><br>
          </code></font></td>
      <td valign="middle">This function returns a <font color="#663300"><code>TRUE</code></font> value if the contents of string <font color="#663300"><code>DE<sub>1</sub></code></font> is greater than the contents of string <font color="#663300"><code>DE<sub>2</sub></code></font>, based on the collating sequence of the characters, irrespective of the lengths of <font color="#663300"><code>DE<sub>1</sub></code></font> and <font color="#663300"><code>DE<sub>2</sub></code></font>. Otherwise, the value is <font color="#663300"><code>FALSE</code></font>. This is functionally equivalent to padding the shorter of <font color="#663300"><code>DE<sub>1</sub></code></font> or <font color="#663300"><code>DE<sub>2</sub></code></font> with blanks and then comparing the strings.<br>
      </td>
      <td valign="middle">(XPL/I only.)&nbsp; If this seems confusing, it may be helpful to recall that when the XPL relational operators <font color="#663300"><code>&lt;</code></font>, <font color="#663300"><code>&gt;</code></font>, <font color="#663300"><code>&lt;=</code></font>, and <font color="#663300"><code>&gt;=</code></font> compare two <font color="#663300"><code>CHARACTER</code></font>
 values, they look first at the lengths of the values, and only if the 
lengths are equal do they compare the actual character data.&nbsp; For 
example,<br>
        <blockquote><font color="#663300"><code>'ZZZ' &lt; 'AAAA'</code></font><br>
        </blockquote>
because <font color="#663300"><code>'ZZZ'</code></font> has only 3 characters, while <font color="#663300"><code>'AAAA'</code></font> has 4.&nbsp; Presumably <font color="#663300"><code>STRING_GT</code></font> was introduced because somebody at Intermetrics didn't think that kind of behavior was great, and thus <font color="#663300"><code>STRING_GT('ZZZ', 'AAAA')</code></font> will report instead that <font color="#663300"><code>'ZZZ'</code></font> is greater than <font color="#663300"><code>'AAAA'</code></font>.<br>
        <br>
The collating sequence in either case is EBCDIC rather than the 
more-usual ASCII.&nbsp; The primary visually-obvious consequence of this
 is that digits come after letters rather than before them.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>SUBSTR(DE,NE<sub>1</sub>,NE<sub>2</sub>)</code><code><br>
          </code></font></td>
      <td valign="middle">A function with descriptor value specifying the substring of the string specified by <font color="#663300"><code>DE</code></font>, starting at position with <font color="#663300"><code>NE<sub>1</sub></code></font> with length <font color="#663300"><code>NE<sub>2</sub></code></font>.<br>
      </td>
      <td valign="middle">I.e., it allocates and returns a new string created by taking a substring of length <font color="#663300"><code>NE<sub>2</sub></code></font>, starting at position <font color="#663300"><code>NE<sub>1</sub></code></font> in string <font color="#663300"><code>DE</code></font>.<sub><code></code></sub><sub><code></code></sub><font color="#663300"><code></code></font> </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>SUBSTR(DE,NE)</code><code><br>
          </code></font></td>
      <td valign="middle">Like the above except that all characters from <font color="#663300"><code>NE</code></font> to the end of the string are taken.<br>
      </td>
      <td valign="middle"><br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>TIME</code><code><br>
          </code></font></td>
      <td valign="middle">A function with numeric value given by the time-of-day coded as centiseconds since midnight.<br>
      </td>
      <td valign="middle">McKeeman does not specify the time zone.&nbsp; <b>XCOM-I</b> uses UTC.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>TIME_OF_GENERATION<br>
          </code></font></td>
      <td valign="middle">A word variable initialized with the value of <font color="#663300"><code>TIME</code></font> during compilation of the program.<br>
      </td>
      <td valign="middle"><font color="#663300"><code>TIME</code></font> (see above) isn't literally available during compilation.&nbsp; Moreover, <b>XCOM-I</b>
 implements this as a function rather than as a variable, which should 
be transparent to the programmer.&nbsp; But the function does return a 
value consistent with <font color="#663300"><code>TIME</code></font>.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>TRACE<br>
          </code></font></td>
      <td valign="middle">A procedure,<br>
        <blockquote><font color="#663300"><code>CALL TRACE;</code></font><br>
        </blockquote>
which causes activation of the instruction-by-instruction trace at runtime.<br>
      </td>
      <td valign="middle">This is described in quite a lot of detail in 
McKeeman's Appendix 2.&nbsp; At present, it is accepted during 
compilation but does nothing at runtime in code generated by <b>XCOM-I</b>.<br>
      </td>
    </tr>
    <tr>
      <td valign="middle" align="center"><font color="#663300"><code>UNTRACE<br>
          </code></font></td>
      <td valign="middle">A procedure,<br>
        <blockquote><font color="#663300"><code>CALL UNTRACE;</code></font><br>
        </blockquote>
which turns off run-time trace.<br>
      </td>
      <td valign="middle">See <font color="#663300"><code>TRACE</code></font>.<br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<h3><a name="monitor"></a>The MONITOR Built-In Runtime-Library Function</h3>
<p>As mentioned before, an XPL/I program obtained various services outside what the XPL/I language proper or runtime library could provide, by instead making requests to the separate "submonitor" program.  The mechanism was a call of the <font color="#663300"><code>MONITOR</code></font> procedure.  For <b>XCOM-I</b>, on the other hand, there is no separate submonitor program, and we may as well think of <font color="#663300"><code>MONITOR</code></font> as being just another built-in runtime-library function.  Well, not just <i>any</i> runtime-library function.  A big difference is that it provides a very large number of functions, each one of which can require its own unique syntax, thus necessitating a somewhat more-flexible discussion of how to use it.</p>
<p>The only uniform feature among the many aspects of <font color="#663300"><code>MONITOR</code></font> usage is that each separate function it provides is identified by a number, and such a function number is passed to <font color="#663300"><code>MONITOR</code></font> as its first parameter.  My explanations in the table below are mostly pulled from Chapter 13 of IR-182-1, and then altered according to my understanding (or lack thereof).  Functions 24 through 32 are deduced, poorly, from the <b>HAL/S-FC</b> BAL source-code file for the submonitor program (which happens to be called "MONITOR").<br></p>
<p>A number of the <font color="#663300"><code>MONITOR(...)</code></font> functions work with what's called "IBM hexadecimal floating-point" format, and specifically to the 64-bit (double-precision) version of that format, as opposed to the 32-bit (single-precision) version of it. To make the discussion more concise, I'll just refer to it as "DP floating point".  <br></p>
<p>To be perfectly clear, there is <i>no</i> floating-point datatype in XPL/I, there are no floating-point literal constants, and there is no provision whatever to make it convenient for you (the programmer!) to hard-code such constants into your XPL source code, nor to interpret any such hexadecimal constant you find within legacy source code.  Rather, you must somehow obtain the hexadecimal equivalents for whatever floating-point constants you wish to use, and then hard-code those hexadecimals into your code.  For your convenience — or more accurately, for <i>mine</i> — I've included a little utility called ibmHex.py that you can use to convert back-and-forth between human-readable floating-point numbers and DP floating point.  Just run <font color="#663300"><code>ibmHex.py --help</code></font> for instructions.  This little utility can either be run in a stand-alone fashion, or else <font color="#663300"><code>import</code></font>ed as a Python module.  But I digress!<br></p>
<p>To understand DP floating point, imagine 8 groups of 8 bits each:<br></p>
<blockquote>
  <pre><font color="#663300">SEEEEEEE FFFFFFFF FFFFFFFF ... FFFFFFFF</font></pre>
</blockquote>
<p>where <font color="#663300"><code>S</code></font> is the sign, <font color="#663300"><code>E</code></font> is the exponent, and <font color="#663300"><code>F</code></font> is the fraction.  (SP floating point is the same, but with 3 <font color="#663300"><code>FFFFFFFF</code></font>-groups rather than 7 of them.)  The exponent is a power of 16, biased by 64, and thus represents 16<sup>-64</sup> through 16<sup>63</sup>.  The fraction is an unsigned number, of which the leftmost bit represents 1/2, the next bit represents 1/4, and so on.  As a special case, 0 is encoded as all zeroes.<br><br>For example, the 64-bit hexadecimal pair 0x42640000 0x00000000 parses as:<br></p>
<ul>
  <li>Sign = 0 (i.e., positive)</li>
  <li>Exponent = 16<sup>0x42-0x40</sup> = 16<sup>2</sup> = 2<sup>8</sup>.</li>
  <li>Fraction = 0.0110 0100 ...</li>
</ul>
<p>or in total, 1100100 (binary), or 100 decimal.</p>
<table align="center" cellspacing="2" cellpadding="2" border="1">

  <tbody>
    <tr>
      <th valign="bottom" nowrap="nowrap" align="center">MONITOR Call<br>
      </th>
      <th valign="bottom">Description From Original Documentation<br>
      </th>
      <th valign="bottom">Additional Notes<br>
      </th>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">CALL MONITOR(0,<i>n</i>);<br>
    </font></code></td>
      <td valign="middle">Closes output file <i><font color="#663300"><code>n</code></font></i>.<br>
</td>
      <td valign="middle">I believe this refers to the sequential file or PDS attached for use with <font color="#663300"><code>OUTPUT(<i>n</i>)</code></font>, and <i>not</i> the random-access file (if any) attached for use with <font color="#663300"><code>FILE(<i>n</i>)</code></font>.<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>F</i>=MONITOR(1,<i>n</i>,<i>name</i>);<br>
    </font></code></td>
      <td valign="middle">Assumes that a PDS is attached to output device <font color="#663300"><code><i>n</i></code></font>.&nbsp; Physically writes any data previously buffered in memory by <font color="#663300"><code>OUTPUT(<i>n</i>)</code></font> operations into the PDS's member named <code><font color="#663300"><i>name</i></font></code>.&nbsp; The <code><font color="#663300"><i>name</i></font></code>
 parameter is a string 8 characters long, padded with blanks as 
necessary.&nbsp; Returns 0 if the member hadn't existed previously in 
the PDS, or 1 if the contents of an existing member of that name was 
replaced.<br>
</td>
      <td valign="middle"><br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>F</i>=MONITOR(2,<i>n</i>,<i>name</i>);<br>
    </font></code></td>
      <td valign="middle">Assumes that a PDS is attached to input device <font color="#663300"><code><i>n</i></code></font>.&nbsp; Sets future <font color="#663300"><code>INPUT(n)</code></font> operations to pull data from the PDS's member named <code><font color="#663300"><i>name</i></font></code>.&nbsp; The <code><font color="#663300"><i>name</i></font></code>
 parameter is a string 8 characters long, padded with blanks as 
necessary.&nbsp;  Returns 0 if the member was found, or 1 if it was not 
found.<br>
</td>
      <td valign="middle">The end-of-data for the member is detected when an input string of 0 length is encountered.<br>
  <br>
IR-182-1 asserts that devices 4 and 7 have the following abnormal <i>ad hoc</i> behavior very specific to <b>HAL/S-FC</b>.&nbsp;
 A PDS called "INCLUDE" is normally attached to input device 4, while 
either "INCLUDE" or "OUTPUT6" is normally attached to input device 
7.&nbsp; But member <code><font color="#663300"><i>name</i></font></code>&nbsp; is sought in device 4 or 7, then <code><font color="#663300"><i>name</i></font></code> is first sought in "INCLUDE" but upon failure is then sought in "OUTPUT6".<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">CALL MONITOR(3,<i>n</i>);<br>
    </font></code></td>
      <td valign="middle">Closes input file <i><font color="#663300"><code>n</code></font></i>.</td>
      <td valign="middle">I believe this refers to the sequential file or PDS attached for use with <font color="#663300"><code>INPUT(<i>n</i>)</code></font>, and <i>not</i> the random-access file (if any) attached for use with <font color="#663300"><code>FILE(<i>n</i>)</code></font>.</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">CALL MONITOR(4,<i>n</i>,<i>b</i>);<br>
    </font></code></td>
      <td valign="middle">Changes the record size of random-access file <code><font color="#663300"><i>n</i></font></code> to <code><font color="#663300"><i>b</i></font></code>.&nbsp; Must precede the first use of <font color="#663300"><code>FILE(<i>n</i>)</code></font>.<br>
</td>
      <td valign="middle"><br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">CALL MONITOR(5,ADDR(DW));<br>
    </font></code></td>
      <td valign="middle">Sets the location of the double-word work area (<font color="#663300"><code>DW</code></font>) for subsequent use by <font color="#663300"><code>MONITOR(9,...)</code></font> and <font color="#663300"><code>MONITOR(10,...)</code></font>.<br>
</td>
      <td valign="middle"><code><font color="#663300">DW</font></code> is meant to be literal here, at least for <b>HAL/S-FC</b>, and should not be replaced by anything else.<br>
  <br>
  <code><font color="#663300">DW</font></code> refers to an array of <font color="#663300"><code>FIXED</code></font>
 variables used in pairs, to hold 64-bit values. In particular, these 
pairs are often used to hold double-precision floating-point numbers in 
IBM System/360 format.&nbsp;&nbsp; <code><font color="#663300">MONITOR(9,<i>op</i>)</font></code> <font color="#663300"><font color="#000000">(see
 below) is then capable of performing various arithmetical operations on
 those numbers.&nbsp; Since XPL/I itself has no facilities for 
floating-point variables or operations on them, this workaround is the 
only available way to employ floating-point numbers in XPL/I programs.</font></font><code><font color="#663300"><br>
    </font></code></td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>F</i>=MONITOR(6,ADDR(<i>basedVariable</i>),<i>n</i>);<br>
    </font></code></td>
      <td valign="middle">Allocates n bytes of storage in free memory, clearing that memory to 0, and assigns the pointer of the <font color="#663300"><code><i>basedVariable</i></code></font> to point to that newly-allocated space.&nbsp; Returns 0 upon success, or 1 upon failure.<br>
</td>
      <td valign="middle">I.e., <font color="#663300"><code><i>basedVariable</i></code></font> is supposed to have been declared in XPL via <br>
  <blockquote>
    <pre><font color="#663300">BASED <i>basedVariable</i> ...;</font><br></pre>
  </blockquote>
and <code><font color="#663300"><i>n</i></font></code> should be an integral multiple of the size of <font color="#663300"><code><i>basedVariable</i></code></font>'s entries.<br>
  <br>
Garbage collection (via <font color="#663300"><code>COMPACTIFY</code></font>) is automatically performed if needed, and failure is reported only if there's a lack of space after garbage collection.<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>F</i>=MONITOR(7,ADDR(<i>basedVariable</i>),<i>n</i>);<br>
    </font></code></td>
      <td valign="middle">Frees the memory previously allocated via <code><font color="#663300">MONITOR(6,ADDR(<i>basedVariable</i>),<i>n</i>)</font></code>.&nbsp; However, <code><font color="#663300"><i>basedVariable</i></font></code>'s pointer is not changed, a thus will continue to point to the freed area until explicitly changed.<br>
</td>
      <td valign="middle"><br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">CALL MONITOR(8);<br>
    </font></code></td>
      <td valign="middle">Not used.&nbsp; Aborts the program if called.<br>
</td>
      <td valign="middle"><br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>F</i>=MONITOR(9,<i>op</i>);<br>
    </font></code></td>
      <td valign="middle">Performs floating point evaluation as specified by value of <code><font color="#663300"><i>op</i></font></code>.&nbsp; Operands are obtained from work area whose address was set up via a <font color="#663300"><code>MONITOR(5)</code></font>
 call. The first operand is taken from the first double word of the work
 area and the second operand from the second double word. The result is 
placed in the first double word of the work area. The return code is 0 
if the operation succeeds, or 1 if the operation fails (under or 
overflow).<br>
  <br>
The values of <code><font color="#663300"><i>op</i></font></code> are:<br>
  <table align="center" cellspacing="2" cellpadding="2" border="1">
    <tbody>
      <tr>
        <th valign="top">OP<br>
        </th>
        <th valign="top">Function<br>
        </th>
      </tr>
      <tr>
        <td valign="top" align="center">1<br>
        </td>
        <td valign="top" align="center">arg1 + arg2<br>
        </td>
      </tr>
      <tr>
        <td valign="top" align="center">2<br>
        </td>
        <td valign="top" align="center">arg1 - arg2<br>
        </td>
      </tr>
      <tr>
        <td valign="top" align="center">3<br>
        </td>
        <td valign="top" align="center">arg1 * arg2<br>
        </td>
      </tr>
      <tr>
        <td valign="top" align="center">4<br>
        </td>
        <td valign="top" align="center">arg1 / arg2<br>
        </td>
      </tr>
      <tr>
        <td valign="top" align="center">5<br>
        </td>
        <td valign="top" align="center">arg1<sup>arg2</sup><br>
        </td>
      </tr>
      <tr>
        <td valign="top" align="center">6<br>
        </td>
        <td valign="top" align="center">sin(arg1)<br>
        </td>
      </tr>
      <tr>
        <td valign="top" align="center">7<br>
        </td>
        <td valign="top" align="center">cos(arg1)<br>
        </td>
      </tr>
      <tr>
        <td valign="top" align="center">8<br>
        </td>
        <td valign="top" align="center">tan(arg1)<br>
        </td>
      </tr>
      <tr>
        <td valign="top" align="center">9<br>
        </td>
        <td valign="top" align="center">exp(arg1)<br>
        </td>
      </tr>
      <tr>
        <td valign="top" align="center">10<br>
        </td>
        <td valign="top" align="center">log(arg1)<br>
        </td>
      </tr>
      <tr>
        <td valign="top" align="center">11<br>
        </td>
        <td valign="top" align="center">sqrt(arg1)<br>
        </td>
      </tr>
    </tbody>
  </table>
  <br>
</td>
      <td valign="middle">"arg1" refers to the DP floating-point number stored in the pair of work-area valued <font color="#663300"><code>DW(0),DW(1)</code></font>.<br>
  <br>
"arg2" refers to the DP floating-point number stored in the pair of work-area valued <font color="#663300"><code>DW(2),DW(3)</code></font>.<br>

  <br>
The DP floating-point result of the operation is stored back into <font color="#663300"><code>DW(0),DW(1)</code></font>, although not all of the operations can necessarily produce results of full DP accuracy from DP operands.<br>
  <br>
The angular unit for trigonometric operations is the radian.<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>F</i>=MONITOR(10,<i>string</i>);<br>
    </font></code></td>
      <td valign="middle">Performs character to DP floating-point conversion upon characters in <code><font color="#663300"><i>string</i></font></code>.
 The return code is 0 if the result is valid, or 1 if conversion was not
 possible. The result is placed in the first double word of the work 
area provided by the <font color="#663300"><code>MONITOR(5)</code></font> call.<br>
</td>
      <td valign="middle">In other words, <code><font color="#663300"><i>string</i></font></code> is interpreted as a DP floating-point number and stored in <font color="#663300"><code>DW(0),DW(1)</code></font>.&nbsp; Any of the usual representations for decimal numbers are accepted in the string, including the usual <font color="#663300"><code>E</code></font> notation for exponents.<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">CALL MONITOR(11);<br>
    </font></code></td>
      <td valign="middle">Not used — a no-op.<br>
</td>
      <td valign="middle"><br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>string</i>=MONITOR(12,<i>p</i>);<br>
    </font></code></td>
      <td valign="middle">Converts floating-point number in the first double word of the work area to standard HAL/S character form. Value of <code><font color="#663300"><i>p</i></font></code> indicates whether the operand is SP (<code><font color="#663300"><i>p</i></font></code>=0) or DP (<code><font color="#663300"><i>p</i></font></code>=8).<br>
</td>
      <td valign="middle">In other words, this is the inverse of <code><font color="#663300">MONITOR(10,<i>string</i>)</font></code> (see above).<br>
  <br>
As far as the "standard HAL/S character form" is concerned, it's described in HAL/S documentation (<i>Programming in HAL/S</i>, p. 3) as follows:<br>
  <ul>
    <li>0.0: Printed as " 0.0" (notice the leading space).</li>
    <li>Positive:  Printed as " d.ddd...E±ee"</li>
    <li>Negative:  Printed as "-d.ddd...E±ee"</li>
  </ul>
Except for the special case 0.0, the number of printed fractional digits
 is always the same, although we're not told exactly how many that it 
is:&nbsp; merely that it is "implementation dependent".&nbsp; I believe,
 without any basis — and therefore <b>XCOM-I</b> implements — that the 
number of fractional digits is chosen to provide the maximum accuracy, 
which is 6 for single precision and 15 for double precision.<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>point</i>=MONITOR(13,<i>name</i>);<br>
    </font></code></td>
      <td valign="middle">N/A<br>
</td>
      <td valign="middle">This is a no-op for <b>XCOM-I</b>.<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>F</i>=MONITOR(14,<i>n</i>,<i>a</i>);<br>
    </font></code></td>
      <td valign="middle">N/A<br>
</td>
      <td valign="middle">This is a no-op for <b>XCOM-I</b> but may be implemented in the future.&nbsp; It is related to so-called Simulation Data Files (SDF), which are only relevant to <b>HAL/S-FC</b>
 compiler passes 3 and 4, which are not currently on Virtual AGC's 
roadmap for implementation since none of the support software for SDF 
has survived.<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>I</i>=MONITOR(15);<br>
    </font></code></td>
      <td valign="middle">Returns Revision Level and Catenation Number from last <font color="#663300"><code>MONITOR(2)</code></font>
 call.&nbsp; Catenation number is obtained from PDS directory data and 
Revision Level from user data field as specified in the HAL/SDL ICD. The
 values are returned in the left and right halfwords of the result.<br>
</td>
      <td valign="middle">TBD<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">CALL MONITOR(16,<i>n</i>);<br>
    </font></code></td>
      <td valign="middle">Sets flags in byte to be returned as high 
order byte of return code at end of compilation. Flags are passed as 
right most byte of fullword <code><font color="#663300"><i>n</i></font></code>. If high order bit of <code><font color="#663300"><i>n</i></font></code> is zero, flags are OR'ed into existing flags. If high order bit of <code><font color="#663300"><i>n</i></font></code> is one, flags replace existing flags.<br>
</td>
      <td valign="middle">TBD<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">CALL MONITOR(17,name);<br>
    </font></code></td>
      <td valign="middle">Causes <i><code><font color="#663300">name</font></code></i> to be copied to third parm field (if any) passed to <font color="#663300"><code>MONITOR</code></font> by the program that invoked the compiler. See HAL/SDL ICD.<br>
</td>
      <td valign="middle">TBD<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>T</i>=MONITOR(18);<br>
    </font></code></td>
      <td valign="middle">Returns elapsed CPU time since beginning of run in units of .01 seconds.<br>
</td>
      <td valign="middle"><br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>F</i>=MONITOR(19,<i>addressList</i>,<i>sizeList</i>);<br>
    </font></code></td>
      <td valign="middle">This is an extended form of <font color="#663300"><code>MONITOR(6)</code></font> (see above), accepting arrays of addresses of <font color="#663300"><code>BASED</code></font> variables and their block sizes.&nbsp; Unlike <font color="#663300"><code>MONITOR(6)</code></font>, the newly-allocated blocks of memory are not cleared to 0.<br>
</td>
      <td valign="middle"><br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">CALL MONITOR(20,</font></code><code><font color="#663300"><code><font color="#663300"><i>addressList</i>,<i>sizeList</i></font></code>);<br>
    </font></code></td>
      <td valign="middle">This is an extended form of <font color="#663300"><code>MONITOR(7)</code></font> (see above), accepting arrays of addresses of <font color="#663300"><code>BASED</code></font> variables and their block sizes. <br>
</td>
      <td valign="middle"><br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>I</i>=MONITOR(21);<br>
    </font></code></td>
      <td valign="middle">Returns remaining amount of memory (in bytes) that's free for allocation via <font color="#663300"><code>MONITOR(6)</code></font> without garbage collection.<br>
</td>
      <td valign="middle">For Intermetrics <b>XCOM</b>, I believe, <font color="#663300"><code>MONITOR(6)</code></font> could use <i>any</i> contiguous block of free memory, including those that were candidates for garbage collection.&nbsp; Whereas <b>XCOM-I</b>
 only allocates memory within the contiguous block at the end of the 
free-memory space.&nbsp; Consequently, this function would originally 
have found the largest free block wherever it was located, whereas <b>XCOM-I</b> merely reports the size of the final block of free memory.<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>F</i>=MONITOR(22,<i>n</i>,<i>a</i>);<br>
    </font></code></td>
      <td valign="middle">N/A<br>
</td>
      <td valign="middle">See the comments for <font color="#663300"><code>MONITOR(14)</code></font>.<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300"><i>string</i>=MONITOR(23);<br>
    </font></code></td>
      <td valign="middle">Returns the 10 character string obtained from 
the ID field of the File Control Block of the first phase of the 
compiler. The ID field is maintained by the <b>XPLZAP</b> program and contains the identifying string printed on the header of each page of the HAL listing.<br>
</td>
      <td valign="middle">I'm not fully clear what this means.&nbsp; At present, <code><font color="#663300"><i>string</i></font></code> is always returned as 'REL32V0&nbsp;&nbsp; '.<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">MONITOR(24)<br>
    </font></code></td>
      <td valign="middle">Read a block of a load module.<br>
</td>
      <td valign="middle">TBD<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">MONITOR(25)<br>
    </font></code></td>
      <td valign="middle">Read a mass-memory load block.<br>
</td>
      <td valign="middle">TBD<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">MONITOR(26)<br>
    </font></code></td>
      <td valign="middle">Read a MAF (memory analysis file) block<br>
</td>
      <td valign="middle">TBD<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">MONITOR(27)<br>
    </font></code></td>
      <td valign="middle">Write a MAF block<br>
</td>
      <td valign="middle">TBD<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">MONITOR(28)<br>
    </font></code></td>
      <td valign="middle">Link to dump analysis service routine<br>
</td>
      <td valign="middle">TBD<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">MONITOR(29)<br>
    </font></code></td>
      <td valign="middle">Return current page number<br>
</td>
      <td valign="middle">TBD<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">MONITOR(30)<br>
    </font></code></td>
      <td valign="middle">Return JFCB as string<br>
</td>
      <td valign="middle">TBD<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">MONITOR(31)<br>
    </font></code></td>
      <td valign="middle">Virtual-memory lookahead service.<br>
</td>
      <td valign="middle">TBD<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">MONITOR(32)<br>
    </font></code></td>
      <td valign="middle">Find out subpool minimum size<br>
</td>
      <td valign="middle">TBD<br>
</td>
    </tr>
    <tr>
      <td valign="middle" nowrap="nowrap" align="center"><code><font color="#663300">MONITOR(33)<br>
    </font></code></td>
      <td valign="middle">Find out FILE max REC# and BLKSIZ<br>
</td>
      <td valign="middle">TBD<br>
</td>
    </tr>
    
    
    
    
    
    
  </tbody>
</table>

<h1>Debugging XPL Programs</h1>
<p>It is admittedly unlikely that many people will be writing new XPL or XPL/I programs nowadays, and will instead be compiling only legacy XPL or XPL/I programs ... assuming that I haven't already compiled all of them first!  (Which is a distinct possibility.)  Since such legacy programs will presumably all have been debugged decades before, there's not as much need for a debugger as there is for computer languages in which there are many active developers.  Nevertheless, XPL or XPL/I programs can be run under a debugger to a certain extent.<br></p>
The trick is to realizes that while we have no debugger for the XPL language, we do have debuggers for C, and once <b>XCOM-I</b>
 has translated XPL or XPL-I software into C, such C debuggers can be 
used.  It is merely necessary when compiling the C code to include the 
necessary command-line switches that cause the C compiler to incorporate
 debugging information into the executable.  For the <b>gcc</b> C compiler, that command-line switch is <font color="#663300"><code>-ggdb</code></font>, and incorporating it can be done simply by adding it to the <b>make</b> command like via<br>
<blockquote><font color="#663300"><code>make EXTRA=-ggdb ...</code></font><br>
</blockquote>
Having done this, any debugger which can accept <b>gdb</b> style debugging info, such as <b>gdb</b> itself or full-screen wrappers for <b>gdb</b>, can now be used for debugging.&nbsp; For other C compilers or other debuggers, perhaps different switches would be needed.<br>
<br>
The principal difficulty in debugging the code in C vs in XPL (if that were possible) is that <b>XCOM-I</b> doesn't model XPL variables as C variables, but rather as numerical locations in an array called <font color="#663300"><code>memory</code></font>.&nbsp;
 Moreover, the format of this data in "memory" is that of the IBM 
System/360 rather than the native format of the computer on which 
debugging is being performed.&nbsp; While in my opinion, these design 
choices for <b>XCOM-I</b> were are all necessary and unavoidable, 
there's no denying that they make it trickier to use a debugger to see 
the how the values of variable change during execution.&nbsp; <br>
<br>
I have, however, provided a few C functions in the runtime library to make it a <i>little</i> less painful to examine XPL variables within a debugger.&nbsp; You can also use the XPL <font color="#663300"><code>CALL INLINE</code></font>
 feature to directly embed calls to these functions within your program,
 without running a debugger at all, if it's more convenient for you to 
do so.<br>
<br>
The debugging functions are:<br>
<ul>
  <li><font color="#663300"><code>void printMemoryMap(char *heading)</code></font> — This function prints out the entire current state of the memory map.  I.e., the addresses of all variables, including dynamically-allocated ones, and the contents of all of those variables.  Of course, for an XPL program any complexity, the printout is quite long, so this function is presumably used sparingly.  The <font color="#663300"><code>heading</code></font> parameter is simply a message printed at the top, which can be helpful if you call <font color="#663300"><code>printMemoryMap</code></font> several times (perhaps via <font color="#663300"><code>CALL INLINE</code></font>) in the same program run.  In a <b>gdb</b> console, you could run it via the command <font color="#663300"><code>call printMemoryMap("...")</code></font>, whereas you could instead embed it in your XPL source code via <font color="#663300"><code>CALL INLINE('</code><code>printMemoryMap("...")</code><code>');</code></font>.<br></li>
  <li><font color="#663300"><code>char *getXPL(char *identifier)</code></font> — Returns (as a C string) the value of a single XPL variable whose name is given by the <font color="#663300"><code>identifier</code></font>.  The <font color="#663300"><code>identifier</code></font> string can be any identifier expression that's syntactically correct in XPL/I, provided that subscripts consist entirely of decimal digits, possibly with a leading minus sign.  This includes expressions like <font color="#663300"><code>"V"</code></font>, <font color="#663300"><code>"V(5)"</code></font>, <font color="#663300"><code>"B(3).V"</code></font>, or <font color="#663300"><code>"B(3).V(-5)"</code></font>.  Recall that in XPL/I, subscripts can be applied to scalar variables.  If you are querying a <font color="#663300"><code>BASED RECORD</code></font>, then be sure to include the desired field, since while <font color="#663300"><code>getXPL</code></font> knows how to print an individual field of a <font color="#663300"><code>RECORD</code></font>, it does not know how to print a <i>collection</i> of fields such as a <font color="#663300"><code>RECORD</code></font>.  In a <b>gdb</b> console, you could use <font color="#663300"><code>getXPL</code></font> with a command like <font color="#663300"><code>print getXPL(...)</code></font>.   For example, <font color="#663300"><code>print getXPL("C1(4)")</code></font>. <br></li>
  <li><font color="#663300"><code>void printXPL(char *identifier)</code></font> — This provides the same functionality as <font color="#663300"><code>getXPL</code></font>, except that it prints its output to <font color="#663300"><code>stdout</code></font> rather than returning it as a string.  In a <b>gdb</b> console, you could run it via the command <font color="#663300"><code>call printXPL("...")</code></font>, or you could instead embed it in your XPL source code via <font color="#663300"><code>CALL INLINE('</code><code>printXPL("...")</code><code>');</code></font>.</li>
  <li><font color="#663300"><code>int bitBits</code></font> — By default, <font color="#663300"><code>getXPL</code></font> and <font color="#663300"><code>printXPL</code></font> print the data of a <font color="#663300"><code>BIT</code></font> variable in hexadecimal notation.  In contrast, legacy XPL source code has often logically partitioned the data in <font color="#663300"><code>BIT</code></font> strings into subgroupings of 1, 2, or 3 bits (rather than 4 as for hexadecimal), thus using literal constants (such as initializers in declarations) that are in binary, base-4, or octal notation.  In those cases, it's difficult to relate hexadecimal strings returned by <font color="#663300"><code>getXPL</code></font> with the literals shown in the XPL source code.  The global variable <font color="#663300"><code>bitBits</code></font> addresses this by allowing you to change the radix used for the <font color="#663300"><code>BIT</code></font> data.  By default <font color="#663300"><code>bitBits</code></font> is 4 (hexadecimal), but can be changed to 1 (binary), 2 (base-4), or 3 (octal)<font color="#663300"><code></code></font>.  In a <b>gdb</b> console, you could change via a command like <font color="#663300"><code>set bitBits=2</code></font>.</li>
</ul>
<p>In using these debugging functions, note that they all require <i>mangled</i> forms of variable names and parameters of <code>PROCEDURE</code>s.  Mangled names consist of the names of the variables or parameters as <font color="#663300"><code>DECLARE</code></font>d in the XPL source code, but <i>prefixed</i> by the names of all of the parent <font color="#663300"><code>PROCEDURE</code></font>s.  Perhaps an example would make this clearer.  Suppose your XPL source code looked like the following:<br></p>
<blockquote>
  <pre><font color="#663300">DECLARE X FIXED, Y FIXED, Z FIXED;<br></font></pre>
  <pre><font color="#663300">PROC1:<br>PROCEDURE(X, Y);<br>   DECLARE X FIXED, Y FIXED, Z FIXED;<br><br>   PROC2:<br>   PROCEDURE(X, Y);<br>      DECLARE X FIXED, Y FIXED, Z FIXED;<br>      ...<br>   END PROC2;<br><br>END PROC1;</font><br></pre>
</blockquote>
<p>Then the mangled variable and parameter names we'd find in our memory map (and just for reference, <font color="#663300"><code>PROCEDURE</code></font> names), as well as being used in our debugging functions, would be:<br></p>
<blockquote>
  <pre><font color="#663300">X<br>Y<br>Z<br>PROC1<br>PROC1xX<br>PROC1xY<br>PROC1xZ<br>PROC1xPROC2<br>PROC1xPROC2xX<br>PROC1xPROC2xY<br>PROC1xPROC2xZ</font><br></pre>
</blockquote>
Thus while we have lots of global and local variables and function parameters named <font color="#663300"><code>X</code></font>, <font color="#663300"><code>Y</code></font>, and <font color="#663300"><code>Z</code></font>, their mangled names are all distinct. <br>
<blockquote><font size="-1"><b>Aside:</b> By the way, the lower-case '<font color="#663300"><code>x</code></font>' characters appearing in the mangled names have nothing to do with the fact that one of our identifiers is '<font color="#663300"><code>X</code></font>'.&nbsp; That's a coincidence.&nbsp; Rather, they're just convenient separators <b>XCOM-I</b> conventionally uses between scope names and the variable names.&nbsp; Recall that XPL identifiers are case-insensitive.&nbsp; <b>XCOM-I</b> translates them all internally to upper case.&nbsp; Hence, lower-case 'x' is not a character that can appear in <i>un</i>mangled identifiers or names of scopes.</font><br>
</blockquote>
<h1>


  <a name="hooks"></a>Patches for Basic Assembly Language Code<br>
</h1>A serious difficulty in working with XPL/I code is that the Space Shuttle <b>PASS</b> programs were not 
written entirely in XPL/I, but also inserted inline IBM System/360 basic
 assembly-language (BAL) code at various junctures.&nbsp; However good 
<b>XCOM-I</b> may (or may not) be at translating XPL or XPL/I to C, it is <i>not</i> capable of inferring the intent of arbitrary BAL code, nor of translating such code into C.<br>
<br>
Moreover, there is a second problem associated with BAL code that has 
been inlined into XPL/I code, which is that while I can imagine 
replacing such BAL code by C-language code that provides the same 
functionality, I do <i>not</i> want to do it in a way that necessitates 
altering the original XPL/I source code!&nbsp; Why is that?&nbsp; Well, 
the XPL/I source code for (say) <b>HAL/S-FC</b> is quite large, comprising 
tens of thousands of lines across hundreds of files, and I'd prefer to 
avoid storing two almost-identical copies of it in our Virtual AGC 
source-code tree, one of which is identical to the original and one of 
which has been altered. It's better from my perspective to have a single
 copy of it that's verifiably identical to the original.<br>
<br>
Don't worry!&nbsp; <b>XCOM-I</b> let's us satisfy our desires.&nbsp; But to understand <i>how</i>, you need to know a 
little more about this BAL source code that's causing the problem.<br>
<br>
BAL source code is embedded in XPL or XPL/I code via calls to the XPL built-in function <font color="#663333"><code>INLINE</code></font> that look roughly like this:
<blockquote>
  <pre><pre><meta name="qrichtext" content="1"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><style type="text/css">
p, li { white-space: pre-wrap</style><p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><font color="#663300">         CALL INLINE("58", 3, 0, DW_AD);           /* L    3,DW_AD            */</font></p><font color="#663300">/*LOAD DOUBLE FROM STACK SPACE 3 TO REGISTER 0*/
</font><pre style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><font color="#663300">         CALL INLINE("68", 0, 0, 3, 0);            /* LD   0,0(0,3)           */</font></pre><font color="#663300">/*LOAD POSITIVE VALUE OF REGISTER 0 INTO REGISTER 0*/
</font><pre style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><font color="#663300">         CALL INLINE("20", 0, 0);                  /* LPDR 0,0                */</font></pre><font color="#663300">/*LOAD ROUNDING VALUE INTO STACK 1 THEN ADD TO REGISTER 0*/
</font><pre style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><font color="#663300">         CALL INLINE("58", 1, 0, ADDR_ROUNDER);    /* L    1,ADDR_ROUNDER     */</font></pre><font color="#663300">         CALL INLINE("6A", 0, 0, 1, 0);            /* AD   0,0(0,1)           */
</font><pre style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><font color="#663300">         CALL INLINE("58", 1, 0, ADDR_FIXED_LIMIT);/* L    1,ADDR_FIXED_LIMIT */</font></pre><font color="#663300">         CALL INLINE("58", 2, 0, PTR);             /* L    2,PTR              */
</font><pre style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><font color="#663300">/*COMPARE REGISTER 0 TO THE POSITIVE INTEGER LIMIT*/</font></pre><font color="#663300">         CALL INLINE("69", 0, 0, 1, 0);            /* CD   0,0(0,1)           */
</font><pre style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><font color="#663300">/*BRANCH TO 'LIMIT_OK' IF REGISTER 0 IS LESS THAN OR EQUAL TO THE LIMIT       */</font></pre><font color="#663300">         CALL INLINE("07",12, 2);                  /* BNHR 2                  */</font><pre style=" margin-top:0px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><!--EndFragment--></pre></pre></pre>
</blockquote>
There are several different variations to <font color="#663333"><code>INLINE</code></font>'s syntax, but those differences aren't important to us.&nbsp; What's important at the moment is rather that each <font color="#663333"><code>CALL INLINE(...)</code></font> inserts a single BAL instruction.<br>
<br>
Another thing that's important is that when <b>XCOM-I</b> encounters a <font color="#663333"><code>CALL INLINE(...)</code></font>,
 by default it translates it simply to an empty C statement; i.e., to a C
 statement that's just a semi-colon.&nbsp; But it also inserts a <i>numbered</i> program comment.&nbsp; The code above, for example, might be translated to C by <b>XCOM-I</b> as:<br>
<pre><pre><font color="#663300">        // (459) CALL INLINE("58", 3, 0, DW_AD);<br>	;<br>        // (460) CALL INLINE("68", 0, 0, 3, 0); <br>	;<br>        // (461) CALL INLINE("20", 0, 0);<br>	;<br>        // (462) CALL INLINE("58", 1, 0, ADDR_ROUNDER);<br>	;<br>        // (463) CALL INLINE("6A", 0, 0, 1, 0);<br>	;<br>        // (464) CALL INLINE("58", 1, 0, ADDR_FIXED_LIMIT);<br>	;<br>        // (465) CALL INLINE("58", 2, 0, PTR);<br>	;<br>        // (466) CALL INLINE("69", 0, 0, 1, 0);<br>	;</font><br></pre></pre>
These parenthesized numbers which <b>XCOM-I</b> has inserted into the comments 
are not only all distinct from each other, but also are always the same 
every time the source code has been compiled, as long no <font color="#663333"><code>INLINE</code></font>s have been added or removed in the meantime ... an assumption which at this point seems pretty safe!&nbsp; Let's call them <i>patch numbers</i>.<br>
<br>
Reasonably enough, patch numbers can be used to define places at which 
<b>XCOM-I</b> makes a patch.&nbsp; Suppose, for example, that we had a file 
called "patch459.c" containing C code that we wanted to use to mimic the
 functionality of the BAL code above.&nbsp; Similarly, we could have a 
patch460.c, a patch461.c, and so on, but there's little reason to do so,
 since it's just easier to put all of our replacement code for this 
sequence of instructions into a single file.<br>
<br>
Each time <b>XCOM-I</b> encounters a <font color="#663333"><code>CALL INLINE(...)</code></font>, it looks for a patch file corresponding to the <font color="#663333"><code>INLINE</code></font>'s
 patch number.&nbsp; If it finds such a file, then it inserts it, and 
it's only if there's no such patch file exists that the default 
translation into an empty C statement occurs.<br>
<br>
Of course, the glib explanation I've just given glosses over a lot of 
the difficulties, such as figuring out what C code is appropriate for 
any given BAL code.&nbsp; I can't give you any amazingly-handy insights 
on that topic, I'm afraid.&nbsp; In the case of this <i>particular</i> 
example, the code I've shown above is just the beginning portion of a 
longer sequence of BAL instructions, intermixed with XPL statements, 
which occurs in the <font color="#663333"><code>ROUND_SCALAR PROCEDURE</code></font>
 in the <b>HAL/S-FC</b> source-code file HALMATIN.xpl.&nbsp; Collectively, I 
think the entire sequence may round a double-precision floating-point 
number previously loaded into a pair of the CPU's floating-point 
registers (referred to by the symbolic name <font color="#663300"><code>DW[0]</code></font> and <font color="#663300"><code>DW[1]</code></font>) to an integer, then compare that integer to the positive and negative limits of the 32-bit signed integer datatype (<font color="#663300"><code>FIXED</code></font>), and finally, cap the value at those limits, ultimately storing the rounded-and-capped value back into <font color="#663300"><code>DW[0]</code></font> and <font color="#663300"><code>DW[1]</code></font>.&nbsp; (Which would not be terribly surprising given that the name of the <font color="#663300"><code>PROCEDURE</code></font> is <font color="#663300"><code>ROUND_SCALAR</code></font>.)&nbsp; <br>
<blockquote><font size="-1"><b>Aside:</b> How did I arrive at these 
conclusions?&nbsp; My best explanation is that you sit quietly, unfocus 
your eyes, clear your mind, attain some kind of a zenlike state, ignore 
the BAL instructions themselves, and think merely of the program 
comments and symbolic names.&nbsp; On the other hand, I suspect that my 
explanation is perhaps not of universal applicability.&nbsp; And it 
might be fair to mention that many of these sequences of BAL 
instructions use these same kinds of rounding and capping operations, 
and you do get a feel for them after looking at a few.</font><br>
</blockquote>
<blockquote><font size="-1"><b>Aside:</b> Realize too that the values 
stored in the CPU's floating-point registers will be in IBM 360 
floating-point format, so to do anything useful with them, we may want 
to translate them back and forth into the native C floating-point 
format.</font><br>
</blockquote>
If all that's true, then our patch file (patch459.c) might look 
something like the following, where I've invented some 
plausible-sounding helper functions to implement it.&nbsp; It's not 
important at the moment that you don't understand the patch code, or 
even if it's correct.&nbsp; It probably isn't!&nbsp; We're just 
exploring the principles involved in patching.&nbsp; Note that the <font color="#663300"><code>return</code></font>
 at the end is not an essential part of the patching process; rather it 
just happens to be appropriate for this example, but wouldn't be present
 in most patches.<br>
<blockquote>
  <pre><font color="#663300">// Note: ADDR(NULL, 0, "DW", i) gives the address of DW[i] in the <br>// simulated-memory array.  For efficiency's sake, we'd probably<br>// want to determine these addresses just once, during program<br>// initialization  But let's not worry about that at the moment.<br>double x = fromFloatIBM(ADDR(NULL, 0, "DW", 0), ADDR(NULL, 0, "DW", 1));<br>double r = round(x);<br>int32_t n;<br>if (r &gt; 2147483647)<br>	n = 2147483647;<br>else if (r &lt; -2147483648)<br>	n = -2147483648;<br>else<br>	n = r;<br>toFloatIBM(ADDR(NULL, 0, "DW", 0), ADDR(NULL, 0, "DW", 1), n);<br>return 1;</font><br></pre>
</blockquote>
Putting all this together, if <b>XCOM-I</b> is used to compile the program once
 again, it now finds patch-file patch459.c, but no patch460.c, 
patch461.c, etc., so it ends up compiling our mess of <font color="#663333"><code>CALL INLINE(...)</code></font> statements to:<br>
<pre><pre><font color="#663300">        { // (459) CALL INLINE("58", 3, 0, DW_AD);<br></font><font color="#663300"><font color="#663300">                // Note: ADDR(NULL, 0, "DW", i) gives the address of DW[i] in the </font></font><br><font color="#663300"><font color="#663300">                // simulated-memory array.  For efficiency's sake, we'd probably</font></font><br><font color="#663300"><font color="#663300">                // want to determine these addresses just once, during program</font></font><br><font color="#663300"><font color="#663300">                // initialization  But let's not worry about that at the moment.</font></font><br><font color="#663300">		double x = fromFloatIBM(ADDR(NULL, 0, "DW", 0), ADDR(NULL, 0, "DW", 1));<br>		double r = round(x);<br>		int32_t n;<br>		if (r &gt; 2147483647)<br>			n = 2147483647;<br>		else if (r &lt; -2147483648)<br>			n = -2147483648;<br>		else<br>			n = r;<br>		toFloatIBM(ADDR(NULL, 0, "DW", 0), ADDR(NULL, 0, "DW", 1), n);<br>		return 1;
	}<br>        // (460) CALL INLINE("68", 0, 0, 3, 0); <br>	;<br>        // (461) CALL INLINE("20", 0, 0);<br>	;<br>        // (462) CALL INLINE("58", 1, 0, ADDR_ROUNDER);<br>	;<br>        // (463) CALL INLINE("6A", 0, 0, 1, 0);<br>	;<br>        // (464) CALL INLINE("58", 1, 0, ADDR_FIXED_LIMIT);<br>	;<br>        // (465) CALL INLINE("58", 2, 0, PTR);<br>	;<br>        // (466) CALL INLINE("69", 0, 0, 1, 0);<br>	;</font></pre></pre>

Notice that the patch is automatically placed within a C <font color="#663300"><code>{...}</code></font> block, which is important if the <font color="#663333"><code>CALL INLINE(...)</code></font> happens to have been preceded by something like <code><font color="#663300">IF ... THEN</font></code> or <font color="#663300"><code>ELSE</code></font>.&nbsp; The <font color="#663300"><code>return</code></font> at the end of our patch causes all of the remainder of the <font color="#663333"><code>ROUND_SCALAR PROCEDURE</code></font> to be skipped past, probably generating a few warnings from the C compiler.&nbsp; But in a more-usual example the <font color="#663300"><code>return</code></font> wouldn't have been in the patch, and so the compiler warnings wouldn't be generated either.<br>
<br>
By default, <b>XCOM-I</b> will look for patch files in the same folder holding 
the XPL/I source-code file it's compiling, though it has a command-line 
option (<font color="#663300"><code>--patch=<i>PATHNAME</i></code></font>)
 that allows a different folder to be specified, which in the case of a 
huge XPL/I program like <b>HAL/S-FC</b> is probably a better idea.<br>
<br>
Incidentally, in <b>XCOM-I</b>, if <font color="#663333"><code>CALL INLINE(...) </code></font>is
 used with a single parameter that's a string, then no patch file is 
sought.&nbsp; Rather, <b>XCOM-I</b> treats that single string parameter as a 
line of C code, and inserts the line directly into the output C 
code.&nbsp; Thus if you were willing to modify the original XPL source 
code rather than leaving it unchanged and using the patch-file 
technique, you might be able to do so just by altering the parameters of
 the <font color="#663333"><code>CALL INLINE(...) </code></font>statements to contain C source code rather than BAL source code.<br>
<br>


    
<hr style="width: 100%; height: 2px;">
    
<center><br>
      <span style="color: rgb(84, 89, 93); font-family: sans-serif;
        font-size: 11.05px; font-style: normal; font-variant: normal;
        font-weight: normal; letter-spacing: normal; line-height:
        16.575px; orphans: auto; text-align: center; text-indent: 0px;
        text-transform: none; white-space: normal; widows: 1;
        word-spacing: 0px; -webkit-text-stroke-width: 0px; display:
        inline !important; float: none; background-color: rgb(255, 255,
        255);"> This page is available under the <a href="https://creativecommons.org/publicdomain/zero/1.0/">
          Creative Commons No Rights Reserved License</a> </span><br>
      <i><font size="-1">Last modified by <a href="mailto:info@sandroid.org">Ronald Burkey</a> on
          2024-04-28<br>
          <br>
          <a href="https://www.ibiblio.org"> <img style="border: 0px
              solid ; width: 300px; height: 100px;" alt="Virtual AGC is
              hosted by ibiblio.org" src="hosted.png" width="300" height="100"></a><br>
        </font></i></center>


    <br>


  

</body></html>