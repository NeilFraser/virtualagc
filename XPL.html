<!DOCTYPE doctype PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
    
<title>Virtual AGC Document Library Page</title>


    
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">


    
<meta name="Author" content="Ronald Burkey">


    
<link rel="icon" type="image/png" href="favicon.png">


    
<meta name="author" content="Ronald S. Burkey">


    
<script type="text/javascript" src="Header.js"></script>
  </head>
  <body style="background-image: url(gray3.jpg);">
    
<script type="text/javascript">
document.write(headerTemplate.replace("@TITLE@","Space Shuttle").replace("@SUBTITLE@","XPL/I Compiler XCOM-I"))
</script><br>


    
<div align="center"><i>(This page is under construction.)</i><br>
    </div>


    
<h1>Table of Contents </h1>


    
<ul>


      <li><a moz-do-not-send="true" href="#Introduction">Introduction to XPL/I</a></li>
<li><a moz-do-not-send="true" href="#compiling">Processing a Program Written in XPL, Using <b>XCOM-I</b>
</a></li>
<ul>
  <li><a moz-do-not-send="true" href="#installation">Installation of <b>XCOM-I</b></a></li>
  <li><a moz-do-not-send="true" href="#xpl">Compiling and Running an XPL Program</a></li></ul>
<li><a moz-do-not-send="true" href="#xpli">A Primer for Standard XPL and Intermetrics XPL/I</a>
</li>
<ul>

  
</ul>

<li><a moz-do-not-send="true" href="#hooks">Patches for Basic Assembly Language Code</a>
</li>
</ul>


    
<h1><a name="Introduction"></a>Introduction to XPL/I<br>
</h1>Keep in mind that this website is devoted to onboard guidance 
software used aboard space vehicles such as those of the Apollo and 
Space Shuttle projects, thus most of what I have to say on the topic of 
XPL is from that point of view.&nbsp; But that doesn't mean it cannot be used for general purposes as well.<br>
<br>
For the purpose of thinking about XPL, 
what you need to know to follow the discussion herein is this:<br>
<ul>
  <li>Flight software for the Space Shuttle was primarily written in a computer language called <i>HAL/S</i>, created by Intermetrics, Inc.&nbsp; That flight software was called <i>PASS</i>, and that's what I'll refer to it as from now on.<br></li>
  <li>To compile PASS source code, you therefore need a compiler for HAL/S, and more-specifically for Intermetrics's specific variation of HAL/S.&nbsp; Intermetrics's HAL/S compiler, called HAL/S-FC, was primarily written in a computer language they called <i>XPL</i>.</li>
  <li>Thus to compile the <i>compiler</i> for PASS, you need a compiler for the XPL language.<br></li>
</ul>
Well, that's certainly a mouthful of words!&nbsp; The point is that 
having an XPL compiler is just one item — though an important one! —  in
 a 
chain of things that are helpful in the process of 
resurrecting PASS for modern audiences. In more-general terms, though, 
XPL used to be a computer language (<a moz-do-not-send="true" href="https://en.wikipedia.org/wiki/XPL">see the Wikipedia article</a>) in the 1960's and 1970's that was defined by a book called <i>A Compiler Generator</i>,
 by William M. McKeeman, James J. Horning, and David B. Wortman.&nbsp; 
In practical terms, that book is the sole documentation for the standard
 XPL language, and is available neither for free, nor in digital form 
online.&nbsp; For brevity, I'll refer to that book from now on simply as
 <i>McKeeman</i>.<br>
<br>
Alas, it's even a bit more complicated than what I just said.&nbsp; For 
one thing, Intermetrics did not write its HAL/S compiler in <i>standard</i>
 XPL as defined by McKeeman.&nbsp; Rather, they extended the language 
with new features, occasionally changing the existing features in an 
incompatible way, and relying heavily on the fact that the compiled XPL 
programs would run on IBM System/360 mainframes.&nbsp; From now on, I'll
 refer to Intermetrics's variant of XPL as <i>XPL/I</i> to distinguish it from the standard.<br>
<br>
In short, if you actually had a compiler for standard XPL that you could
 use on (say) a Windows, Mac OS, or Linux computer, it would neither 
compile most XPL/I programs, nor would most of those compiled programs 
run correctly afterwards if you were able to do so.&nbsp; Consider the 
following brief example of a program that relies on XPL/I extensions to 
XPL:<br>
<blockquote>
  <pre><font color="#663333">declare x fixed, y fixed, z fixed;<br>x(0) = 1;<br>x(1) = 2;<br>x(2) = 3;<br>output = x(0) || ' ' || x(1) || ' ' || x(2);<br></font><font color="#663333">output = x || ' ' || y || ' ' || z;</font><br></pre>
</blockquote>
What is this little example supposed to do?&nbsp; First, it declares 3 variables of the <font color="#663333"><code>fixed</code></font> datatype; <font color="#663333"><code>fixed</code></font> means that <font color="#663333"><code>x</code></font>, <font color="#663333"><code>y</code></font>, and <font color="#663333"><code>z</code></font> are 32-bit integers.&nbsp; It then proceeds to use <font color="#663333"><code>x</code></font>
 <i>as if</i> it were a three-element array, though <font color="#663333"><code>x</code></font> wasn't declared that 
way, assigning values to each of its elements.&nbsp; In other words, the program assumes that <font color="#663333"><code>x(0)</code></font> corresponds to <font color="#663333"><code>x</code></font>, <font color="#663333"><code>x(1)</code></font> corresponds to <font color="#663333"><code>y</code></font>, and <font color="#663333"><code>x(2)</code></font> corresponds to <font color="#663333"><code>z</code></font>.&nbsp; Finally, the program "prints out" both the elements of <font color="#663333"><code>x</code></font> (as an array) and the values of <font color="#663333"><code>x</code></font> (as a non-array), <font color="#663333"><code>y</code></font>, and <font color="#663333"><code>z</code></font>.&nbsp; Naturally, those two lines of printout are identical.<br>
<blockquote><font size="-1"><b>Aside:</b> In case you're wondering, we <i>could</i> have used <font color="#663333"><code>x(-1)</code></font> or <font color="#663333"><code>x(3)</code></font>
 in our little program to read or write areas of memory in which no 
variables at all had been declared.&nbsp; Or if we had declared 
variables of some other datatype than <font color="#663333"><code>FIXED</code></font>, we could have used this same trick to access them as if they were </font><font size="-1"><font size="-1"><font color="#663333"><code>FIXED</code></font></font>.</font><br>
</blockquote>
The interchangeability of scalar variables with array variables is <i>not</i>
 allowed in standard XPL, or — if you'll allow some editorializing on my
 part — in any rational development tool supporting development of a 
high-reliability application.&nbsp; Indeed, <i>standard</i> XPL was a 
strictly-typed language, and McKeeman tells us explicitly that XPL 
enforced the declared array bounds.&nbsp; As for whether relaxation of 
these rules is a "feature" 
of XPL/I, or 
whether it's just sloppiness by Intermetrics's XPL/I 
compiler is hard to say from this remove in time.&nbsp; Perhaps some 
members of the development team were simply so young and so steeped in 
IBM System/360 expertise that it never occurred to them that exploiting 
its undocumented features wasn't a great idea from a wider perspective. 
Whatever the explanation, what <i>can</i> be said is that the 
writers of the XPL/I source code for Intermetrics's HAL/S compiler relied on
this "feature", and used it ... a lot!&nbsp; So in the end, whether it's a "feature" versus an exploited
bug is irrelevant; what's relevant is that it has to be supported by any XPL/I compiler we deploy today.<br>
<blockquote><font size="-1"><b>Aside:</b>&nbsp; Incidentally, <a moz-do-not-send="true" href="https://sourceforge.net/projects/xpl-compiler/">Daniel 
Weaver has written an XPL-to-C translator</a>, which as far as I know is
 the
 only existing XPL compiler (prior to the present Virtual AGC 
development effort) capable of being used on a modern computer without 
somehow simulating a legacy computer system as well.&nbsp; 
The first thing anyone suggests to me when this topic is discussed is 
"Why don't you just use it?"&nbsp; The array sloppiness inherent in 
actual usage of XPL/I is one good reason.&nbsp; As you might expect, 
Daniel's translator cannot
 compile the XPL/I example program above.&nbsp; And why in the world 
would anybody expect it to?&nbsp; Here's a fun printout of what you get 
if you try to do so:<br>
  </font>
  <blockquote>
    <pre><font size="-1">XPL to C language translator -- version 1.1<br>2    |x(0) = 1;                                                                       |<br>           |<br>*** Error, Identifier is not an array (detected at line 5741 in xcom). ***<br>3    |x(1) = 2;                                                                       |<br>           |<br>*** Error, Identifier is not an array (detected at line 5741 in xcom). ***<br>*** Last previous error was detected on line 2. ***<br>4    |x(2) = 3;                                                                       |<br>           |<br>*** Error, Identifier is not an array (detected at line 5741 in xcom). ***<br>*** Last previous error was detected on line 3. ***<br>5    |output = x(0) || ' ' || x(1) || ' ' || x(2);                                    |<br>                    |<br>*** Error, Identifier is not an array (detected at line 5741 in xcom). ***<br>*** Last previous error was detected on line 4. ***<br>5    |output = x(0) || ' ' || x(1) || ' ' || x(2);                                    |<br>                                   |<br>*** Error, Identifier is not an array (detected at line 5741 in xcom). ***<br>*** Last previous error was detected on line 5. ***<br>5    |output = x(0) || ' ' || x(1) || ' ' || x(2);                                    |<br>                                                 |<br>*** Error, Identifier is not an array (detected at line 5741 in xcom). ***<br>*** Last previous error was detected on line 5. ***<br>6 cards containing 7 statements were compiled.<br>6 errors (0 severe) were detected.<br>The last detected error was on line 5.</font><br></pre>
  </blockquote>
</blockquote>But that's just <i>one</i> example of an XPL/I extension to XPL.&nbsp; Playing fast 
and loose with arrays versus scalars is far from the only difference 
between XPL and XPL/I.&nbsp; To be fair, I'll admit that it's 
hard to make a list of all differences between XPL and XPL/I, because 
neither is McKeeman a full and accurate description of XPL, nor is 
Intermetrics documentation a full description of XPL/I.&nbsp; Nor did 
Intermetrics use the term "XPL/I", simply calling their language "XPL", and 
making it hard to be entirely sure what's supposed to be different between them and what's not.&nbsp; <br>
<br>
By the way, I recognize that it's very dangerous to make claims about what other people <i>haven't</i>
 accomplished, so you have to take it with a grain of salt when I say 
that you're not going to find any existing compiler for Windows, Mac, or
 Linux that can compile and run XPL/I programs.&nbsp; If you find out 
that I don't know what I'm talking about, by all means let me 
know!&nbsp; <br>
<blockquote><font size="-1"><b>Aside:</b> In point of fact, I do know of another XPL/I compiler currently under
 development, though not yet fully ready for use.&nbsp; Indeed, it was a discussion with the author of that compiler, </font><font size="-1"><font size="-1">Don Schmidt, </font>prior to the start of his own work, which motivated me to look into this topic to begin with.</font><br>
</blockquote>
With that said, 
as far as I can tell, if you want to compile
 Intermetrics's HAL/S compiler, you're going to have to rely on a 
newly-written XPL compiler having XPL/I support baked into it from the 
ground up, rather than hoping to somehow tack XPL/I capabilities onto 
some existing XPL compiler.&nbsp; And that's what's discussed throughout
 the remainder of this page.&nbsp; I call the new compiler <b>XCOM-I</b>, for <b>XCOM</b> (the name of McKeeman's original XPL compiler) and "I" (for "Intermetrics").<br>
<br>
Like Daniel Weaver's XPL translator, and Don Schmidt's compiler in development, <b>XCOM-I</b> is actually an XPL/I-to-C translator, though it is entirely new and is 
not based on Daniel's work nor on any of the original XPL 
compilers. In most cases, <b>XCOM-I</b> should work for standard XPL programs too, but not always.<br>
<blockquote><font size="-1"><b>Aside:</b> And in case you wonder, <b>XCOM-I</b>
 does translate the sample XPL/I program given above to C without error;
 the C program it creates also compiles without errors; and if you run the compiled C 
program you get what you might expect:<br>
  </font>
  
<blockquote>
  <pre><font size="-1">PAGE 1<br><br><br>1 2 3<br>1 2 3</font><br></pre>
</blockquote>

</blockquote>
However ... there's one final complication:&nbsp; Another thing the 
original Intermetrics authors did in the XPL/I source code they wrote 
was to intersperse it (thankfully, sparingly!) with code written in IBM 
System/360 Basic Assembly
 Language (BAL).&nbsp; Unfortunately, <b>XCOM-I</b> cannot translate BAL into 
anything meaningful.&nbsp; But <b>XCOM-I</b> does provide hooks so that you can 
patch in replacement code, written in C, for the embedded BAL 
code.&nbsp; 
Those hooks will be discussed below, although little guidance can be 
given on writing a C patch that can replace arbitrary BAL source code.<br>
<h1><a name="compiling"></a>Processing a Program Written in XPL, Using XCOM-I<br>
</h1>
<p>Despite the title of this section, there's actually no difference between how to build and run XPL/I programs than XPL programs.&nbsp; Once you know how to build and run an XPL program, you'll automatically know how to build and run an XPL/I program.<br></p>
<p>With that said, the XPL/I source code available to us dwarfs the XPL source code we have for any standard XPL programs we have.&nbsp; Moreover, those XPL/I programs are much larger and more complex than the XPL programs.&nbsp; This means that there are differences in how the source code for the two is organized and maintained.&nbsp; In that sense we find differences in how to deal with the two.&nbsp; That's why I concentrate at first on compiling standard XPL programs, and defer some discussion of XPL/I compilation until later.
</p>

<h2><a name="installation"></a>Installation of XCOM-I<br>
</h2><b>XCOM-I</b> is a program written in the Python 3 language.&nbsp; To install <b>XCOM-I</b> on your system, you simply need to copy <a moz-do-not-send="true" href="https://github.com/virtualagc/virtualagc/tree/XCOM-I/XCOM-I">the folder called "XCOM-I" of the "XCOM-I" branch of the Virtual AGC software repository</a>
 onto your computer, and add that directory to your PATH.&nbsp; Running <b>XCOM-I</b> requires Python 3.7 or later, but I don't think it requires additional 
installation of any Python modules not present in a normal Python 
distribution.&nbsp; <br>
<br>
Compiling the C programs created by running <b>XCOM-I</b> using the 
simplest variation of the instructions given below assumes that the GNU <b>gcc</b> C compiler and the GNU <b>make</b> program are also installed on your computer.&nbsp; Using alternatives may be possible, probably easily, but I 
have no way to personally survey every possible combination of development tools. <br>
<h2><a name="xpl"></a>Compiling and Running an XPL Program<br>
</h2>
There are several standard XPL programs present in the folder 
XCOM-I/Tests/.&nbsp; It would be a mistake to think any of them are 
user-friendly.&nbsp; But they do illustrate the principles involved.<br>
<blockquote><font size="-1"><b>Aside:</b> You'd also be very mistaken to
 imagine that <b>XCOM-I</b> itself is user-friendly.&nbsp; I fear that there will be a
 lot of work involved before the error messages <b>XCOM-I</b> spits out upon 
occasion can be mistaken for anything <i>other</i> than spit.&nbsp; Until then, try not to make any errors in your XPL programming.</font><br>
</blockquote>

<blockquote><font size="-1"><b>Aside:</b>&nbsp; Throughout this 
discussion, I use the Linux/Mac convention that the symbol '/' is used 
to separate the components of a filename and the path to the folder 
containing it.&nbsp; Windows uses the separator '\' instead, so in some 
places you may find that you need to replace '/' by '\'.</font><br>

</blockquote>
<ul></ul>
<p>For the sake of discussion, suppose we wish to compile and run the sample program called Example-6.18.6.xpl.&nbsp; The first step is to use <b>XCOM-I</b> to translate Example-6.18.6.xpl into C source code:
</p>

<blockquote>
  <pre><font color="#663300">cd XCOM-I<br>XCOM-I.py Tests/Example-6.18.6.xpl<br></font></pre><font color="#663300">
</font></blockquote><font color="#663300">
</font>This will create a sub-folder called Example-6.18.6/ of the current
 working folder, and put all of the files of the C translation into that
 folder.&nbsp; <br>
<blockquote><font size="-1"><b>Aside:</b>&nbsp; XCOM-I.py has various 
allowable command-line options, though none were needed in the 
invocation shown above.&nbsp; You can see a list of XCOM-I.py's 
command-line options with
 the command <br>


  </font>
  <blockquote>
    <pre><font size="-1" color="#663300">XCOM-I.py --help</font><br></pre>
  </blockquote>
</blockquote>
<blockquote>
</blockquote>
I won't bore you with a lengthy description of the C files output by <b>XCOM-I</b>, 
but it might be mildly instructive to glance briefly at a couple of 
them.&nbsp; For this example, the principal outputs are the files 
RANDOM.c and main.c, and here you can see a comparison of the original 
XPL file (left) to the C translation of them (right):<br>
<table align="center" cellspacing="40" cellpadding="2" border="1">
  <tbody>
    <tr>
      <td valign="middle">
        <pre><font color="#663300">/* This is example XPL program 6.18.6 from McKeeman p. 157.<br>   The book only provides PROCEDURE RANDOM, which is transcribed as-is.<br>   The top-level code that exercises RANDOM is new. */<br>   <br>RANDOM:<br>  procedure(range) fixed;<br>    /*  Returns a random integer in the range 0 to range - 1  */<br>    <br>    declare range fixed, rbase fixed initial(1),<br>      rmult literally '671297325';<br>      <br>    rbase = rbase * rmult;<br>    <br>    return shr(shr(rbase, 16) * range, 16);<br>    <br>  end RANDOM;<br><br>declare i;<br><br>do i = 1 to 100;<br>  output = RANDOM(100000);<br>end;<br><br>eof</font><br></pre>
      </td>
      <td valign="top">
        <pre><font color="#663300">/*<br>  File RANDOM.c generated by XCOM-I, 2024-04-16 08:46:47.<br>*/<br><br>#include "runtimeC.h"<br>#include "procedures.h"<br><br>int32_t<br>RANDOM(void)<br>{<br><br>  // rbase = rbase * rmult; (2)<br>  {<br>    int32_t numberRHS = xmultiply(getFIXED(8), 671297325);<br>    putFIXED(8, numberRHS);<br>  }<br>  // return shr(shr(rbase, 16) * range, 16); (3)<br>  return SHR(xmultiply(SHR(getFIXED(8), 16), getFIXED(4)), 16);<br>}<br><br>/*<br>  File main.c generated by XCOM-I, 2024-04-16 08:46:47.<br>  XPL/I source-code file used: Example-6.18.6.xpl.<br>  To build the program from the command line, using defaults:<br>          cd Example-6.18.6/<br>          make<br>  View the Makefile to see different options for the `make`<br>  command above.  To run the program:<br>          Example-6.18.6 [OPTIONS]<br>  Use `Example-6.18.6 --help` to see the available OPTIONS.<br>*/<br><br>#include "runtimeC.h"<br>#include "procedures.h"<br><br>/*<br>  Memory Map:<br>           Address (Hex)        Data Type        Variable<br>           -------------        ---------        --------<br>              0 (000000)        FIXED            I<br>              4 (000004)        FIXED            RANDOMxRANGE<br>              8 (000008)        FIXED            RANDOMxRBASE<br>*/<br><br>int<br>main(int argc, char *argv[])<br>{<br><br>  if (parseCommandLine(argc, argv)) exit(0);<br><br>  // do i = 1 to 100; (0)<br>  {<br>    int32_t from0, to0, by0;<br>    from0 = 1;<br>    to0 = 100;<br>    by0 = 1;<br>    for (putFIXED(0, from0);<br>         getFIXED(0) &lt;= to0;<br>         putFIXED(0, getFIXED(0) + by0)) {<br>      // output = RANDOM(100000); (1)<br>      {<br>        int32_t numberRHS = ( putFIXED(4, 100000), RANDOM() );<br>        string_t stringRHS;<br>        strcpy(stringRHS, fixedToCharacter(numberRHS));<br>        OUTPUT(0, stringRHS);<br>      }<br>    }<br>  } // End of DO for-loop block<br><br>  if (LINE_COUNT)<br>    printf("\n"); // Flush buffer for OUTPUT(0) and OUTPUT(1).<br>  return 0; // Just in case ...<br>}<br></font><br></pre>
      </td>
    </tr>
  </tbody>
</table>
The comparison, I think, is both tantalizing and mysterious.&nbsp; Tantalizing, because you can <i>almost</i> see how it works.&nbsp; And mysterious, because you can't <i>quite</i> see it.&nbsp; But I digress!<br>
<br>
The next step, of course, is to compile the C programs.&nbsp; If your 
setup is like mine, namely a Linux system with <b>gcc</b> as the default C 
compiler, then compilation can be accomplished like this, assuming that you're still in the XCOM-I/ working directory:<font color="#663300"><code></code></font><br>
<font color="#663300"><code></code></font><blockquote><font color="#663300"><code>
make -C Example-6.18.6</code><br>


</font></blockquote><font color="#663300">
</font>This just produces an executable program within the Example-6.18.6/ folder that's also called <b>Example-6.18.6</b>.<br>
<br>
But the world being what it is, you most likely <i>don't</i> have a 
setup like mine, so some alterations in the instructions above may be needed
needed.&nbsp; For one thing, your C compiler may not be <b>gcc</b>.&nbsp; 
Actually, the default assumption isn't that the compiler is <b>gcc</b>, but 
rather that the shell's environment variable CC<code></code> holds the 
name of the compiler.&nbsp; But if you're not using <b>gcc</b>, I'm sure there are 
other C compilers that would work.&nbsp; For example, suppose you use <b>clang</b>. Just change the build commands to read:<br>
<blockquote><font color="#663300"><code>cd XCOM-I</code><br>

  <code>
make -C Example-6.18.6 CC=clang</code></font><br>
</blockquote>


Or if you're on Windows — and who isn't, really? — then you'd want to 
add the filename extension ".exe" to your executable.&nbsp; That's done 
like so:<br>
<blockquote><font color="#663300"><code>cd XCOM-I</code><br>

  <code>
make -C Example-6.18.6 TARGET=Example-6.18.6.exe</code></font><br>
</blockquote>
The Makefile itself lists other possible alterations, any or all of which can be used in combination with the others.<br>
<br>
Finally, you can now run the program:<br>
<blockquote>
  <pre><font color="#663300">Example-6.18.6/Example-6.18.6</font></pre>
</blockquote>What this particular sample program does is just to print 100 random numbers, so that's what should happen.<br>
<blockquote><font size="-1"><b>Aside:</b> Just like XCOM-I, the compiled
 application also has a variety of command-line options that may affect 
how it runs.&nbsp; None of them are really applicable to this particular
 sample program, but you could see them with the command</font><br>
<blockquote>
<pre><font size="-1" color="#663300">Example-6.18.6/Example-6.18.6 --help</font></pre>
</blockquote>
</blockquote>

If you want to see a much meatier sample program in standard XPL, you 
can look instead at the <b>ANALYZER</b> program, Tests/ANALYZER.xpl.&nbsp; <br>
<blockquote><font size="-1"><b>Aside:</b>&nbsp; I originally found the source code presented for <b>ANALYZER</b>
 online, and don't actually know if it's precisely the same source code 
as given in McKeeman.&nbsp; At least, not without much more-detailed 
checking than I have any desire to do.&nbsp; I have definitely seen <i>some</i>
 differences from the book, but suspect that the book may have errors 
(gasp!) due to typesetting process.&nbsp; Whether there are differences 
not accounted for by typesetting, I cannot say.</font><br>
</blockquote>
If you have a copy, McKeeman (see Section 7.1, Chapter 10, and Appendix 
6) provides reasonably-detailed operating instructions and theory of 
operation for the program.&nbsp; Basically, <b>ANALYZER</b> is used for 
analyzing a given BNF grammar and printing a report about it.&nbsp; Thus McKeeman recommends <b>ANALYZER</b>
 for 
developing BNF grammars and debugging them.&nbsp; There's an associated 
data file as well, SKELETON.xpl, which contains the BNF description for a
 very simple grammar that's the basis for some of the discussion in the 
book.&nbsp; The steps for compiling and running <b>ANALYZER</b> with SKELETON.bnf as input are just what you'd expect from the discussion earlier:<br>
<blockquote>
  <pre><font color="#663300">cd XCOM-I<br>XCOM-I.py Tests/ANALYZER.xpl
make -C ANALYZER
ANALYZER/ANALYZER &lt;Tests/SKELETON.bnf<br></font></pre></blockquote>
<blockquote>
</blockquote>
If you're interested, you can compare <a moz-do-not-send="true" href="SKELETON-XCOM-I.pdf">the report on the SKELETON grammar produced by the steps above,</a> versus <a moz-do-not-send="true" href="SKELETON-McKeeman.pdf">the report printed in Figure 7.1.6 of McKeeman</a><a moz-do-not-send="true" href="file:///home/rburkey/git/virtualagc-web/SKELETON-McKeeman.pdf"> in 1969 </a>.&nbsp; <br>
<blockquote><font size="-1"><b>Note:</b>&nbsp; Sadly, the book is still 
under copyright, though long out of print, so I'm departing from my 
normal policy ("no copyrighted material!") by showing you the 1969 
report.&nbsp; I'm trusting Prentice-Hall not to start chasing me with 
hatchets to recover imaginary lost profits.&nbsp; If they do, I'll 
remove the scan of Figure 7.1.6 and just <i>tell</i> you that it looks 
the same as the report I generated myself, apart from differences 
explainable as editorial/typographical decisions back when the book was 
published.)</font><br>
</blockquote>
The Tests/ folder also contains a similar&nbsp; but more-complex BNF 
grammar that's purportedly for XPL itself, namely XPL.bnf, and you can 
also run <b>ANALYZER</b> on it in a <i>similar</i> but not identical 
manner.&nbsp; I say "purportedly" not because I doubt it, but because I 
found it online and don't really know anything about.&nbsp; These BNF 
files used as input to <b>ANALYZER</b> could contain directives that 
activated otherwise-inactive program options.&nbsp; In particular, 
XPL.bnf contains a directive that reads "$PUNCH", which tells analyzer 
to output some data to "device" (i.e., file) number 2.&nbsp; But device 
number 2 isn't attached by default to any file, so <b>ANALYZER</b> would immediately abort with an error message if we didn't take any additional action to attach a file to device 2.&nbsp; <i>Originally,</i> this was done via "DD" statements in Job Control Language (JCL) "DD" statements.&nbsp; Naturally, we have no JCL in our <b>XCOM-I</b> based system.&nbsp; What we have instead are command-line options that tell <b>ANALYZER</b> to attach files to device numbers, thusly:<br>
<blockquote>
  <pre><font color="#663300">ANALYZER/ANALYZER --ddo=2,PUNCH.txt &lt;Tests/XPL.bnf</font></pre>
</blockquote>
For a <i>still meatier</i> sample program, we can turn to the source code of the original XPL compiler itself, <b>XCOM</b>.&nbsp; <b>XCOM</b> was written in XPL, so perhaps we can compile it using <b>XCOM-I</b>.&nbsp; Like <b>ANALYZER</b>, the source code for <b>XCOM</b> is in McKeeman (Appendix 3), but also like <b>ANALYZER</b>,
 the source code we have is something I found online, and I have no idea
 whether it's identical to the book or not.&nbsp; If we can get that to 
work, we'll have the dubious pleasure of being able to use it to compile
 standard XPL programs to IBM System/360 basic assembly language.&nbsp; 
But it's the modern-compilation principle that's important here, not <b>XCOM</b>'s utility.<br>
<br>
TBD<br>
<h1><a name="xpli"></a>A Primer for Standard XPL and Intermetrics XPL/I</h1>


<p>It is a truth universally acknowledged that there is no satisfactory introductory information available concerning programming in XPL.&nbsp; Or at least, it <i>would</i> be universally acknowledged if anybody had ever heard of XPL and wanted to use it for anything.&nbsp; <br></p>
<p>The best you can do, generally speaking, is to purchase a used copy of McKeeman (i.e., <i>A Compiler Generator</i>).&nbsp; If you do, you'll find a book that's densely packed with information, but that information is the source code for an XPL compiler (written in XPL), lots of BNF descriptions of the language, lots of theory on how to write a compiler-generator program, and very little of direct interest to a programmer who wants to come up to speed quickly on how to write or understand a program written in XPL.&nbsp; And as a bonus, the book provides an index of almost no use at all.&nbsp; Besides which, most online information about XPL, in my experience, is a simple abridgement or other rehashing of <i>A Compiler Generator</i>, and adds little extra of value in a tutorial sense.&nbsp; With that said, you may find some useful online information in a couple of places:<br></p>

<ul>
  <li>&nbsp;<a moz-do-not-send="true" href="https://sourceforge.net/projects/xpl-compiler/">Daniel Weaver provides some documentation (in particular, his xpl.pdf) with his XPL-to-C translator program</a>.</li>
  <li>The <a moz-do-not-send="true" href="https://www.cs.toronto.edu/XPL/ldindex.html">University of Toronto XPL website has a page</a> with a small but useful transcription of some material from <i>A Compiler Generator</i> — albeit with unfortunate HTML formatting that make some of it almost unreadable.</li>
</ul>
<p>And as for Intermetrics XPL/I ... well, from a tutorial perspective, it's orders of magnitude worse.&nbsp; Enough said!
</p>

<p>Taking all of that into account, it might be reasonable to provide a full tutorial here how to write XPL or XPL/I programs.&nbsp; Perhaps I'll do that sometime.&nbsp; For now, though, I'll just cover some of the basics and quirks of the language(s).
</p>
<h2><a name="basics"></a>The Basics</h2>
<h3>Character Set</h3>
<p>The most basic characteristic of a language is the character set in which the language is expressed.&nbsp; Neither McKeeman nor Intermetrics specifies the character set.&nbsp; I've given it a lot of thought, and my conclusion is that the originally-supported character set was:
</p>
<p align="center">&lt;space&gt;<br>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z<br>a b c d e f g h i j k l m n o p q r s t u v w x y z<br>0 1 2 3 4 5 6 7 8 9<br>_ % + - * . / | &amp; = &lt; &gt; # @ $ , ; : ( ) ' " ! ? <br>¢ ¬</p>
<p>You'll notice that several characters common today were not originally supported, including:</p>
<p align="center">` ~ ^ [ ] { }</p>

<p>Contrariwise, there are two characters (¢ and ¬) that don't exist at all in the 7-bit ASCII character set that's the common core for the character sets typically used today when writing software source code.&nbsp; Therefore, when working with <b>XCOM-I</b>, we use the characters ~ and ^ interchangeably with ¬ (but prefer ~).&nbsp; Similarly, we use ` in preference to ¢.&nbsp; These substitutions allow us to completely translate the original XPL or XPL/I source code back-and-forth between the original EBCDIC and ACII without any loss of information, and without insisting that you adopt any specific "locale" like ISO-8859-15 or UTF-8 for your computer that's not optimal for your other (non-XPL'ing) activities.&nbsp; With that said, I <i>hope</i> that you could use ¢ and ¬ in your XPL/I source code, if you insist on doing so, but I do not guarantee it.<br></p>
<blockquote>
  <p><font size="-1"><b>Aside:</b> All previously-existing XPL or XPL/I source code I've found, or HAL/S source code for that matter, has already substituted ~ or ^ for ¬ anyway.  And indeed, some early HAL/S documentation suggests this very substitution.  I suspect that's because some IBM printers at the time printed ~ in place of </font><font size="-1"><font size="-1">¬</font>.  But whatever the explanation, the substitutions I'm suggesting are not exactly daring in their originality.  As far as the </font><font size="-1">¢ symbol is concerned, it's not actually used in active XPL or XPL/I code, as such, but can be used in program comments to toggle various compiler options on and off, or in principle could appear within quoted strings.</font></p>
</blockquote>

<h3>Case Sensitivity</h3>
<p>XPL programs are <i>not</i> case-sensitive, except in so far as the contents of quoted strings are concerned.&nbsp; E.g., lower-case or mixed-case symbols are treated as being identical to their upper-case correspondents, but quoted strings are case-sensitive.
</p>
<h3>Identifiers</h3>
<p>Identifiers cannot begin with a digit, but otherwise consist of any sequence of upper- or lower-case alphanumeric characters, <i>or</i> any of the characters @ _ # $.&nbsp; For example, @_26$8ab# is a legal name for a variable.
</p>
<p>Identifiers cannot exceed 256 characters in length.
</p>
<h3>Datatypes</h3>
<p>There are only three basic datatypes:<br></p>
<ul>
  <li><font color="#663333"><code>FIXED</code></font> is a 32-bit signed integer.&nbsp; (Stored as 2's-complement, in big-endian byte order, vs the little-endian byte order used in most personal computers today.)<br></li>
  <li><font color="#663333"><code>BIT(n)</code></font>, where <font color="#663333"><code>n</code></font> is from 1 to 32, is an <font color="#663333"><code>n</code></font>-bit unsigned integer.&nbsp; It is apparently <i>intended</i> to provide a set of bit-fields that can be individually accessed, but the XPL language doesn't have any built-in facilities to make such access convenient, so in most respects these <font color="#663333"><code>BIT</code></font> datatypes are used as reduced-precision unsigned integers rather than as collections of logical flags.&nbsp; Note that <font color="#663333"><code>BIT(1)</code></font> through <font color="#663333"><code>B(8)</code></font> are stored in memory as single bytes, <font color="#663333"><code>BIT(9)</code></font> through <font color="#663333"><code>BIT(16)</code></font> are stored as 2-byte "half-words", and <font color="#663333"><code>BIT(17)</code></font> through <font color="#663333"><code>BIT(32)</code></font> are stored as 32-bit words.<br></li>
  <li><font color="#663333"><code>CHARACTER</code></font> is a variable-width character string, with a string-length limited to 256 or less.&nbsp; Strings are stored as a 32-bit unsigned integer known as a <i>descriptor</i>, paired with a separate area from 1 to 256 bytes containing the individual characters of the string, encoded in EBCDIC.&nbsp; The descriptor has 8 bits specifying the string length (minus 1) and 24-bits providing the starting memory-address of the character data.</li></ul>
<blockquote>
  <p><font size="-1"><b>Aside:</b> The method for storing string data just described leaves no room for 0-length "empty" strings, but the XPL and XPL/I languages <i>do</i> allow for empty strings.&nbsp; The documentation simply doesn't tell use how to encode the empty strings in memory!  Nor the memories of individual developers I've consulted provide any clue on the matter.  Thus for empty strings, <b>XCOM-I</b> uses its own custom approach that may not quite match the original implementations. Specifically, <b>XCOM-I</b> uses a string descriptor with a value of 0 to represent an empty string, and does not allocate any additional storage beyond the descriptor in that case.  This isn't ambiguous, by the way, because for technical reasons I won't get into right here, a string descriptor of 0 wouldn't have been valid otherwise in XPL. </font><br></p>
</blockquote>
<ul>

</ul>

<p>The storage formats in memory duplicate those that would have been expected on an IBM System/360 computer, within the limits of my ability to infer what those formats were.&nbsp; While the storage formats are not significant in abstract terms, they'll be seen to be <i>quite</i> significant in dealing with certain aspects of HAL/S-FC's source code, such as its so-called "virtual memory" system, and indeed I think it would be impossible to run HAL/S-FC unless these underlying IBM 360 storage formats were used.
</p>
<blockquote>
  <p><font size="-1"><b>Aside:</b> In particular, it may seem at first glance that using separate storage formats for <font color="#663333"><code>BIT(8)</code></font> vs <font color="#663333"><code>BIT(16)</code></font> vs <font color="#663333"><code>BIT(32)</code></font> is an unnecessary complication.&nbsp; Why not just use 32-bit integers to store each of these types, thus treating them in a uniform way?&nbsp; There are two reasons: First, McKeeman (p. 134) explicitly states that this is the amount of storage used.&nbsp; Second, and more important, the built-in XPL <font color="#663333"><code>FILE</code></font> function expects to use </font><font size="-1"><font size="-1"><font color="#663333"><code>BIT(8)</code></font></font> buffers for transferring data between random-access files and memory.&nbsp; If </font><font size="-1"><font size="-1"><font color="#663333"><code>BIT(8)</code></font></font> used 4 bytes per entry rather than 1 byte per entry, the </font><font size="-1"><font size="-1"><font color="#663333"><code>FILE</code></font></font> function would no longer behave as expected with existing XPL programs.<br></font></p>
<p><font size="-1"><b>Note:</b> McKeeman indicates support for bit strings as long as <font color="#663333"><code>BIT(2048)</code></font>.&nbsp; There are no uses of such longer strings HAL/S-FC's XPL source code, nor in any available standard-XPL software.&nbsp; So I've simply chosen not to deal with them.  There's no support for bit-strings longer than 32 in <b>XCOM-I</b>.<br></font></p>

</blockquote>
These basic datatypes can also be declared in single-dimension arrays. 
Multi-dimensional arrays are not allowed.&nbsp; There is no maximum 
array length beyond the available memory.&nbsp; Array indices start at 
0.&nbsp; It is important to realize that an array of <font color="#663333"><code>CHARACTER</code></font>
 is not an array of characters, but rather an array of 
string-descriptors of strings; in particular, you cannot use subscripting to access an 
individual character in a string.&nbsp; Nor is a <font color="#663333"><code>BIT(n)</code></font> variable an array of <font color="#663333"><code>n</code></font> bits, other than in an abstract sense, because you cannot use subscripting to access an individual bit.<br>
<br>
Variables are <i>supposedly</i> strictly typed, and every variable used 
must have an associated declaration statement, though we've already seen
 examples of the casual way XPL/I treats XPL's strict typing.<br>
<br>
Here are a few examples of declarations of variables, both scalar and array:<br>
<blockquote>
  <pre><font color="#663300">DECLARE F FIXED, C CHARACTER, B BIT(5);<br>DECLARE FS(10) FIXED, CS(10) CHARACTER, BS(10) BIT(5);</font><br></pre>
</blockquote>

These are pretty self-explanatory in most ways, so I won't dissect them 
for you in detail.&nbsp; What's perhaps most confusing is that the three
 arrays declared here (<font color="#663300"><code>FS</code></font>, <font color="#663300"><code>CS</code></font>, and <font color="#663300"><code>BS</code></font>) each have <i>eleven</i>
 elements in them, because the number 10 in their declarations is not 
the number of elements, but rather the highest legal index.&nbsp; As 
mentioned above, indices start at 0, so the total number of elements in 
each is 11. <br>
<br>
XPL/I provides a separate kind of statement which can declare arrays, which syntactically differs only in that the keyword <font color="#663300"><code>ARRAY</code></font> is used in place of the keyword <font color="#663300"><code>DECLARE</code></font>, and in that it can only be used for arrays of <font color="#663300"><code>FIXED</code></font> or <font color="#663300"><code>BIT</code></font>, and not for <font color="#663300"><code>CHARACTER</code></font>.<br>
<blockquote><font size="-1"><b>Aside:</b> For the original XPL/I compiler, there was a distinction in the way <font color="#663300"><code>ARRAY</code></font> variables were stored in memory vs <font color="#663300"><code>DECLARE</code></font> variables.&nbsp; At the present time, I don't see this distinction as being operationally significant, so <b>XCOM-I</b> treats the two keywords identically.&nbsp; This is subject to change, if I discover my thinking was in error.</font><br>
</blockquote>

XPL/I adds an additional kind of datatype that it calls a <font color="#663300"><code>BASED</code></font> variable.&nbsp; These are basically <i>pointers</i> to arrays of <font color="#663300"><code>FIXED</code></font>, <font color="#663300"><code>BIT</code></font>, or <font color="#663300"><code>CHARACTER</code></font>.&nbsp; By changing the address stored in the <font color="#663300"><code>BASED</code></font>
 variable's pointer, you can instantly interpret an entirely different 
chunk of memory as the array.&nbsp; Moreover, besides the basic types 
just mentioned, the <font color="#663300"><code>BASED</code></font> variable can point to an array of "records", where each "record" is a collection of the basic 
datatypes.&nbsp; I.e., a record can hold any combination of <font color="#663300"><code>FIXED</code></font>, <font color="#663300"><code>BIT</code></font>, or <font color="#663300"><code>CHARACTER</code></font> fields, or arrays thereof.&nbsp; Using the <font color="#663300"><code>BASED</code></font>
 mechanism, XPL/I can thus mimic both pointers and primitive types of 
structures, neither of which is available in XPL proper.&nbsp; I say 
that the structures are "primitive", because <font color="#663300"><code>BASED</code></font> variables cannot be fields of <font color="#663300"><code>BASED</code></font> variables, and only structures that are a single-level deep are available.&nbsp; <br>
<br>
Here are a couple of examples of declarations of <font color="#663300"><code>BASED</code></font> variables:<br>
<blockquote>
  <pre><font color="#663300">BASED FB FIXED;<br>BASED RB RECORD:<br>    F FIXED,<br>    C CHARACTER,<br>    A(10) BIT(5),<br>END;</font><br></pre>
</blockquote>

Although <font color="#663300"><code>BASED</code></font> variables are always (or almost always) arrays, you'll note that the declarations of <font color="#663300"><code>FB</code></font> and <font color="#663300"><code>RB</code></font>
 don't indicate any dimensional information.&nbsp; That's because no 
memory for them, other than for the pointer, is allocated at 
compile-time.&nbsp; Space is instead explicitly allocated at runtime by 
user code.&nbsp; Thus <b>XCOM-I</b> has knowledge of the <i>size</i> of each array entry, but not of the <i>number of elements</i> in the array.&nbsp; <br>
<br>
To allocate the space, you have to know the sizes of the array entries, which in this case is 4 bytes for <font color="#663300"><code>FB</code></font> (because the entry is a <font color="#663300"><code>FIXED</code></font>, which is 32 bits long) and 19 bytes for <font color="#663300"><code>RB</code></font> (4 bytes for <code>FIXED</code> field <code>F</code>, 4 bytes for <code>CHARACTER</code> field <code>C</code>, and 11 bytes for the 11-element <code>BIT(5)</code> array <code>A</code>).&nbsp; And yes, you <i>do</i>
 have to explicitly perform this size calculation for yourself, and 
XPL/I won't help you do it!&nbsp; Blame Intermetrics for that, not <b>XCOM-I</b>.&nbsp; Suppose, for example, that we wanted <font color="#663300"><code>FB</code></font> and <font color="#663300"><code>RB</code></font> to each have 101 elements.&nbsp; The allocation process at runtime involves the XPL/I built-in <font color="#663300"><code>MONITOR</code></font> function.&nbsp; Here's what the XPL/I code looks like:<br>
<blockquote>
  <pre><font color="#663300">CALL MONITOR(6, ADDR(FB), 101 * 4);<br>CALL MONITOR(6, ADDR(RB), 101 * 19);</font><br></pre>
</blockquote>
<blockquote><font size="-1"><b>Aside:</b> <font color="#663300"><code>ADDR</code></font> is an XPL built-in that returns the memory address associated with any identifier or array reference.<br>
    <br>
    <b>Aside:</b> <font color="#663300"><code>MONITOR</code></font> provides lots of different kinds of functionality beyond just allocation of <font color="#663300"><code>BASED</code></font> variables.&nbsp; Quite a lot of information about the various types of </font><font size="-1"><font size="-1"><font color="#663300"><code>MONITOR</code></font></font> calls in XPL/I</font><font size="-1"><font size="-1"> — </font>though alas, not all of them — can be found <a moz-do-not-send="true" href="https://www.ibiblio.org/apollo/Shuttle/19700020796.pdf#page=826">in section 13.3 of Intermetrics document IR-182-1</a>.</font><br>
</blockquote>
Having allocated the space, you can now use <font color="#663300"><code>FB</code></font> just like any other array of <font color="#663300"><code>FIXED</code></font>, such as in assignments like "<font color="#663300"><code>FB(27) = 6;</code></font>" or "<font color="#663300"><code>X = FB(N) + 12;</code></font>".<br>
<br>
Accessing <font color="#663300"><code>RB</code></font>, on the other hand, uses the dotted style today used for accessing fields of structures.&nbsp; Some examples include:<br>
<blockquote>
  <pre><font color="#663300">RB(6).F = 12;<br>RB(10).C = 'XPL is where it is at!';<br>RB(20).A(6) = 15;<br>X = RB(6).F;</font><br></pre>
</blockquote>
and so on.<br>
<br>
The <font color="#663300"><code>CALL MONITOR(6, ...)</code></font> statements sampled above allocate space for the <font color="#663300"><code>BASED</code></font> variables from the pool of free memory.&nbsp; There's another possibility with <font color="#663300"><code>BASED</code></font>
 variables, though, and that's to alias them to previously-allocated 
memory, or even to static memory spaces allocated at compile-time by <b>XCOM-I</b>.&nbsp;
 The virtual memory system in HAL/S-FC uses this capability, I believe, 
to swap blocks of data in memory with blocks in random-access 
files.&nbsp; Suppose, for example, that you wanted to alias <font color="#663300"><code>RB</code></font> with the pre-existing array called <font color="#663300"><code>BUFFER</code></font>, rather than allocating any new memory for it.&nbsp; The syntax for that is:<br>
<blockquote>
  <pre><font color="#663300">COREWORD(ADDR(RB)) = ADDR(BUFFER);</font><br></pre>
</blockquote>
<blockquote><font size="-1"><b>Aside:</b> <font color="#663300"><code>COREWORD</code></font> is another XPL built-in, which returns the <font color="#663300"><code>FIXED</code></font> value stored at a given address in memory, or allows modification of that value.<br>
  </font></blockquote>
You may not like this too much.&nbsp; I don't, myself.&nbsp; But I 
reiterate, this is the documented mechanism invented by Intermetrics, 
and used in XPL/I source code like HAL/S-FC.&nbsp; It's not my invention
 or some wacky innovation in <b>XCOM-I</b>.<br>
<h3>COMMON Memory</h3>
XPL/I also introduces the notion of <font color="#663300"><code>COMMON</code></font> memory, not present in XPL.&nbsp; The notion behind <font color="#663300"><code>COMMON</code></font>
 memory is that a very large application program like HAL/S-FC won't be 
loaded entirely in memory at once, but will instead be run as a sequence
 of "passes".&nbsp; <br>
<br>
Thus, HAL/S-FC isn't a single application program, but rather a set of 
them:&nbsp; PASS1, FLO, OPT, AUX, PASS2, PASS3, and PASS4.&nbsp; Each of
 these applications is loaded, run, and discarded, in succession.<br>
<br>
But!&nbsp; Each of these application programs may receive some kind of 
input data or state data from the preceding application program, and 
transmit output data or state data to the next application program in 
succession.&nbsp; In XPL/I's visualization, <i>some</i> of that data is 
passed in files.&nbsp; But other of that data is instead just assumed to
 remain in computer memory, unchanged from whatever the preceding 
application has left behind.&nbsp; The term XPL/I applies to this 
leftover memory is <font color="#663300"><code>COMMON</code></font>.&nbsp; It's formalized by explicitly declaring variables as being in <font color="#663300"><code>COMMON</code></font>.&nbsp; Variables declared to be in <font color="#663300"><code>COMMON</code></font>
 are not initialized by an XPL/I program, but are simply assumed to 
already contain the data needed.&nbsp; Variables not declared <font color="#663300"><code>COMMON</code></font>
 are up for grabs, and no assumption can be made about their initial 
contents other than whatever initialization their declarations 
explicitly provide.<br>
<br>
Syntactically, <font color="#663300"><code>COMMON</code></font> data is declared in XPL/I by three methods:<br>
<ul>
  <li>Using the keyword <font color="#663300"><code>COMMON</code></font> in place of the keyword <font color="#663300"><code>DECLARE</code></font>.</li>
  <li>Using the keyword-pair <font color="#663300"><code>COMMON ARRAY</code></font> in place of the keyword <font color="#663300"><code>ARRAY</code></font>.</li>
  <li>Using the keyword-pair <font color="#663300"><code>COMMON BASED</code></font> in place of the keyword <font color="#663300"><code>BASED</code></font>.</li>
</ul>
<p>Another distinction is that <font color="#663300"><code>CHARACTER</code></font> variables cannot declared in <font color="#663300"><code>COMMON</code></font>, though <font color="#663300"><code>CHARACTER</code></font> variables can appear as fields in <font color="#663300"><code>COMMON BASED RECORD</code></font> variables.  <b>XCOM-I</b> actually relaxes this restriction.<br></p>
<p>It's not documented anywhere, as far as I know, but I would <i>assume</i> that there was originally an expectation that each cooperating application running in succession needed to declare <font color="#663300"><code>COMMON</code></font> in exactly the same way, using exactly the same ordering of variables and the same datatypes.  <b>XCOM-I</b> relaxes this restriction as well.  <br></p>
<p>Of course, <b>XCOM-I</b> makes no effort at all to pass <font color="#663300"><code>COMMON</code></font> data from one application to another using actual memory.  Rather, each XPL/I application program compiled by <b>XCOM-I</b> optionally (depending on its command-line options) can load a file of data into its <font color="#663300"><code>COMMON</code></font> area, and automatically writes out its <font color="#663300"><code>COMMON</code></font> area into a file upon termination.  By using the <font color="#663300"><code>--commoni</code></font> and <font color="#663300"><code>--commono</code></font> command-line switches of the application, a close degree of control can be exercised over which previously-saved <font color="#663300"><code>COMMON</code></font> blocks, if any, are passed to which application programs.<br></p>
<blockquote>
</blockquote>
<h3>Memory Model for a Compiled XPL Program<br>
</h3>
<p>The theoretical memory space at runtime for a compiled XPL program is 2<sup>24</sup>=16,777,216 bytes in size, although the Wikipedia article on IBM System/360 tells us that the actual physical maximum was only 8 MB.&nbsp; I presume that for the original XPL and XPL/I compilers, a contiguous partition in this (theoretical) 16 MB space was dedicated to storing just the program's variables, whereas the rest was presumably devoted to the operating system and program's executable code.&nbsp; For XCOM/I, such a partitioning is not necessary, and the entire 16MB space can be used for the compiled program's variables.<br></p>
<p>In <b>XCOM-I</b>, the lowest addresses of memory are filled with static data defined at compile-time:  <font color="#663300"><code>FIXED</code></font> and <font color="#663300"><code>BIT</code></font> variables and arrays, the string-descriptors for <font color="#663300"><code>CHARACTER</code></font> variables and arrays, the pointers for <font color="#663300"><code>BASED</code></font> variables.  None of the allocations in this area change at runtime, though the contents of the variables residing there may change during a run.  Above that static partition we dynamic allocations which may grow or shrink, or even move to other addresses entirely.  In particular, we have all of the string data for <font color="#663300"><code>CHARACTER</code></font> values and any allocations of memory made at runtime (for example, for <font color="#663300"><code>BASED</code></font> variables).  <b>XCOM-I</b> and its runtime library do not use any of this dynamic partition (or indeed any of the simulated memory model at all) for data of their own, so all of it is available for the XPL or XPL/I program. <br></p>

<p>Unfortunately, we have to stick pretty closely to the memory-space behavior as conceived by Intermetrics for it's XPL/I compiler, however poorly documented it may be, and however irrelevant it seems to a "modern" implementation, because HAL/S-FC source code sometimes relies on their hidden knowledge of that behavior.&nbsp; 
</p>
<blockquote>
  
<p><font size="-1"><b>Aside:</b> There are plenty of examples in HAL/S-FC source code where the source code exploits hidden knowledge of the internals of the compiler implementation.&nbsp; Here's one from the <font color="#663333"><code>SCAN</code></font> procedure of HAL/S-FC.&nbsp; In two of its sub-procedures, <font color="#663333"><code>BUILD_BCD</code></font> and <font color="#663333"><code>BUILD_INTERNAL_BCD</code></font>, it builds a string (<font color="#663333"><code>BCD</code></font>), character by character, whose length it does not know in advance.&nbsp; You'd think it could simply repeatedly convert each character to a string, and then use the string-concatenation operator (<font color="#663333"><code>||</code></font>) to append the new string to the old one.&nbsp; But you'd be wrong, since for some reason there's actually no way in XPL or XPL/I to convert  a character to a string.&nbsp; So instead, it:<br></font></p>

  <ul>
    <li><font size="-1">Uses an undocumented trick (namely concatenating a constant string which contains a single character to </font><font size="-1"><font size="-1"><font color="#663333"><code>BCD</code></font></font>), which forces </font><font size="-1"><font size="-1"><font size="-1"><font color="#663333"><code>BCD</code></font></font></font> to be moved to the top of allocated memory, and be followed by free memory.</font></li>
    <li><font size="-1">Uses the <font color="#663300"><code>COREBYTE</code></font> built-in function to write the character to the address just preceding the start of free memory.</font></li>
  </ul>
  
</blockquote>

<p>As mentioned before, variables of the <font color="#663333"><code>FIXED</code></font> and <font color="#663333"><code>BIT</code></font> datatypes, or arrays thereof, have sizes that are set at compile-time, and do not change thereafter.&nbsp; Moreover, the storage for the descriptors for the <font color="#663333"><code>CHARACTER</code></font> datatype and the pointers for the <font color="#663333"><code>BASED</code></font> variables are fixed at compile time as well.&nbsp; <i>However</i>, the character strings associated with the string descriptors for the <font color="#663333"><code>CHARACTER</code></font> variables, and the number of records associated with the <font color="#663333"><code>BASED</code></font> variables, can change during execution of the compiled XPL program, and in particular can increase in size.&nbsp; When the latter happens, it is necessary for such data to be moved into a previously-free area of the 16 MB memory, leaving unused holes in the memory.&nbsp; <br></p>
<p>The holes in memory don't directly cause a problem, but the ever-decreasing range of contiguous free memory at the end of the memory space may cause a problem eventually.&nbsp; The garbage-collection procedure called <font color="#663333"><code>COMPACTIFY</code></font> is called under these circumstances to repack the memory space, correct all pointers into the memory space, and thus increase the range of contiguous free memory.&nbsp; McKeeman (p. 140) lists <font color="#663333"><code>COMPACTIFY</code></font> among the built-in functions of XPL, but in defiance of that, explicitly provides an XPL <font color="#663333"><code>PROCEDURE</code></font> for it, whose source code is required to be included in other XPL programs; in fact, McKeeman's <b>XCOM</b> includes it <i>automatically</i>.&nbsp; Similarly, in the original XPL/I compiler, it was a user function provided by the HAL/S-FC source code file HALINCL/SPACELIB.&nbsp; <b>XCOM-I</b> takes a different approach: It provides its own implementation of <font color="#663333"><code>COMPACTIFY</code></font> in its runtime library, and it is a true built-in written in C rather than in XPL.&nbsp; <font size="-1">
</font></p>
<blockquote>
  <p><font size="-1"><b>Aside:</b>&nbsp; In case you're wondering why we don't simply use the </font><font size="-1"><font color="#663333"><code>COMPACTIFY</code></font> supplied in HALINCL/SPACELIB?&nbsp; It's a good question, which I elect not to answer. </font><br></p>
</blockquote>



<h3>Structure of an XPL Program</h3>
<p>An XPL program consists of any sequence of XPL <i>statements</i>, followed by the token <font color="#663333"><code>EOF</code></font>.&nbsp; In particular, declarations of variables can be intermixed with active statements such as assignments.
</p>
<blockquote>
  <p><font size="-1"><b>Note:</b>&nbsp; The original XPL compiler, which was called XCOM, performed a single pass.&nbsp; It required that the declaration of any particular identifier as an object (such as a variable) had to precede the use of that identifier, although there were provisions for making a forward declaration for a </font><font size="-1"><font color="#663333"><code>PROCEDURE</code></font>, so that the </font><font size="-1"><font color="#663333"><code>PROCEDURE</code></font> could be used before it was defined.&nbsp; <b>XCOM-I</b> relaxes this requirement.</font><br></p>
</blockquote>
<h3>Peculiarities of PROCEDUREs<br>
</h3>
<p>In a view from a height, an XPL program consists of <font color="#663333"><code>PROCEDURE</code></font> definitions and of code that uses those definitions.<br></p>
<p><font color="#663333"><code>PROCEDURE</code></font> definitions in the source code can be nested, to any desired depth. 
</p>
<p>A <font color="#663333"><code>PROCEDURE</code></font> may be invoked in two different ways.&nbsp; If it returns a value, it can be used in an arithmetical expression or a string expression.&nbsp; If it doesn't return a value, or if it does return a value and you simply want to ignore the value, a <font color="#663333"><code>CALL</code></font> statement can be used to invoke the <font color="#663333"><code>PROCEDURE</code></font> but to discard any returned value.<br></p>
<p><b>Important:</b>&nbsp; All variables local to a <font color="#663333"><code>PROCEDURE</code></font> definition retain their values after the <font color="#663333"><code>PROCEDURE</code></font> returns.&nbsp; If the <font color="#663333"><code>PROCEDURE</code></font> is re-executed, those local variables retain the values they previously had in the prior invocation of the <font color="#663333"><code>PROCEDURE</code></font>.&nbsp; The values of those local variables, though retained, are inaccessible to code outside of the <font color="#663333"><code>PROCEDURE</code></font>, because the compiler enforces scopes of variables. (In C code, this would be the same thing as saying that every local variable of every function is automatically declared as <font color="#663333"><code>static</code></font>.)
</p>
<p><b><i>Very</i> important:</b> Any <i>parameter</i>s at the end of the calling list of a <font color="#663333"><code>PROCEDURE</code></font> can be omitted from when calling the <font color="#663333"><code>PROCEDURE</code></font>, and if omitted, they retain the same values as the last time the <font color="#663333"><code>PROCEDURE</code></font> was invoked <i>or</i> the values previously assigned to those parameters from within the <font color="#663333"><code>PROCEDURE</code></font> itself!&nbsp; (In essence, this is like saying that parameters of a <font color="#663333"><code>PROCEDURE</code></font> are not passed to the <font color="#663333"><code>PROCEDURE</code></font>, but rather that they are just aliases for some set of global variables dedicated to the <font color="#663333"><code>PROCEDURE</code></font>.)&nbsp; That's so weird that we need to see an example.&nbsp; Consider the following XPL <font color="#663333"><code>PROCEDURE</code></font> definition, and <font color="#663333"><code>CALL</code></font>s to it:
</p>
<blockquote>
  <pre><font color="#663333">weirdo: <br>procedure(x, y, z);<br>    declare (x, y, z) fixed;		/* Declare x,y,z as integers */<br>    output = x || ' ' || y || ' ' || z; /* Print out x,y,z */<br>    x = 29;<br>    y = y + 1;<br>end weirdo;<br><br>call weirdo(1, 2, 3);<br>call weirdo(4, 5);<br>call weirdo(6);<br>call weirdo();<br>call weirdo;</font><br></pre>
</blockquote>
<p>The five calls successively print out the following:
</p>
<blockquote>
  <pre>1 2 3<br>4 5 3<br>6 6 3<br>29 7 3<br>29 8 3<br></pre>
</blockquote>
<p><font color="#663333"><code>PROCEDURE</code></font>s cannot be recursive, either directly or indirectly.<br></p>
<p>Taking these facts altogether, <b>XCOM-I</b> implements both parameters and local variables of <font color="#663333"><code>PROCEDURE</code></font>s essentially as global variables in they way they are stored:&nbsp; i.e., each parameter and each local variable of each <font color="#663333"><code>PROCEDURE</code></font> has its own <i>static</i> address (in the global memory model), assigned at compile time and unchanging thereafter.&nbsp; The compiler enforces the logical scoping of these variables.
</p>



<h1>


  <a name="hooks"></a>Patches for Basic Assembly Language Code<br>
</h1>A serious difficulty in working with previously-existing XPL code, 
and particularly XPL/I code, is that many of these programs were not 
written entirely in XPL or XPL/I, but also inserted IBM System/360 basic
 assembly-language (BAL) code at various junctures.&nbsp; However good 
<b>XCOM-I</b> may (or may not) be at translating XPL or XPL/I to C, it is <i>not</i> capable of inferring the intent of arbitrary BAL code, nor of translating such code into C.<br>
<br>
Moreover, there is a second problem associated with BAL code that has 
been intermixed into XPL/I code, which is that while I can imagine 
replacing such BAL code by C-language code that provides the same 
functionality, I do <i>not</i> want to do it in a way that necessitates 
altering the original XPL/I source code!&nbsp; Why is that?&nbsp; Well, 
the XPL/I source code for (say) HAL/S-FC is fairly large, comprising 
tens of thousands of lines across hundreds of files, and I'd prefer to 
avoid storing two almost-identical copies of it in our Virtual AGC 
source-code tree, one of which is identical to the original and one of 
which has been altered. It's better from my perspective to have a single
 copy of it that's verifiably identical to the original.<br>
<br>
Don't worry: <b>XCOM-I</b> accomplishes this.&nbsp; But to understand what you 
and <b>XCOM-I</b> can actually do about this situation, you need to know a 
little more about this BAL source code that's causing the problem.<br>
<br>
BAL source code is embedded in XPL or XPL/I code via calls to the XPL built-in function <font color="#663333"><code>INLINE</code></font> that look roughly like this:
<blockquote>
  <pre><pre><meta name="qrichtext" content="1"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><style type="text/css">
p, li { white-space: pre-wrap</style><p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><font color="#663300">         CALL INLINE("58", 3, 0, DW_AD);           /* L    3,DW_AD            */</font></p><font color="#663300">/*LOAD DOUBLE FROM STACK SPACE 3 TO REGISTER 0*/
</font><pre style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><font color="#663300">         CALL INLINE("68", 0, 0, 3, 0);            /* LD   0,0(0,3)           */</font></pre><font color="#663300">/*LOAD POSITIVE VALUE OF REGISTER 0 INTO REGISTER 0*/
</font><pre style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><font color="#663300">         CALL INLINE("20", 0, 0);                  /* LPDR 0,0                */</font></pre><font color="#663300">/*LOAD ROUNDING VALUE INTO STACK 1 THEN ADD TO REGISTER 0*/
</font><pre style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><font color="#663300">         CALL INLINE("58", 1, 0, ADDR_ROUNDER);    /* L    1,ADDR_ROUNDER     */</font></pre><font color="#663300">         CALL INLINE("6A", 0, 0, 1, 0);            /* AD   0,0(0,1)           */
</font><pre style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><font color="#663300">         CALL INLINE("58", 1, 0, ADDR_FIXED_LIMIT);/* L    1,ADDR_FIXED_LIMIT */</font></pre><font color="#663300">         CALL INLINE("58", 2, 0, PTR);             /* L    2,PTR              */
</font><pre style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><font color="#663300">/*COMPARE REGISTER 0 TO THE POSITIVE INTEGER LIMIT*/</font></pre><font color="#663300">         CALL INLINE("69", 0, 0, 1, 0);            /* CD   0,0(0,1)           */
</font><pre style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><font color="#663300">/*BRANCH TO 'LIMIT_OK' IF REGISTER 0 IS LESS THAN OR EQUAL TO THE LIMIT       */</font></pre><font color="#663300">         CALL INLINE("07",12, 2);                  /* BNHR 2                  */</font><pre style=" margin-top:0px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><!--EndFragment--></pre></pre></pre>
</blockquote>
There are several different variations to <font color="#663333"><code>INLINE</code></font>'s calling sequence, but those differences aren't important to us.&nbsp; What's important is that each <font color="#663333"><code>CALL INLINE(...)</code></font> inserts a single BAL instruction.<br>
<br>
Another thing that's important is that when <b>XCOM-I</b> encounters a <font color="#663333"><code>CALL INLINE(...)</code></font>,
 by default it translates it simply to an empty C statement; i.e., to a C
 statement that's just a semi-colon.&nbsp; But it also inserts a <i>numbered</i> program comment.&nbsp; The code above, for example, might be translated to C by <b>XCOM-I</b> as:<br>
<pre><pre><font color="#663300">        // (459) CALL INLINE("58", 3, 0, DW_AD);<br>	;<br>        // (460) CALL INLINE("68", 0, 0, 3, 0); <br>	;<br>        // (461) CALL INLINE("20", 0, 0);<br>	;<br>        // (462) CALL INLINE("58", 1, 0, ADDR_ROUNDER);<br>	;<br>        // (463) CALL INLINE("6A", 0, 0, 1, 0);<br>	;<br>        // (464) CALL INLINE("58", 1, 0, ADDR_FIXED_LIMIT);<br>	;<br>        // (465) CALL INLINE("58", 2, 0, PTR);<br>	;<br>        // (466) CALL INLINE("69", 0, 0, 1, 0);<br>	;</font><br></pre></pre>
These parenthesized numbers which <b>XCOM-I</b> has inserted into the comments 
are not only all distinct from each other, but also are always the same 
every time the source code has been compiled, as long no <font color="#663333"><code>INLINE</code></font>s have been added or removed in the meantime ... an assumption which at this point seems pretty safe!&nbsp; Let's call them <i>patch numbers</i>.<br>
<br>
Reasonably enough, patch numbers can be used to define places at which 
<b>XCOM-I</b> makes a patch.&nbsp; Suppose, for example, that we had a file 
called "patch459.c" containing C code that we wanted to use to mimic the
 functionality of the BAL code above.&nbsp; Similarly, we could have a 
patch460.c, a patch461.c, and so on, but there's little reason to do so,
 since it's just easier to put all of our replacement code for this 
sequence of instructions into a single file.<br>
<br>
Each time <b>XCOM-I</b> encounters a <font color="#663333"><code>CALL INLINE(...)</code></font>, it looks for a patch file corresponding to the <font color="#663333"><code>INLINE</code></font>'s
 patch number.&nbsp; If it finds such a file, then it inserts it, and 
it's only if there's no such patch file exists that the default 
translation into an empty C statement occurs.<br>
<br>
Of course, the glib explanation I've just given glosses over a lot of 
the difficulties, such as figuring out what C code is appropriate for 
any given BAL code.&nbsp; I can't give you any amazingly-handy insights 
on that topic, I'm afraid.&nbsp; In the case of this <i>particular</i> 
example, the code I've shown above is just the beginning portion of a 
longer sequence of BAL instructions, intermixed with XPL statements, 
which occurs in the <font color="#663333"><code>ROUND_SCALAR PROCEDURE</code></font>
 in the HAL/S-FC source-code file HALMATIN.xpl.&nbsp; Collectively, I 
think the entire sequence may round a double-precision floating-point 
number previously loaded into a pair of the CPU's floating-point 
registers (referred to by the symbolic name <font color="#663300"><code>DW[0]</code></font> and <font color="#663300"><code>DW[1]</code></font>) to an integer, compare that integer to the positive and negative limits of the 32-bit signed integer datatype (<font color="#663300"><code>FIXED</code></font>), and cap the value at those limits, ultimately storing the rounded-and-capped value back into <font color="#663300"><code>DW[0]</code></font> and <font color="#663300"><code>DW[1]</code></font>.&nbsp; (Which would not be terribly surprising given that the name of the <font color="#663300"><code>PROCEDURE</code></font> is <font color="#663300"><code>ROUND_SCALAR</code></font>.)&nbsp; <br>
<blockquote><font size="-1"><b>Aside:</b> How did I arrive at these 
conclusions?&nbsp; My best explanation is that you sit quietly, unfocus 
your eyes, clear your mind, attain some kind of a zenlike state, ignore 
the BAL instructions themselves, and think merely of the program 
comments and symbolic names.&nbsp; On the other hand, I suspect that my 
explanation is perhaps not of universal applicability.&nbsp; And it 
might be fair to mention that many of these sequences of BAL 
instructions use these same kinds of rounding and capping operations, 
and you do get a feel for them after looking at a few.</font><br>
</blockquote>
<blockquote><font size="-1"><b>Aside:</b> Realize too that the values 
stored in the CPU's floating-point registers will be in IBM 360 
floating-point format, so to do anything useful with them, we may want 
to translate them back and forth into the native C floating-point 
format.</font><br>
</blockquote>
If all that's true, then our patch file (patch459.c) might look 
something like the following, where I've invented some 
plausible-sounding helper functions to implement it.&nbsp; It's not 
important at the moment that you don't understand the patch code, or 
even if it's correct.&nbsp; It probably isn't!&nbsp; We're just 
exploring the principles involved in patching.&nbsp; Note that the <font color="#663300"><code>return</code></font>
 at the end is not an essential part of the patching process; rather it 
just happens to be appropriate for this example, but wouldn't be present
 in most patches.<br>
<blockquote>
  <pre><font color="#663300">// Note: ADDR(NULL, 0, "DW", i) gives the address of DW[i] in the simulated-memory array.<br>double x = fromFloatIBM(ADDR(NULL, 0, "DW", 0), ADDR(NULL, 0, "DW", 1));<br>double r = round(x);<br>int32_t n;<br>if (r &gt; 2147483647)<br>	n = 2147483647;<br>else if (r &lt; -2147483648)<br>	n = -2147483648;<br>else<br>	n = r;<br>toFloatIBM(ADDR(NULL, 0, "DW", 0), ADDR(NULL, 0, "DW", 1), n);<br>return 1;</font><br></pre>
</blockquote>
Putting all this together, if <b>XCOM-I</b> is used to compile the program once
 again, it now finds patch-file patch459.c, but no patch460.c, 
patch461.c, etc., so it ends up compiling our mess of <font color="#663333"><code>CALL INLINE(...)</code></font> statements to:<br>
<pre><pre><font color="#663300">        { // (459) CALL INLINE("58", 3, 0, DW_AD);<br>		// Note: ADDR(NULL, 0, "DW", i) gives the address of DW[i] in the simulated-memory array.
		double x = fromFloatIBM(ADDR(NULL, 0, "DW", 0), ADDR(NULL, 0, "DW", 1));<br>		double r = round(x);<br>		int32_t n;<br>		if (r &gt; 2147483647)<br>			n = 2147483647;<br>		else if (r &lt; -2147483648)<br>			n = -2147483648;<br>		else<br>			n = r;<br>		toFloatIBM(ADDR(NULL, 0, "DW", 0), ADDR(NULL, 0, "DW", 1), n);<br>		return 1;
	}<br>        // (460) CALL INLINE("68", 0, 0, 3, 0); <br>	;<br>        // (461) CALL INLINE("20", 0, 0);<br>	;<br>        // (462) CALL INLINE("58", 1, 0, ADDR_ROUNDER);<br>	;<br>        // (463) CALL INLINE("6A", 0, 0, 1, 0);<br>	;<br>        // (464) CALL INLINE("58", 1, 0, ADDR_FIXED_LIMIT);<br>	;<br>        // (465) CALL INLINE("58", 2, 0, PTR);<br>	;<br>        // (466) CALL INLINE("69", 0, 0, 1, 0);<br>	;</font></pre></pre>

Notice that the patch is automatically placed within a C <font color="#663300"><code>{...}</code></font> block, which is important if the <font color="#663333"><code>CALL INLINE(...)</code></font> happens to have been preceded by something like <code><font color="#663300">IF ... THEN</font></code> or <font color="#663300"><code>ELSE</code></font>.&nbsp; The <font color="#663300"><code>return</code></font> at the end of our patch causes all of the remainder of the <font color="#663333"><code>ROUND_SCALAR PROCEDURE</code></font> to be skipped past, probably generating a few warnings from the C compiler.&nbsp; But in a more-usual example the <font color="#663300"><code>return</code></font> wouldn't have been in the patch, and so the compiler warnings wouldn't be generated either.<br>
<br>
By default, <b>XCOM-I</b> will look for patch files in the same folder holding 
the XPL/I source-code file it's compiling, though it has a command-line 
option (<font color="#663300"><code>--patch=<i>PATHNAME</i></code></font>)
 that allows a different folder to be specified, which in the case of a 
huge XPL/I program like HAL/S-FC is probably a better idea.<br>
<br>
Incidentally, in <b>XCOM-I</b>, if <font color="#663333"><code>CALL INLINE(...) </code></font>is
 used with a single parameter that's a string, then no patch file is 
sought.&nbsp; Rather, <b>XCOM-I</b> treats that single string parameter as a 
line of C code, and inserts the line directly into the output C 
code.&nbsp; Thus if you were willing to modify the original XPL source 
code rather than leaving it unchanged and using the patch-file 
technique, you might be able to do so just by altering the parameters of
 the <font color="#663333"><code>CALL INLINE(...) </code></font>statements to contain C source code rather than BAL source code.<br>
<br>


    
<hr style="width: 100%; height: 2px;">
    
<center><br>
      <span style="color: rgb(84, 89, 93); font-family: sans-serif;
        font-size: 11.05px; font-style: normal; font-variant: normal;
        font-weight: normal; letter-spacing: normal; line-height:
        16.575px; orphans: auto; text-align: center; text-indent: 0px;
        text-transform: none; white-space: normal; widows: 1;
        word-spacing: 0px; -webkit-text-stroke-width: 0px; display:
        inline !important; float: none; background-color: rgb(255, 255,
        255);"> This page is available under the <a href="https://creativecommons.org/publicdomain/zero/1.0/">
          Creative Commons No Rights Reserved License</a> </span><br>
      <i><font size="-1">Last modified by <a href="mailto:info@sandroid.org">Ronald Burkey</a> on
          2024-04-18<br>
          <br>
          <a href="https://www.ibiblio.org"> <img style="border: 0px
              solid ; width: 300px; height: 100px;" alt="Virtual AGC is
              hosted by ibiblio.org" src="hosted.png" width="300" height="100"></a><br>
        </font></i></center>


    <br>


  

</body></html>