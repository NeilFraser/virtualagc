<!DOCTYPE doctype PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
  <head>
    <title>Virtual AGC Document Library Page</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="Author" content="Ronald Burkey">
    <link rel="icon" type="image/png" href="favicon.png">
    <meta name="author" content="Ronald S. Burkey">
    <script type="text/javascript" src="Header.js"></script>
  </head>
  <body style="background-image: url(gray3.jpg);">
    <script type="text/javascript">
document.write(headerTemplate.replace("@TITLE@","Space Shuttle").replace("@SUBTITLE@","Flight Software"))
</script><br>
    <div align="center"><i>(This page is under construction.)</i><br>
    </div>
    <h1>Table of Contents </h1>
    <ul>
      <li> <a moz-do-not-send="true" href="#Introduction">Introduction</a></li>
      <li><a moz-do-not-send="true" href="#References">References</a></li>
      <li><a moz-do-not-send="true" href="#PASS">PASS, BFS, and Other
          Shuttle Source Code</a></li>
      <li><a moz-do-not-send="true" href="#EBCDIC">Encoding of the
          Shuttle Source Code</a><br>
      </li>
      <li><a moz-do-not-send="true" href="#HALS">HAL/S</a><br>
      </li>
      <li><a moz-do-not-send="true" href="#Versioning">Software
          Versioning</a></li>
      <li><a moz-do-not-send="true" href="#Display">Multi-Function
          Display Formatting and Versioning</a></li>
      <li><a moz-do-not-send="true" href="#Messaging">Computer-to-Peripheral






          Interface</a><br>
      </li>
      <li><a moz-do-not-send="true" href="#Emulation">Compilation and
          Emulation</a></li>
    </ul>
    <h1><a name="Introduction"></a>Introduction</h1>
    <p>Insofar as the Space Shuttle is concerned, the Virtual AGC
      Project's present goals — or if you'd prefer, <i>my</i> goals —
      at present are the following:<br>
    </p>
    <ul>
      <li>To provide the complete source code for the software for the
        most-significant of its onboard computer systems, to the extent
        allowed by U.S. law.</li>
      <li>To provide all of the official documentation needed to
        understand that software and to work with it.&nbsp; See the <a
          moz-do-not-send="true" href="#References">References</a>.<br>
      </li>
      <li>To provide development tools suitable for working with the
        software source code, and in particular for compiling/assembling
        it into executable form.</li>
      <li>To provide an emulator suitable for running that executable
        code.</li>
      <li>For the emulator to be integrated into space-flight simulation
        systems such as Orbiter+SSU or FlightGear.</li>
    </ul>
    <p>In essence, we'd like to do the same kinds of things for the
      Space Shuttle's onboard computers, and in particular the
      computers' software, as we have done for Apollo's onboard computer
      systems and software.<br>
    </p>
    <p>In particular, we <i>don't</i> pretend to be putting together an
      "everything about the Space Shuttle" site.&nbsp; If you want to
      know about the Space Shuttle's Main Engines (SSME) or Reaction
      Control System (RCS), or hear marvelous facts such as the maximum
      payload size being a 15×60 foot cylinder weighing 65,000 pounds,
      then this is <i>not</i> the place to look.&nbsp; (But that's <i>big</i>,
      isn't it?&nbsp; I never knew.)<br>
    </p>
    <p>Now, there are various nuances to the statements above, such as
      whether access to source code must be restricted in some ways,
      rather than being freely available.&nbsp; And by "the" source
      code, do I mean <i>all</i> revisions?&nbsp; Do I mean for <i>all</i>
      components of the system?&nbsp; And by "the" development tools, do
      I mean the original ones, or do I mean partial work-alikes?&nbsp;
      And by emulation, do I mean emulation of the entire stack of code,
      or just for some restricted portion of it?&nbsp; And besides
      which, how do I really know which documents may be relevant to
      these matters and which may be completely irrelevant?<br>
    </p>
    <p>For example, although I explicitly said above that this <i>isn't</i>
      the site to come to if you want to learn about engines (SSME), the
      engines were in fact controlled by a dedicated controller
      containing <a moz-do-not-send="true"
        href="Shuttle/1985008580.pdf#page=60">two redundant Honeywell
        HDC-601 digital computers</a> ... so shouldn't those computers
      and their software be covered here?<br>
    </p>
    <p>Answers to those questions will become clear in the sections
      below ... or at least, clearer than they are now.&nbsp; There are
      a lot of gray areas.&nbsp; And I don't pretend to know all of the
      answers <i>yet</i>, so we may need to await future events to have
      a more-complete picture.&nbsp; But there aren't necessarily
      unique, permanently-correct answers anyway.&nbsp; One thing I can
      say unequivocally is that integration into space-flight simulation
      systems is my <i>hope</i> rather than anything that I'll actively
      pursue; integration is the prerogative of the developers of those
      space-flight simulators, rather than mine, if they feel it's
      worthwhile for them.<br>
    </p>
    <p>My explanation of the Shuttle's computer system here will by
      necessity be rather limited.&nbsp; The system is simply too
      complex, and there are too many resources already available on the
      web for me to suppose that a presentation by a johnny-come-lately
      like me would be worthwhile or even interesting about a topic this
      big.&nbsp; Perhaps the best place to get a general introduction
      would be <a moz-do-not-send="true"
href="https://www.ibiblio.org/apollo/Shuttle/Computers%20in%20Spaceflight%20-%20Chapter%204.pdf">Chapter


















        4, "Computers in the Space Shuttle Avionics System", of James
        Tomayko's <i>Computers in Spaceflight: The NASA Experience</i></a>,
      but there are numerous other documents in <a
        moz-do-not-send="true" href="links-shuttle.html">our Shuttle
        Library</a> to provide more detail.<br>
    </p>
    <p>With that said, here's a brief synopsis.&nbsp; As with any
      engineering system of substantial complexity, prepare to descend
      into acronym hell!<br>
    </p>
    <p>The portion of the Shuttle's full avionics system which primarily
      concerns us is the <i>Data Process System (DPS)</i>, which
      includes the <i>General Purpose Computers (GPC)</i>, the crew
      interface (display and keyboards), the mass-memory units, and the
      data-bus network interconnecting all of them.&nbsp; Here's a
      diagram, swiped from the afore-mentioned <i>Computers in
        Spaceflight</i>, that gives a very high-level view of the system
      architecture:<br>
    </p>
    <div align="center"><img moz-do-not-send="true"
        src="DPS%20block%20diagram.png" alt="" width="805" height="445"><br>
      <div align="left"><br>
        As you can see, there were five separate GPCs.&nbsp; Each of the
        GPCs was an AP-101S computer, designed and manufactured by IBM's
        Federal Services Division (as were the Apollo LVDC or Gemini
        OBC, though the GPC was not similar to them).&nbsp; Although I
        may not talk about the AP-101S much, it's worth mentioning that
        it was a kind of embedded version of the IBM System/360
        mainframe, in that it shared roughly the same assembly language,
        known as <i>Basic Assembly Language (BAL)</i>.<br>
        <br>
        Four of the GPCs nominally redundantly ran <i>identical</i>
        software, known as the <i>Primary Flight Software (PFS)</i>
        atop the <i>Flight Control Operating System (FCOS)</i>.&nbsp;
        PFS and FCOS together are collectively referred to as the <i>Primary













          Avionics Software Subsystem (PASS)</i>.&nbsp; The behaviors of
        these four copies of FCOS were synchronized ... not on a
        CPU-cycle by CPU-cycle basis, but to the extent that inputs to
        the GPCs from the spacecraft, as well as commands output from
        the GPCs to the spacecraft, occurred at the same time.&nbsp; In
        particular, the fact that outputs from the GPCs were
        synchronized allowed detection if one of the GPCs was behaving
        abnormally.&nbsp; I say they did this "nominally", because this
        extreme level of redundancy was warranted only during critical
        flight phases ... in particular, during ascent and
        reentry.&nbsp; During the more-leisurely phases of the mission,
        if additional computing power was needed, the four principal
        GPCs did not necessarily need to run identical, redundant
        software.<br>
        <br>
        The fifth GPC instead ran the <i>Backup Flight Software (BFS)</i>,
        created entirely separately from PASS in a clean-room
        fashion.&nbsp; This fifth GPC served roughly the same purpose in
        the Shuttle as the Abort Guidance System (AGS) did in the Apollo
        LM.&nbsp; BFS was specialized for abort functionality, i.e.,
        reentry in the absence of a reliable set of GPCs running
        PASS.&nbsp; And as I said above, this capability was really
        needed only during ascent or reentry.<br>
        <br>
        Besides these, there was a <i>Run Time Library (RTL)</i> that
        provided various common functions needed by PASS / BFS, such as
        square roots, trigonometric functions, and so forth, though the
        compiler embedded RTL code directly in the executable, so it
        doesn't seem to have existed as a separate entity.<br>
        <br>
        The data buses interconnecting the GPCs and peripheral devices
        were MIL-STD-1553 buses.<br>
        <br>
        The crew-interface devices included:<br>
        <ul>
          <li>26 line by 51 character displays, capable also of
            displaying some graphics.&nbsp; Prior to about the year
            2000, the pilots had 3 of these displays and the crew
            specialist had 1; they were monochrome (green text on black
            background) cathode-ray tubes (CRTs).&nbsp; After 2000, the
            CRTs were replaced by multi-color liquid crystal displays
            (LCDs), 9 for the pilots and 2 elsewhere.&nbsp;
            Collectively, the CRTs and LCDs were referred to as <i>Multifunction







              Display Units (MDUs)</i>.&nbsp; <br>
          </li>
          <li>Keyboards.&nbsp; The pilots had 2 of these, and the
            mission specialist station had a 3rd.</li>
        </ul>
        <p>The pre-2000 configuration was known collectively as the <i>Multifunction







            CRT Display System (MCDS)</i>, while the post-2000
          configuration was known as the <i>Multifunction Electronic
            Display Subsystem (MEDS)</i>.<br>
        </p>
        <p>In the diagrams below, the pre-2000 configuration is shown on
          the left, while the post-2000 configuration is shown on the
          right.&nbsp; Notice that the LCD-based displays (on the right)
          have 6 buttons along the bottom edges that the CRTs (on the
          left) lack, as well as being taller relative to their
          width.&nbsp; The LCDs continued to display 51×26 textual
          characters, just as the CRTs had, but the text was scrunched
          into the upper part of the screen, while a strip along the
          bottom of the LCD could display additional stuff that the CRTs
          hadn't been able to, such as menu options selectable by the
          edge buttons.&nbsp; These differences were transparent to the
          PASS / BFS flight software, because the additional stuff
          displayed along the bottom was not controlled by the PASS /
          BFS software.&nbsp; In contrast, keyboards were the same in
          type and number throughout the duration of the Shuttle
          program.<br>
        </p>
        <div align="center">
          <table width="100%" cellspacing="2" cellpadding="2"
            height="739">
            <tbody>
              <tr>
                <td valign="top" align="center">
                  <div><img moz-do-not-send="true"
                      src="ShuttleCRThorizSitPhoto.jpg" alt=""
                      width="429" height="364"><img
                      moz-do-not-send="true"
                      src="DPS%20keyboard%20and%20CRT.png" alt=""
                      width="952" height="730"><br>
                  </div>
                  <br>
                  <div><i>Older configuration:&nbsp; 4 CRT displays<br>
                      (Multifunction CRT Display System, or MCDS)<br>
                    </i> </div>
                </td>
                <td valign="top" align="center"><img
                    moz-do-not-send="true"
                    src="ShuttleLCDhorizSitPhoto.jpg" alt="" width="377"
                    height="363"><br>
                  <img moz-do-not-send="true" src="ShuttleMFD.png"
                    alt="" width="485" height="421"><br>
                  <br>
                  <img moz-do-not-send="true"
                    src="ShuttleForwardCockpitDisplays.png" alt=""
                    width="886" height="290"><br>
                  <br>
                  <i>Newer configuration:&nbsp; 11 LCD displays<br>
                    (Multifunction Electronic Display Subsystem, or
                    MEDS)<br>
                  </i> </td>
              </tr>
            </tbody>
          </table>
          <br>
          <br>
        </div>
      </div>
      <div align="left">There's a more-inclusive diagram below (click to
        enlarge) of the entire <i>older</i> configuration of the
        avionics system, if you feel the need for one.&nbsp; Personally,
        I'm just including it because it's colorful, and you'll need to
        dig into the actual documentation if you want real detail.&nbsp;
        By the way, you can tell it's the older configuration (MCDS)
        rather than the newer one (MEDS), because if you look in the
        upper-left area, you'll see "CRT 1", "CRT 2", "CRT 3", and
        (somewhat below the others) "CRT 4", rather than the 11 MFDs
        you'd see in the newer configuration:<br>
        <br>
        <div align="center"><a href="shuttle_avionics_sm.jpg"><img
              moz-do-not-send="true" src="shuttle_avionics_sm-small.jpg"
              alt="" title="Click to enlarge" width="1200" height="333"
              border="2"></a><br>
        </div>
        <br>
        <br>
        Below, on the other hand, is an extremely-informative diagram of
        display-system interconnections that specifically for the newer
        MEDS configuration.&nbsp; Don't be confused by the fact that
        some of the LCDs are designated by names like "CRT <i>N</i>",
        because they're <i>not</i> CRTs; they're just legacy names!<br>
        <br>
        <div align="center"><a href="MEDS.png"><img
              moz-do-not-send="true" src="MEDS.png" alt="" title="Click
              to enlarge" width="486" height="320" border="2"></a><br>
        </div>
        <br>
        Like the AGC, AGS, and LVDC, which are programmed essentially in
        the assembly language native to their CPU types, the Flight
        Control Operating System (FCOS) and the Run Time Library (RTL)
        are written in BAL, the assembly language of the AP-101S
        CPU.&nbsp; But once you get past those infrastructural software
        components, you have the Primary Flight Software (PFS), and the
        PFS is written in a higher-level language called HAL/S, as is
        the BFS.&nbsp; <a moz-do-not-send="true"
          href="Shuttle/DPS%20Overview%20Workbook.pdf#page=22">The DPS
          Overview Workbook</a> explains the overall structure of the
        PFS better than I can:&nbsp; <br>
        <blockquote>"PASS software consists of two types of software:
          system software and application software. System software runs
          the GPC. It is responsible for tasks such as GPC–to–GPC
          communication, loading software from MMUs, and timekeeping
          activities. Application software is software that runs the
          orbiter. This includes software that calculates orbiter
          trajectories and maneuvers, monitors various orbiter systems
          (such as power, communications, and life support), and
          supports mission–specific payload operations. The application
          software is divided into broad functional areas called major
          functions; in turn, each major function consists of
          Operational Sequences (OPS), which are loaded into the GPCs
          for each major phase of flight.<br>
          <br>
          "Finally, each OPS has one or more Major Modes (MMs) that
          address individual events or subphases of the flight."<br>
          <br>
        </blockquote>
        <div align="center"><img moz-do-not-send="true"
            src="Shuttle%20flight%20computer%20software.png" alt=""
            width="626" height="538"><br>
        </div>
      </div>
    </div>
    <ul>
    </ul>
    <h1><a name="References"></a>References</h1>
    <p>All documents I can find that I feel are relevant to discussion
      of the Space Shuttle's onboard computer systems and their software
      have been collected on <b><a moz-do-not-send="true"
          href="links-shuttle.html">our Space Shuttle Library page</a></b>.&nbsp;


















      That should be your first stop in a documentation
      pilgrimage!&nbsp; However, here are some websites that have
      additional documents that you may find interesting, and which may
      still contain relevant materials that I've overlooked:<br>
    </p>
    <ul>
      <li><a moz-do-not-send="true"
href="https://www.nasa.gov/centers/johnson/news/flightdatafiles/foia_archive.html">Johnson


















          Space Center's FOIA archive of flight data files</a>.</li>
      <li><a moz-do-not-send="true"
          href="https://sourceforge.net/projects/shuttleultra/files/References/">The


















          Space Shuttle Ultra site, particularly its reference section</a>.&nbsp;


















        Space Shuttle Ultra (SSU) is an add-on for the Orbiter
        spaceflight simulation system.</li>
      <li><a moz-do-not-send="true"
          href="https://wiki.flightgear.org/Space_Shuttle_Avionics">The
          FlightGear wiki entry on Space Shuttle avionics</a>.&nbsp;
        FlightGear is a flight simulation system.</li>
      <li><a moz-do-not-send="true"
          href="https://gandalfddi.z19.web.core.windows.net/shuttle.html">Ken


















          Hollis's Space Shuttle page</a>.</li>
      <li><a moz-do-not-send="true" href="https://ntrs.nasa.gov/">The
          NASA Technical Reports Server (NTRS)</a>.</li>
    </ul>
    <h1><a name="PASS"></a>PASS, BFS, and Other Shuttle Source Code</h1>
    <p>I have become aware of private individuals with copies of what I
      think may be the complete final revision of PASS and BFS.&nbsp;
      This is remarkable, given that a former developer of Shuttle
      software has told me that: <br>
    </p>
    <blockquote>
      <p>"When NASA shut down the Space Shuttle project, they erased all
        of the backup storage media — since there WAS NO REQUIREMENT for
        saving source code!&nbsp; Most of the HAL/S compiler and related
        tools (like ... other support software were not saved), but all
        of the HAL/S-based flight code was preserved."</p>
    </blockquote>
    <p>I will keep the editorial comments I'm tempted to make to
      myself.&nbsp; As an aside, I'll also comment that fortunately the
      source code of the original HAL/S compiler <i>was</i> saved after
      all, though by individuals rather than by any of the
      organizational actors involved.&nbsp; Shame on you, organizational
      actors!<br>
    </p>
    <p>At any rate, here is a list Shuttle-era software source code
      currently available to us, or that we hope to make available
      (potentially subject to ITAR restrictions on portions of it) at
      some point in the future:<br>
    </p>
    <ul>
      <li>HAL/S-FC — the original HAL/S compiler.&nbsp; Our software
        repository currently has <a moz-do-not-send="true"
href="https://github.com/virtualagc/virtualagc/tree/master/yaShuttle/Source%20Code/HAL-S-FC-REL32V0">only


          <i>partial</i> source code for release 32V0"</a>.&nbsp; Here
        are some admittedly-poor hints for dissecting that source code:</li>
      <ul>
        <li>The top-level program for any given phase of the compiler is
          generally the one called "##DRIVER.xpl".<br>
        </li>
        <li>The structure of the compiler program to one or another
          level of detail is documented in:</li>
        <ul>
          <li><a moz-do-not-send="true"
              href="Shuttle/19740021426.pdf#page=10">Chapter 2
              ("Compiler Organization") of the "HAL/S-FC Compiler System
              Functional Specification"</a>.</li>
          <li><a moz-do-not-send="true"
              href="Shuttle/hal-s_compiler_system_specification.pdf">"HAL/S


              Compiler System Specification"</a>.</li>
          <li><a moz-do-not-send="true" href="Shuttle/19760020796.pdf">"HAL/S-FC


              &amp; HAL/S-360 Compiler System Program Description"</a>.<br>
          </li>
        </ul>
        <li>The HAL/S compiler was based on the "Translator Writing
          System" (TWS), which is basically a compiler (XCOM) and other
          utilities for the XPL language, described in great detail in
          the book <i>A Compiler Generator</i> by McKeeman, Horning,
          and Wortman.&nbsp; Moreover, the HAL/S language is itself very
          much like the XPL language.&nbsp; Therefore, you may get some
          insights about HAL/S-FC&nbsp; by reading about XCOM that you
          mightn't get by in looking at the documentation that survives
          from the Shuttle project.</li>
      </ul>
      <li>Translator Writing System (TWS) —<a moz-do-not-send="true"
href="https://github.com/virtualagc/virtualagc/tree/master/yaShuttle/Source%20Code/XPL-TWS-1969-03">The


          source code from the Appendices of the book <i>A Compiler
            Generator</i></a> mentioned above, including XCOM and other
        XPL software.&nbsp; This is reference code, and is guaranteed
        (because the available documentation says so) not to be the same
        version of TWS on which HAL/S-FC is based.<br>
      </li>
      <li>PFS — wish list.</li>
      <li>BFS — wish list.</li>
      <li>FCOS — wish list.</li>
      <li>TBD<br>
      </li>
    </ul>
    <h1><a name="EBCDIC"></a>Encoding of the Shuttle Source Code</h1>
    <p><b>Executive summary</b>:&nbsp; As presented by the Virtual AGC
      Project, the vast majority of Shuttle source code is compatible
      with whatever character-encoding environment is used on your
      particular computer system, and in particular with UTF-8.&nbsp;
      But there's a handful of Shuttle source-code files that
      specifically need to be viewed using an ISO 8859-15 (or -1)
      encoding.&nbsp; And one more thing: The characters "^" and "~" are
      used, undocumented, as aliases for the "¬" operator in HAL/S and
      XPL.&nbsp; If this explanation satisfies you, I wouldn't bother to
      read the remainder of this section.&nbsp; If not, then read on!<br>
    </p>
    <p>These days, we tend not to think about how textual information is
      encoded numerically for storage in our computers, because almost
      everybody now does it the same way.&nbsp; Simple Latin-alphabet
      text, such as that found in almost-all computer software source
      code, is nowadays invariably encoded in what's known as 7-bit
      ASCII or "plain vanilla" ASCII:<br>
    </p>
    <blockquote>
      <p><tt>Dec Hex&nbsp;&nbsp;&nbsp; Dec Hex&nbsp;&nbsp;&nbsp; Dec
          Hex&nbsp; Dec Hex&nbsp; Dec Hex&nbsp; Dec Hex&nbsp;&nbsp; Dec
          Hex&nbsp;&nbsp; Dec Hex&nbsp; </tt><tt><br>
        </tt><tt>&nbsp; 0 00 NUL&nbsp; 16 10 DLE&nbsp; 32
          20&nbsp;&nbsp;&nbsp; 48 30 0&nbsp; 64 40 @&nbsp; 80 50
          P&nbsp;&nbsp; 96 60 `&nbsp; 112 70 p</tt><tt><br>
        </tt><tt>&nbsp; 1 01 SOH&nbsp; 17 11 DC1&nbsp; 33 21 !&nbsp; 49
          31 1&nbsp; 65 41 A&nbsp; 81 51 Q&nbsp;&nbsp; 97 61 a&nbsp; 113
          71 q</tt><tt><br>
        </tt><tt>&nbsp; 2 02 STX&nbsp; 18 12 DC2&nbsp; 34 22 "&nbsp; 50
          32 2&nbsp; 66 42 B&nbsp; 82 52 R&nbsp;&nbsp; 98 62 b&nbsp; 114
          72 r</tt><tt><br>
        </tt><tt>&nbsp; 3 03 ETX&nbsp; 19 13 DC3&nbsp; 35 23 #&nbsp; 51
          33 3&nbsp; 67 43 C&nbsp; 83 53 S&nbsp;&nbsp; 99 63 c&nbsp; 115
          73 s</tt><tt><br>
        </tt><tt>&nbsp; 4 04 EOT&nbsp; 20 14 DC4&nbsp; 36 24 $&nbsp; 52
          34 4&nbsp; 68 44 D&nbsp; 84 54 T&nbsp; 100 64 d&nbsp; 116 74 t</tt><tt><br>
        </tt><tt>&nbsp; 5 05 ENQ&nbsp; 21 15 NAK&nbsp; 37 25 %&nbsp; 53
          35 5&nbsp; 69 45 E&nbsp; 85 55 U&nbsp; 101 65 e&nbsp; 117 75 u</tt><tt><br>
        </tt><tt>&nbsp; 6 06 ACK&nbsp; 22 16 SYN&nbsp; 38 26 &amp;&nbsp;
          54 36 6&nbsp; 70 46 F&nbsp; 86 56 V&nbsp; 102 66 f&nbsp; 118
          76 v</tt><tt><br>
        </tt><tt>&nbsp; 7 07 BEL&nbsp; 23 17 ETB&nbsp; 39 27 '&nbsp; 55
          37 7&nbsp; 71 47 G&nbsp; 87 57 W&nbsp; 103 67 g&nbsp; 119 77 w</tt><tt><br>
        </tt><tt>&nbsp; 8 08 BS&nbsp;&nbsp; 24 18 CAN&nbsp; 40 28
          (&nbsp; 56 38 8&nbsp; 72 48 H&nbsp; 88 58 X&nbsp; 104 68
          h&nbsp; 120 78 x</tt><tt><br>
        </tt><tt>&nbsp; 9 09 HT&nbsp;&nbsp; 25 19 EM&nbsp;&nbsp; 41 29
          )&nbsp; 57 39 9&nbsp; 73 49 I&nbsp; 89 59 Y&nbsp; 105 69
          i&nbsp; 121 79 y</tt><tt><br>
        </tt><tt>&nbsp;10 0A LF&nbsp;&nbsp; 26 1A SUB&nbsp; 42 2A
          *&nbsp; 58 3A :&nbsp; 74 4A J&nbsp; 90 5A Z&nbsp; 106 6A
          j&nbsp; 122 7A z</tt><tt><br>
        </tt><tt>&nbsp;11 0B VT&nbsp;&nbsp; 27 1B ESC&nbsp; 43 2B
          +&nbsp; 59 3B ;&nbsp; 75 4B K&nbsp; 91 5B [&nbsp; 107 6B
          k&nbsp; 123 7B {</tt><tt><br>
        </tt><tt>&nbsp;12 0C FF&nbsp;&nbsp; 28 1C FS&nbsp;&nbsp; 44 2C
          ,&nbsp; 60 3C &lt;&nbsp; 76 4C L&nbsp; 92 5C \&nbsp; 108 6C
          l&nbsp; 124 7C |</tt><tt><br>
        </tt><tt>&nbsp;13 0D CR&nbsp;&nbsp; 29 1D GS&nbsp;&nbsp; 45 2D
          -&nbsp; 61 3D =&nbsp; 77 4D M&nbsp; 93 5D ]&nbsp; 109 6D
          m&nbsp; 125 7D }</tt><tt><br>
        </tt><tt>&nbsp;14 0E SO&nbsp;&nbsp; 30 1E RS&nbsp;&nbsp; 46 2E
          .&nbsp; 62 3E &gt;&nbsp; 78 4E N&nbsp; 94 5E ^&nbsp; 110 6E
          n&nbsp; 126 7E ~</tt><tt><br>
        </tt><tt>&nbsp;15 0F SI&nbsp;&nbsp; 31 1F US&nbsp;&nbsp; 47 2F
          /&nbsp; 63 3F ?&nbsp; 79 4F O&nbsp; 95 5F _&nbsp; 111 6F
          o&nbsp; 127 7F DEL</tt><br>
      </p>
    </blockquote>
    <p>Whereas if you have need for more than just the 95 printable
      characters (plus 33 control codes) provided by that scheme, the
      vastly-more-inclusive UTF-8 encoding scheme is used instead.&nbsp;
      In UTF-8, characters are encoded using from 1 to 6 bytes each, <i>but</i>
      the first 128 characters use 1 byte each and are identical to
      7-bit ASCII codes.<br>
    </p>
    <p>But it wasn't always like that, particularly when IBM was king of
      the mainframe hill, as it was back in the time that Shuttle (and
      Apollo) software development was first in full-swing.&nbsp; IBM
      mainframes like System/360 used an 8-bit character-encoding scheme
      called EBCDIC, which was completely unlike ASCII in almost every
      respect. I'll ask you to take my word for that rather than showing
      you a handy-dandy character table for EBCDIC like the one for
      ASCII above, because every EBCDIC table I can find differs (in
      some respects) from the others, and so in the end it's more
      confusing to show you a table than to leave it out entirely.&nbsp;
      How is this relevant to us?&nbsp; Well, since the entire Shuttle
      software-development system basically ran on those IBM System/360
      style computers, all of the Shuttle software source code was
      encoded in EBCDIC.&nbsp; And no modern computer systems use EBCDIC
      any longer.&nbsp; Without being converted in some way, the
      original source code simply looks like gobbledygook!&nbsp; So to
      store any Shuttle-related software in our software repository, or
      to display it here on these web-pages, that source code must first
      be converted from EBCDIC encoding to a modern encoding ... which
      to the extent possible is 7-bit ASCII.<br>
    </p>
    <p>As you may have guessed form the comments I've just made, that
      conversion process is not perfect.&nbsp; Simple alphanumerics and
      common punctuation don't cause any problems, but there are two
      more-unusual characters that cause us some difficulty.&nbsp; <br>
    </p>
    <p>The most irritating is the "¬" character, which as all of the
      HAL/S <i>and</i> XPL documentation tells us is the logical-NOT
      operator.&nbsp; Thus, a HAL/S (or XPL) expression that <tt>A</tt>
      is not equal to <tt>B</tt> would be <tt>A</tt><tt>¬=B</tt>.&nbsp;

      But it's questionable as to whether "¬" is even in EBCDIC or
      not.&nbsp; In some EBCDIC tables you find it encoded as
      hexadecimal 0x5F; in others, as 0xBA; in still other tables, it
      doesn't appear at all.&nbsp; Regardless of that, there is
      certainly no "¬" character in 7-bit ASCII, so no conversion is
      possible.<br>
    </p>
    <p>The workaround employed by HAL/S and XPL developers at the time
      seems to have been to use "^" or "~" instead of "¬", without
      choosing to make any mention of it in the documentation.&nbsp;
      Fortunately, both "^" and "~" do appear in ASCII. And in <i>some</i>
      versions of EBCDIC.&nbsp; <i>Our</i> workaround is simply to
      accept "^" or "~", which have no other uses in HAL/S or XPL, as
      being interchangeable with "¬".&nbsp; For example, <i>any</i> of
      the expressions <tt>A</tt><tt>¬=B</tt>, <tt>A^</tt><tt>=B</tt>,
      or <tt>A~</tt><tt>=B</tt> may be used to express "<tt>A</tt> is
      not equal to <tt>B</tt>" in our source-code presentation. </p>
    <p>The "¢" character is the other problematic case.&nbsp; It is an
      escape code that appears sometimes in string literals.&nbsp; Once
      again, it is usually available in EBCDIC (though not always with
      the same numerical encoding) but is not available in 7-bit ASCII
      at all.&nbsp; In this case, though, the original Shuttle
      developers used no alternate symbol, as far as I know right now
      ... so there is no workaround.&nbsp; We simply have to have "¢"
      characters in our HAL/S source code somehow, regardless of the
      fact that there's no 7-bit ASCII code for it.<br>
    </p>
    <p>Well, and there's also the "§" character that may or may not
      appear in certain messages printed by the original HAL/S compiler;
      I'm less certain about this one than the others, because I'm not
      sure exactly what the character is supposed to be, but it would be
      good to account for it.<br>
    </p>
    <p>So ... how are "¬" and "¢" then reasonably represented in an
      ASCII-like conversion of the original EBCDIC code?&nbsp; As I
      mentioned earlier, the most-standard way of doing that these days
      would probably be to encode them using UTF-8.&nbsp; Personally, I
      find that distasteful, since I hate to introduce multi-byte
      encodings for just a couple of characters appearing in a tiny
      minority of the source-code files.&nbsp; As an alternative to
      UTF-8, there's still a variety of 8-bit encoding schemes in common
      use today.&nbsp; One of these, ISO 8859-15 (or -1) is identical to
      7-bit ASCII for the lowest 128 characters, while encoding our
      problematic characters in the numerical range 128 through
      255.&nbsp; I've chosen to use this scheme for the presentation of
      HAL/S and XPL source code.</p>
    <h1><a name="HALS"></a>HAL/S<br>
    </h1>
    <p>HAL/S?&nbsp; HAL/S was a high-level programming language in which
      the PFS and BFS application software was written.&nbsp; Whereas
      infrastructural software (like operating systems and run-time
      libraries) was written in whatever assembly-languages were native
      to the particular CPUs running that code.&nbsp; <br>
    </p>
    <p>HAL/S was a compiled language, and the HAL/S flight-software
      source code was compiled down to a machine-code executable before
      it could be run.&nbsp; Compilers existed for it that could be used
      on several different types of computers.&nbsp; Some of the
      compilers produced code that could be run on an IBM System/360
      mainframe; others could produce executable code for the Shuttle's
      IBM AP-101S onboard computers; for all I know, others produced
      executable code for other computers. <br>
    </p>
    <p>I'm sure you can't help but notice that "HAL" was the name of the
      computer in the movie <i>2001: A Space Odyssey</i>, which came
      out in 1968, not too many years before the HAL/S language was
      invented.&nbsp; In the movie, H.A.L. stood for "Heuristic
      Algorithmic Logic", and many people have observed that H.A.L. was
      just one letter away from I.B.M.&nbsp; (I.e., "H" is one letter
      before "I" in the alphabet, "A" is one letter before "B", and "L"
      is one letter before "M".)&nbsp; The writer of the movie, Arthur
      C. Clarke, maintained that that was simply a coincidence.&nbsp;
      Where the "HAL" in HAL/S comes from has likewise been explained in
      several ways, none of them relating to <i>2001: A Space Odyssey</i>.&nbsp;






      The HAL/S language was invented (and the flight software was
      written) by a company called Intermetrics, many of whose employees
      were refugees from the same Draper Laboratories (MIT
      Instrumentation Laboratory) at which the Apollo flight software
      had been written.&nbsp; One of those refugees was Ed Copps, one of
      Intermetrics's founders, who is said to have named the HAL/S
      language in honor of Hal Laning, perhaps the most-prominent among
      the designers of the Apollo Guidance Computer's hardware.&nbsp;
      Others offer the explanation that HAL/S is an acronym for
      "High-order Assembly Language / Shuttle".&nbsp; <a
        moz-do-not-send="true" href="Shuttle/20120013307.pdf">Still
        others</a> state that "the acronym 'HAL' was never formally
      defined".&nbsp; Well, who knows?&nbsp; It's fun to make up your
      own mind about which constellation of facts matches your own
      preferences.&nbsp; All I can really say for sure is that there's
      nothing "heuristic" about HAL/S, even if <i>2001</i> may secretly
      have been somewhere in the back of somebody's mind.<br>
    </p>
    <p>But I digress.&nbsp; As I was saying, the HAL/S software for the
      Shuttle's PFS and BFS still survives in private stashes, which is
      much better than the alternative.&nbsp; But the Virtual AGC
      Project doesn't have any as of yet, and whether or not we can get
      any of it depends very much on the kindness of strangers.<br>
    </p>
    <p>Assuming that we can eventually get access to it, working with
      the application software's source code requires knowledge of the
      HAL/S language.&nbsp; Fortunately, we have a fair amount of
      documentation of that:<br>
    </p>
    <ol>
      <li>The recommended starting point is "<a moz-do-not-send="true"
          href="Shuttle/Programming%20in%20HAL_S%20Sept%201978.pdf">Programming
















          in HAL/S</a>", which was intended as an introduction to
        programming in HAL/S and is organized as a tutorial.</li>
      <li>The tutorial itself points out that it is not a definitive
        exposition of the language, and recommends proceeding afterward
        to the <a moz-do-not-send="true"
          href="Shuttle/HAL_S%20Language%20Specification%20Nov%202005.pdf">"HAL/S
















          Language Specification"</a>, which contains a much-more-formal
        specification of the language syntax, both in the form of graphs
        of the syntax and in Backus-Naur form (BNF).</li>
      <li>Or to the <a moz-do-not-send="true"
          href="Shuttle/HAL_S%20Programmers%20Guide%20Nov%202005.pdf">"HAL/S
















          Programmer's Guide"</a>.</li>
      <li>And then there's the <a moz-do-not-send="true"
          href="Shuttle/HAL_S-FC%20User's%20Manual%20Nov%202005.pdf">"HAL/S-FC
















          User's Guide"</a> explains how to compile and execute a HAL/S
        program.&nbsp; That explanation is, of course, completely
        irrelevant to our present situation, but you may find that the
        document answers some questions left unanswered by the preceding
        documents.&nbsp; (You many notice as well that our library
        contains a "HAL/S-360 User's Guide"; that's simply a predecessor
        of the "HAL/S-FC User's Guide".&nbsp; The former assumes that
        the computer on which the compiler ran was an IBM-360, while the
        latter assumed it was some arbitrary "mainframe" to which the
        compiler had been ported.)<br>
      </li>
    </ol>
    <p>We actually have quite a few revisions of each of the middle two
      documents in our library, spanning the mid-1970's to the
      mid-2000's, though I've only chosen to link the latest versions of
      those documents above.&nbsp; <br>
    </p>
    <p>Here's a brief sample of HAL/S code from "Programming in HAL/S",
      just to give you its flavor:<br>
    </p>
    <blockquote>
      <p><tt>&nbsp; FACTORIAL:</tt><tt><br>
        </tt><tt>&nbsp; PROGRAM;</tt><tt><br>
        </tt><tt>&nbsp;&nbsp;&nbsp;&nbsp; DECLARE INTEGER,</tt><tt><br>
        </tt><tt>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
          &nbsp;&nbsp;&nbsp; RESULT, N_MAX, I;</tt><tt><br>
        </tt><tt>&nbsp;&nbsp;&nbsp;&nbsp; READ(5) N_MAX;</tt><tt><br>
        </tt><tt>&nbsp;&nbsp;&nbsp;&nbsp; RESULT = 1;</tt><tt><br>
        </tt><tt>&nbsp;&nbsp;&nbsp;&nbsp; DO FOR I = 2 TO N_MAX BY 1;</tt><tt><br>
        </tt><tt>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; RESULT = I
          RESULT;</tt><tt><br>
        </tt><tt>&nbsp;&nbsp;&nbsp;&nbsp; END;</tt><tt><br>
        </tt><tt>&nbsp;&nbsp;&nbsp;&nbsp; WRITE(6) 'FACTORIAL=', RESULT;</tt><tt><br>
        </tt><tt>&nbsp; CLOSE FACTORIAL;</tt><br>
      </p>
    </blockquote>
    <p>What this program does is to read a number (<tt>N_MAX</tt>),
      compute its mathematical factorial, then output the result.&nbsp;
      While I won't dissect this short program in detail, I can make a
      couple of observations.&nbsp; For one, the language is <i>strongly







        typed</i>, meaning that every variable has a type that's
      declared at compile time, and that storage for it is fixed and
      unalterable at run-time.&nbsp; Nor is there any dynamic memory
      allocation (as well as no stack and no recursion), so RAM usage is
      completely known at compile time.&nbsp; HAL/S programs <i>never</i>
      unexpectedly abort because memory has filled up.&nbsp; The other
      observation is that the <tt>READ(5)</tt> and <tt>WRITE(6)</tt>
      statements are very familiar to FORTRAN users ... or at least to
      FORTRAN users of (say we say?) a certain vintage.&nbsp; In
      FORTRAN-speak, the 5 and 6 are "logical unit numbers" (LUN) whose
      specific interpretation as keyboard and printer (or keyboard and
      display, or even as files) are perhaps assigned externally by the
      Job Control Language (JCL) used to run the job.&nbsp; This
      reflects the fact that the first HAL compilers targeted IBM 360
      computers rather than the Shuttle's computers.&nbsp; In the
      Shuttle software, these <tt>READ</tt> and <tt>WRITE</tt>
      constructs wouldn't have been used, and keyboard input or display
      output would instead have been handled by calls to the run-time
      library.<br>
    </p>
    HAL/S actually has many novel features not visible in the <tt>FACTORIAL</tt>
    example, such as those devoted to real-time response and scheduling
    of execution.&nbsp; Again, I won't get into those here.&nbsp;
    Perhaps the most-novel feature is a superficial one, namely the
    ability to express mathematical formulae in a multi-line format that
    the language's designers felt was more self-documenting than the
    usual single-line manner of expressing mathematical formulae in
    programming languages.&nbsp; One comment made several times in the
    documentation is that it's worthwhile for the programmer to spend
    more time than one is usually inclined to do to make the source code
    easy to read ... because more time will eventually be spend reading
    the code than writing it.&nbsp; I.e., the time lost in creating
    readable code is more than made up for by the saving in maintaining
    the code later.&nbsp; This is sound engineering doctrine, according
    to the software-design literature of the time ... but very far from
    <i>today's</i> actual practice and attitudes (2022), in which the
    initial design schedule is everything, and downstream maintenance is
    an afterthought performed by somebody management doesn't have to
    budget time or money for <i>today</i>.&nbsp; So were the HAL/S
    designers on the wrong side of history in this respect?&nbsp;
    (That's an exercise for the reader.) <br>
    <br>
    What the multi-line format mainly does is to allow a more-natural
    representations of superscripts and subscripts.&nbsp; Here's a HAL/S
    sample that illustrates the multi-line pseudo-mathematical format:<br>
    <blockquote><tt>C Compute corners of a parallelogram.<br>
        <br>
        &nbsp; CORNERS: PROGRAM;</tt><tt><br>
      </tt><tt>&nbsp;&nbsp;&nbsp;&nbsp; DECLARE SCALAR,</tt><tt><br>
      </tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;







        LONG, SHORT, ALPHA;</tt><tt><br>
      </tt><tt>&nbsp;&nbsp;&nbsp;&nbsp; DECLARE VECTOR(2),</tt><tt><br>
      </tt><tt>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
        &nbsp;&nbsp;&nbsp; AB, BC, CD, DA;</tt><tt><br>
      </tt><tt>&nbsp;&nbsp;&nbsp;&nbsp; READ(5) LONG, SHORT, ALPHA;</tt><tt><br>
        <br>
      </tt><tt>E&nbsp;&nbsp;&nbsp; -</tt><tt><br>
      </tt><tt>M&nbsp;&nbsp;&nbsp; AB = 0;</tt><tt><br>
        <br>
      </tt><tt>E&nbsp;&nbsp;&nbsp; -</tt><tt><br>
      </tt><tt>M&nbsp;&nbsp;&nbsp; BC = VECTOR (LONG, 0);</tt><tt><br>
      </tt><tt>S&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;







        2 </tt><tt><br>
      </tt><tt><br>
      </tt><tt>E&nbsp;&nbsp;&nbsp; -</tt><tt><br>
      </tt><tt>M&nbsp;&nbsp;&nbsp; DA = VECTOR (SHORT COS(ALPHA), SHORT
        SIN(ALPHA));</tt><tt><br>
      </tt><tt>S&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;







        2</tt><tt><br>
      </tt><tt><br>
      </tt><tt>E&nbsp;&nbsp;&nbsp; -&nbsp;&nbsp;&nbsp;
        -&nbsp;&nbsp;&nbsp; -</tt><tt><br>
      </tt><tt>M&nbsp;&nbsp;&nbsp; CD = BC + DA;</tt><tt><br>
        <br>
      </tt><tt>E&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;







        -&nbsp;&nbsp; -&nbsp;&nbsp; -&nbsp;&nbsp; -</tt><tt><br>
      </tt><tt>M&nbsp;&nbsp;&nbsp; WRITE(6) AB, BC, CD, DA;</tt><tt><br>
      </tt><tt>&nbsp; CLOSE CORNERS;</tt><br>
    </blockquote>
    What this example program does is to allow input of parameters
    describing a parallelogram — namely, the lengths of a "short" side
    and a "long" side (which is assumed to be along the <i>x</i>-axis),
    and the angle between them in radians — and then to output the (<i>x</i>,<i>y</i>)
    coordinates of the four corners.&nbsp; The code also illustrates
    another of HAL/S's novel features, in that it can do arithmetic not
    just on scalar variables like integers or floats, but also do vector
    arithmetic or even matrix arithmetic. For example, vector/matrix
    addition or subtraction, vector dot products or cross products,
    matrix multiplication or inversion, etc.&nbsp; Functions like <tt>COS</tt>
    or <tt>SIN</tt> or <tt>VECTOR<sub>2</sub></tt> (which forms a
    2-vector from two scalar inputs) were available in the run-time
    library or as compile-time arithmetic when appropriate.<br>
    <br>
    It's important to realize that the lines with the leading characters
    <tt>E</tt>, <tt>M</tt>, and <tt>S</tt> in the example above are
    active code rather than merely program comments.&nbsp; In HAL/S,
    column 1 has a special purpose.&nbsp; Normally that column is
    blank.&nbsp; True, if a <tt>C</tt> appears there, it actually is a
    full-line comment.&nbsp; If a <tt>D</tt> appears there, then the
    line is a compiler directive.&nbsp; But for a multi-line
    mathematical form, <tt>M</tt> in column 1 indicates the formula's
    "main" line, whereas <tt>E</tt> indicates an "exponent" line and <tt>S</tt>
    indicates a "subscript" line.&nbsp; You can see that several places
    above.&nbsp; When this multi-line math format is discussed, it's
    generally described as a "3-line" format.&nbsp; But in fact, there
    was no limit to the number of <tt>E</tt> or <tt>S</tt> lines
    associated with a given <tt>M</tt> line.&nbsp; For example, here's
    some valid code:<br>
    <blockquote>
      <div class="moz-cite-prefix">
        <meta http-equiv="content-type" content="text/html;
          charset=UTF-8">
        <div class="moz-cite-prefix"><tt>E&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;






            DEX$J<br>
          </tt></div>
        <tt> </tt>
        <div class="moz-cite-prefix"><tt>E&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;






            I&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;





            I<br>
          </tt></div>
        <tt> </tt>
        <div class="moz-cite-prefix"><tt>M&nbsp;&nbsp;
            COEF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            ALPHA<br>
          </tt></div>
        <tt> </tt>
        <div class="moz-cite-prefix"><tt>S&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;






            L<br>
          </tt></div>
        <tt> </tt>
        <div class="moz-cite-prefix"><tt>S&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;






            M**2</tt></div>
      </div>
    </blockquote>
    But you'll notice that if you have a subscript in an <tt>E</tt>
    line or an exponent in an <tt>S</tt> line (as in <tt>DEX$J</tt> or
    <tt>M**2</tt> above), you just have to live with <i>those</i>
    little bits remaining in single-line notation.&nbsp; (In fact,
    there's not even <i>any</i> real need to put an <tt>M</tt> in
    column 1 for a main line, since the <tt>M</tt> meant exactly the
    same thing to the original compilers as a blank in column 1.&nbsp;
    I'm told — thank heaven! — that nobody ever actually did omit the <tt>M</tt>'s.)<br>
    <br>
    In the multi-line math format, if a variable (like <tt>AB</tt>) has
    a '-' above it, that means that <tt>AB</tt> is really a
    vector.&nbsp; Actually, a 2-vector, in the example code above.&nbsp;
    That's reflected in the declaration "<tt>DECLARE VECTOR(2), AB, ...</tt>".





    <br>
    <br>
    And '<tt>-</tt>' isn't the only datatype-related character that can
    appear in the <tt>E</tt> line above a variable in the <tt>M</tt>
    line:<br>
    <ul>
      <li>'<tt>-</tt>' for vectors.</li>
      <li>'<tt>*</tt>' for matrices.</li>
      <li>'<tt>,</tt>' for strings.</li>
      <li>'<tt>.</tt>' for booleans.</li>
      <li>'<tt>+</tt>' for structures.<br>
      </li>
    </ul>
    My impression is that creating source code in this multi-line format
    is a pain in the neck, since aligning the columns cards isn't that
    easy.&nbsp; Fortunately, HAL/S doesn't actually <i>require</i> the
    use of this <tt>E/M/S</tt> multi-line format for (input of)
    mathematical formulas.&nbsp; A single-line format is perfectly valid
    as well, and for the <tt>CORNERS</tt> program would look like this:<br>
    <blockquote><tt>&nbsp; CORNERS: PROGRAM;</tt><tt><br>
      </tt><tt>&nbsp;&nbsp;&nbsp;&nbsp; DECLARE SCALAR,</tt><tt><br>
      </tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;







        LONG, SHORT, ALPHA;</tt><tt><br>
      </tt><tt>&nbsp;&nbsp;&nbsp;&nbsp; DECLARE VECTOR(2),</tt><tt><br>
      </tt><tt>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
        &nbsp;&nbsp;&nbsp; AB, BC, CD, DA;</tt><tt><br>
      </tt><tt>&nbsp;&nbsp;&nbsp;&nbsp; READ(5) LONG, SHORT, ALPHA;</tt><tt><br>
        &nbsp;&nbsp;&nbsp;&nbsp; AB = 0;<br>
        &nbsp;&nbsp;&nbsp;&nbsp; BC = VECTOR$2(LONG, 0);<br>
        &nbsp;&nbsp;&nbsp;&nbsp; DA = VECTOR$2(SHORT COS(ALPHA), SHORT
        SIN(ALPHA));<br>
        &nbsp;&nbsp;&nbsp;&nbsp; CD = BC + DA;<br>
        &nbsp;&nbsp;&nbsp;&nbsp; WRITE(6) AB, BC, CD, DA;<br>
      </tt><tt>&nbsp; CLOSE CORNERS;</tt><br>
    </blockquote>
    In the single-line format, The beginning of a subscript is indicated
    by the '<tt>$</tt>' character. <br>
    <br>
    One thing you may take away from this is that the '<tt>-</tt>' (or '<tt>*</tt>',






    '<tt>+</tt>', ...) annotations which appear on the <tt>E</tt> lines
    to indicate vector vs scalar variables weren't really needed, since
    they don't show up in the single-line notation at all; in fact,
    they're just eye-candy nice for readability, and are actually
    discarded by the compiler.&nbsp; Whereas the subscript '<tt>2</tt>'
    which appears on the <tt>S</tt> line is in fact quite necessary,
    since <tt>VECTOR</tt>() isn't the same thing as <tt>VECTOR<sub>2</sub>()</tt>,
    which isn't the same thing as <tt>VECTOR<sub>3</sub>()</tt>.<br>
    <br>
    My guess is that almost all source code was written in the
    single-line format ... and indeed, I've been told by one of the
    original developers that this is so.&nbsp; However, realize that yet
    another novelty of HAL/S is that the original compiler allowed the
    programmer <i>no control whatsoever</i> over the format of the
    output compiler listings.&nbsp; Those were <i>always</i>
    pretty-printed according to the standards decided upon by the
    designers of the compiler.&nbsp; (Well, I think that maybe
    pretty-printing could be turned off, but that doesn't mean the
    person writing the code controlled the format.)&nbsp; Thus, the
    program might input code in the single-line format, but the assembly
    listing would always be output in the multi-line format. <br>
    <br>
    The same is true of any other formatting decisions.&nbsp; I
    mentioned above that column 1 of the source code has a special
    purpose, and thus it matters what characters appear in column 1 vs
    other columns.&nbsp; But for all lines which have blanks in column
    1, the input source code is completely free-form:&nbsp; Multiple
    statements can appear on a single line.&nbsp; Individual statements
    can be broken across multiple lines.&nbsp; Empty lines and
    whitespaces within lines are ignored, except where at least one
    space is needed between two adjacent identifiers.&nbsp; (And except
    in comments or literal quoted strings.)<br>
    <br>
    The latter point is interesting in connection with the operation of
    multiplication.&nbsp; While HAL/S has the usual operators for a lot
    of mathematical or logical operations, such as "<tt>-</tt>" for
    subtraction, "<tt>/</tt>" for division, "<tt>**</tt>" for
    exponentiation, and so on, <i>it has no operator for multiplication</i>.&nbsp;






    Multiplication is indicated simply by placing variable names,
    constant names, or literal numbers adjacent to each other (separated
    by whitespace).&nbsp; For example, <br>
    <blockquote><tt>DECLARE SCALAR, X, Y, Z;<br>
        DECLARE INTEGER, I, J, K;<br>
        X = Y Z ;<br>
        I = 2 J K ;<br>
      </tt></blockquote>
    <p>By the way, <tt>SCALAR</tt> is what HAL/S calls its
      floating-point type; thus <tt>SCALAR</tt> contrasts with <tt>INTEGER</tt>
      or <tt>BOOLEAN</tt> datatypes, but not with <tt>VECTOR</tt> or <tt>MATRIX</tt>.&nbsp;






      In fact, contrary to normal mathematical usage of the terms, all <tt>VECTOR</tt>
      and <tt>MATRIX</tt> objects consist entirely of <tt>SCALAR</tt>
      values.&nbsp; You can't have (say) a <tt>VECTOR</tt> of <tt>INTEGER</tt>
      values.&nbsp; Though there is an <tt>ARRAY</tt> type, of
      arbitrary dimensionality, which can hold values of any datatype
      you like.&nbsp; And as it turns out, there actually is an operator
      '<tt>*</tt>', but it is the vector cross-product operation, not a
      multiplication of two numbers.&nbsp; Similarly, the '<tt>.</tt>'
      operator is a vector dot product.<br>
    </p>
    <h1><a name="Versioning"></a>Software Versioning</h1>
    <p>As I've described above, any given shuttle had a number of
      computers, running a lot of different software components — more
      than just the GPCs running PFS / BFS / FCOS / RTL we're discussing
      here.&nbsp; Each of these software components had their own unique
      versioning.&nbsp; I couldn't begin to tell you what those all are;
      I don't even have a list of all the different computers or their
      software components, let alone details about their versions. <br>
    </p>
    <p>However, in all but the very earliest missions, the <i>collection</i>
      of all of the software components at their various revision levels
      was itself identified by what's called the <i>Operational
        Increment (OI)</i>.&nbsp; You thus see various Shuttle documents
      specifying "OI-24" or "OI-33", and what this means is that those
      documents are specialized to those particular overall software
      versions.&nbsp; The versioning of individual software components
      of the overall software version was apparently by <i>Version
        Increments (VI)</i>, such as "VI 1.23".<br>
    </p>
    <p>At this point, I have no authoritative references which link
      software versions to specific Shuttle missions.&nbsp; For what
      information I do have, I'd refer you to the mission summaries, <a
        moz-do-not-send="true"
        href="Shuttle/SpaceShuttleMissionsSummaryVol1.pdf">Volume 1</a>
      and <a moz-do-not-send="true"
        href="Shuttle/SpaceShuttleMissionsSummaryVol2.pdf">Volume 2</a>.&nbsp;













      (Some data past the end of Volume 2 can be gotten from NASA Press
      Kits for STS-132 through 135.)&nbsp; In the following tabulation,
      sorted by software version, notice that a higher STS mission
      number sometimes has a lower software version number, presumably
      partially because the mission numbering doesn't perfectly agree
      with the chronological order in which the missions were flown.<br>
    </p>
    <table cellspacing="2" cellpadding="2" border="1" align="center">
      <tbody>
        <tr>
          <th valign="middle" align="center">Mission<br>
          </th>
          <th valign="middle" align="center">Software Version<br>
          </th>
        </tr>
        <tr>
          <td valign="top" align="center">STS-1 <br>
          </td>
          <td valign="top" align="center">R16/T9<br>
          </td>
        </tr>
        <tr>
          <td valign="top" align="center">STS-2, 3, 4<br>
          </td>
          <td valign="top" align="center">R18/T11<br>
          </td>
        </tr>
        <tr>
          <td valign="top" align="center">STS-5, 6, 7, 8<br>
          </td>
          <td valign="top" align="center">R19/T12<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center">STS-9 (41A), 11 (41B), 13
            (41C)<br>
          </td>
          <td valign="middle" align="center">OI-2<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center">STS-14 (41DR), 17 (41G), 19
            (51A), 20 (51C), 24 (51B)<br>
          </td>
          <td valign="middle" align="center">OI-4<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center">STS-22 (51E), 23 (51D)<br>
          </td>
          <td valign="middle" align="center">OI-5<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center">STS-26 (51F)<br>
          </td>
          <td valign="middle" align="center">OI5-24<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center">STS-25 (51G)<br>
          </td>
          <td valign="middle" align="center">OI-6<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center">STS-27 (51I)<br>
          </td>
          <td valign="middle" align="center">OI6-27<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center">STS-28 (51J)<br>
          </td>
          <td valign="middle" align="center">OI6-28<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center">STS-30 (61A)<br>
          </td>
          <td valign="middle" align="center">OI6-29<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center">STS-31 (61B)<br>
          </td>
          <td valign="middle" align="center">OI6-30<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center">STS-33 (51L)<br>
          </td>
          <td valign="middle" align="center">OI17-26<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center">STS-32 (61C)<br>
          </td>
          <td valign="middle" align="center">OI17-32<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center">STS-26 (26R), 27 (27R), 28
            (28R), 29 (29R), 30 (30R), 33 (33R)<br>
          </td>
          <td valign="middle" align="center">OI-8B<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center">STS-31 (31R), 32 (32R), 34
            (34R), 36 (36R)<br>
          </td>
          <td valign="middle" align="center">OI-8C<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center">STS-35 (61E), 38, 40, 41<br>
          </td>
          <td valign="middle" align="center">OI-8D<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center">STS-37, 39<br>
          </td>
          <td valign="middle" align="center">OI-8F<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center">STS-42, 43, 44, 45, 48<br>
          </td>
          <td valign="middle" align="center">OI-20<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center">STS-46, 47, 49, 50, 52, 53,
            54, 55, 56<br>
          </td>
          <td valign="middle" align="center">OI-21<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center">STS-51, 57, 58, 59, 60, 61,
            62, 68<br>
          </td>
          <td valign="middle" align="center">OI-22<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center">STS-63, 64, 65, 66, 67<br>
          </td>
          <td valign="middle" align="center">OI-23<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center">STS-69, 70, 71, 72, 73, 74,
            75, 76, 77, 78<br>
          </td>
          <td valign="middle" align="center">OI-24<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center">STS-79, 80, 81, 82, 83, 84,
            94<br>
          </td>
          <td valign="middle" align="center">OI-25<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center">STS-85, 86, 87, 89<br>
          </td>
          <td valign="middle" align="center">OI-26A<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center">STS-88, 90, 91, 93, 95, 103<br>
          </td>
          <td valign="middle" align="center">OI-26B<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center">STS-92, 96, 97, 99, 101,
            106<br>
          </td>
          <td valign="middle" align="center">OI-27<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center">STS-98, 100, 102, 104, 105,
            108, 109<br>
          </td>
          <td valign="middle" align="center">OI-28<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center">STS-107, 110, 111, 112, 113<br>
          </td>
          <td valign="middle" align="center">OI-29<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center">STS-114, 115, 116, 117,
            118, 121<br>
          </td>
          <td valign="middle" align="center">OI-30<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center">STS-120, 122, 123, 124, 125<br>
          </td>
          <td valign="middle" align="center">OI-32<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center">STS-119, 126, 127<br>
          </td>
          <td valign="middle" align="center">OI-33<br>
          </td>
        </tr>
        <tr>
          <td valign="middle" align="center">STS-128, 129, 130, 131,
            132, 133, 134, 135<br>
          </td>
          <td valign="middle" align="center">OI-34<br>
          </td>
        </tr>
      </tbody>
    </table>
    <p>For example, the presentation for <a moz-do-not-send="true"
        href="Shuttle/STS-121%20FRR%20SE&amp;I.pdf#page=22">the STS-121
        Flight Readiness Review (FRR)</a> tells us that the software
      version was OI-30, in agreement with the table above, while just
      the Integrated Display Processor (IDP) software component was
      version VI 4.01 and the Multifunction Display Unit Function (MDUF)
      was version VI 5.00.<br>
    </p>
    <h1><a name="Display"></a>Multi-Function Display Formatting and
      Versioning</h1>
    <p>As was mentioned earlier in the <a moz-do-not-send="true"
        href="#Introduction">Introduction</a>, the principal method by
      which the General Purpose Computers (GPC) running the primary
      flight software (PFS) and backup flight software (BFS) interact
      with the crew includes keyboards and display screens.&nbsp; What's
      unusual about the display screens is that what appears on them is
      only <i>partially</i> controlled by the PFS or BFS
      software.&nbsp; Instead, there was another processor sitting
      between each of the displays and the GPCs, and it was this extra
      processor that directly controlled what was displayed and how the
      display was formatted.&nbsp; (For that matter, the keyboards also
      were attached to one of these extra processors rather than to the
      GPCs, so whatever keystrokes were seen by the PFS / BFS software
      had already been pre-digested by these extra processors.)<br>
    </p>
    <p><img moz-do-not-send="true" src="MCDS.png" alt="" width="455"
        height="278" align="right">In the case of the older, pre-2000
      cockpit configuration (MCDS, 4 CRTs), this extra processor was
      known as the <i>Display Electronics Unit (DEU)</i>, and it
      consisted of an IBM SP-0 CPU with 8K×16 bits of RAM.&nbsp; In the
      case of the newer, post-2000 cockpit configuration (MEDS, 11
      LCDs), the extra processor was known as the Integrated Display
      Processor (IDP), an Intel 368DX microprocessor.&nbsp; The basic
      schema is seen in the diagram to the right.&nbsp; While the
      diagram is specific to the older (MCDS) configuration, the newer
      (MEDS) configuration is conceptually quite similar.&nbsp; In the
      case of the MEDS configuration, the software for the IDP that was
      specifically tasked with formatting the display was called the <i>Display










        Application Software (DAS)</i>.&nbsp; But these kinds of details
      are of little interest to us in the absence of the DAS or other
      software that actually ran on the DEU/IDPs.&nbsp; So the only use
      of these factoids I'll use in the context of the present
      discussion is to refer from now on to what I've been calling the
      "extra processor" instead as the "DEU/IDP".<br>
    </p>
    <p>What <i>is</i> of importance to us, however, is that in addition
      to inputs from the GPCs via the MIL-STD-1553 databuses, the
      DEU/IDP's RAM was used to store a set of templates that controlled
      the formatting of the display screen.&nbsp; These templates were
      loaded from mass memory into RAM at power-up.&nbsp; In other
      words, the screen templates are <i>independent</i> of the PFS /
      BFS source code.<br>
    </p>
    For illustrative purposes, there's an example below of the template
    for screen "GNC SYS SUMM 1" for mission STS-96.&nbsp; It comes in
    two varieties, one for the primary flight software, and one for the
    backup flight software: <br>
    <br>
    <table cellspacing="2" cellpadding="2" border="0" align="center">
      <tbody>
        <tr>
          <td valign="top"><img moz-do-not-send="true"
              src="GNC-SYS-SUMM-1-PASS-STS96.png" alt="" width="534"
              height="385"><br>
            <div align="center"><i>PFS GNC SYS SUMM 1 screen, STS-96</i><br>
            </div>
          </td>
          <td valign="top"><img moz-do-not-send="true"
              src="GNC-SYS-SUMM-1-BFS-STS96.png" alt="" width="532"
              height="385"><br>
            <div align="center"><i>BFS GNC SYS SUMM 1 screen, STS-96</i></div>
          </td>
        </tr>
      </tbody>
    </table>
    <br>
    <p>As you can probably deduce from these images, some of the areas
      are supposed to be updated with data from the GPC (or elsewhere in
      the spacecraft), such as the HH, MM, and SS in the upper-right
      corner or the X's and S's that are all over the place.&nbsp; Other
      markings, like the "SURF", "POS", "MOM", and "DPS" are simply
      features of the template, and don't change at the whim of the GPC
      or more specifically, of PFS or BFS.<br>
    </p>
    <p>The screen templates don't <i>quite</i> fall under the
      Operational Increment (OI) top-level software-versioning scheme
      we've already discussed.&nbsp; They do, but they are also
      controlled by <i>Program Change Notices (PCN)</i>.&nbsp; The
      examples above are for STS-96 which flew software version OI-27,
      but that doesn't mean that all missions using OI-27 necessarily
      had identical screen templates.&nbsp; In a practical sense, what
      this means is that to know the screen templates and consequent
      display-screen formats for any given Shuttle mission, we must have
      not merely the screen templates for that generic OI, but also the
      differences to those templates that were made due to specific PCNs
      ... and of course, actually have the associated documentation so
      that we can consult it.&nbsp; <br>
    </p>
    <p>Several documents provide screen templates that can be related to
      one or more missions or software versions.&nbsp; The
      most-available seems to be JSC-48017,&nbsp; the "Data Processing
      System Dictionary".&nbsp; <a moz-do-not-send="true"
        href="links-shuttle.html#DPS">We have several revisions of
        JSC-48017 in our Shuttle Library</a>, and in principle, if we
      could collect <i>all</i> of the different revisions, then we'd
      have all of the screen templates for all of the missions.&nbsp; <a
        moz-do-not-send="true"
        href="Shuttle/Space%20Shuttle%20DPS%20Dictionary%20OI-26.pdf">The








        GNC SYS SUMM 1 sample templates above came from one such DPS
        Dictionary</a>.&nbsp; There are also reference-card-like
      summaries that are very helpful, such as <a
        moz-do-not-send="true"
        href="Shuttle/Orbiter%20Displays%20Reference%20Guide%20OI-34.pdf">this











        one for OI-34</a>.<br>
    </p>
    <p>On the other hand, <i>the <a moz-do-not-send="true"
          href="links-shuttle.html#DPS">Functional Subsystem Software
          Requirements (FSSR)</a></i> documents also contain these
      templates, and seem a lot more authoritative, as well as providing
      a lot more information. In fact, the FSSR goes so far as to give
      screen coordinates for each field, and to explain how every datum
      received by the DEU/IDP via the databus relates specifically to
      each X and S on the display screen!&nbsp; Unfortunately, the FSSRs
      are also a lot more numerous and a lot harder to find than DPS
      Dictionaries are, so the dream of obtaining a complete set of them
      seems more whimsical than obtaining a complete set of DPS
      Dictionaries.&nbsp; Nevertheless, on balance, it seems as though
      the FSSRs should be regarded as the controlling documents for the
      screen templates.&nbsp; We just need to collect all of them, or
      failing that, fall back on DPS Dictionaries when available.&nbsp;
      For example, here are the same GNC SYS SUMM 1 templates, but for
      software version OI-34 (say, mission STS-128), taken from the
      FSSR.&nbsp; They're different than the ones shown above for
      STS-96, though only barely so.&nbsp; Personally, I see only 4
      differences, some sensible, some nonsensical, and some (I suspect)
      misprints; perhaps you can find more.&nbsp; Incidentally, STS-96
      had the MCDS (pre-2000) cockpit configuration, while STS-128 had
      the MEDS (post-2000) cockpit configuration, so perhaps that has
      something to do with the differences.<br>
      <br>
    </p>
    <table cellspacing="2" cellpadding="2" border="0" align="center">
      <tbody>
        <tr>
          <td valign="top"><img moz-do-not-send="true"
              src="GNC-SYS-SUMM-1-PASS-OP34.png" alt="" width="541"
              height="371"><br>
            <div align="center"><i>PFS GNC SYS SUMM 1 screen, STS-128</i><br>
            </div>
          </td>
          <td valign="top"><img moz-do-not-send="true"
              src="GNC-SYS-SUMM-1-BFS-OP34.png" alt="" width="541"
              height="371"><br>
            <div align="center"><i>BFS GNC SYS SUMM 1 screen, STS-128</i></div>
          </td>
        </tr>
      </tbody>
    </table>
    <h1><a name="Messaging"></a>Computer-to-Peripheral Interface<br>
    </h1>
    <p>Keyboard data was supplied to the General Purpose Computers
      (GPC), and hence to the PASS/BFS software, by means of messages on
      the MIL-STD-1553 databuses interconnecting the GPCs and
      DEU/IDPs.&nbsp; Similarly, data was output by the GPCs for display
      by passing messages on the databuses as well.&nbsp; Technical
      details about this messaging can be found in the <a
        moz-do-not-send="true"
href="Shuttle/JSC-18820%20-%20Rev%20B%20-%20Data%20Processing%20System%20Brief%2019970615.pdf#page=169">Data









        Processing System Brief</a>.&nbsp; I won't bother to summarize
      that information here, since the document's presentation is at
      least as readable as anything I might write up to supplement
      it.&nbsp; While our only available revision of this document so
      far is for the MCDS, recall that the change from the MCDS to MEDS
      cockpit configurations was done in a way that was transparent to
      the existing software.&nbsp; That implies, I hope, that the
      messaging format would have been the same in either configuration.<br>
    </p>
    <p>TBD<br>
    </p>
    <h1><a name="Emulation"></a>Compilation and Emulation</h1>
    In contrast to the HAL/S source code for PFS (PASS) and BFS, of
    which I have none so far, I have in fact received quite <a
      moz-do-not-send="true" href="#PASS">a lot of the source code (but
      not all) for the original HAL/S compiler, HAL/S-FC</a>.&nbsp; <br>
    <blockquote><font size="-1"><b>Aside:</b> HAL/S-FC was written in a
        language called <a moz-do-not-send="true"
          href="https://www.cs.toronto.edu/XPL/">XPL</a>, and HAL/S
        could theoretically be compiled (and run) using <a
          moz-do-not-send="true"
          href="https://sourceforge.net/projects/xpl-compiler/">Daniel
          Weaver's XPL-to-C cross-compiler</a>;&nbsp; I say
        "theoretically", because it doesn't work at all for me, and I am
        not currently pursuing that approach.&nbsp; If you succeed in
        doing so, or if you simply wish to discuss it, let me know! </font><br>
    </blockquote>
    In lieu of being able to run the HAL/S-FC compiler itself, I have
    been working on my own "modern" HAL/S compiler.&nbsp; I expect it to
    be inferior to HAL/S-FC, but perhaps more-capable of adaptation and
    maintenance into the future.&nbsp; We'll see.&nbsp; At any rate,
    when a HAL/S compiler and means of emulating the compiled PASS/BFS
    executable code exist, I'll report on them in this section. Until
    then, I'll point out that <a moz-do-not-send="true"
href="https://github.com/virtualagc/virtualagc/blob/master/yaShuttle/README.md">the















      compiler-development roadmap and reports on progress along that
      roadmap appear in the associated README</a> file in our software
    repository.<br>
    <blockquote><font size="-1"><b>Aside:</b>&nbsp; If you are
        knowledgeable about compiler theory, you may have noticed that a
        BNF grammar for HAL/S is available in the original
        documentation.&nbsp; This may lead you to hope that you can
        relatively-easily throw together a compiler for HAL/S, using
        modern compiler-generator tools.&nbsp; If you somehow succeed in
        doing so, or want to discuss it in more detail, let me
        know!&nbsp; However, it's worth noting that the available BNF
        (which is supposed to be used for describing <i>context-free</i>
        grammars) is incomplete in a manner that serves to conceal the
        fact that the grammar for HAL/S is <i>not</i> actually
        context-free.&nbsp; I offer you a couple of examples, in the
        form of parsing problems that you should be able to answer from
        a context-free grammar, without recourse to any contextual
        information such as variable declarations elsewhere in the
        code:&nbsp; <br>
        <br>
        &nbsp;&nbsp;&nbsp; a) Is the HAL/S expression </font><font
        size="-1"><tt>A.B</tt></font><font size="-1"> a reference to
        field </font><font size="-1"><tt>B</tt></font><font size="-1">
        in structure </font><font size="-1"><tt>A</tt></font><font
        size="-1">, or is it the dot product of vectors </font><font
        size="-1"><tt>A</tt></font><font size="-1"> and </font><font
        size="-1"><tt>B</tt></font><font size="-1">?<br>
        &nbsp;&nbsp;&nbsp; b) Is the HAL/S expression </font><font
        size="-1"><tt>A(B)</tt></font><font size="-1"> a call to
        function </font><font size="-1"><tt>A</tt></font><font
        size="-1"> with argument </font><font size="-1"><tt>B</tt></font><font
        size="-1">, or is it the multiplication of </font><font
        size="-1"><tt>A</tt></font><font size="-1"> times </font><font
        size="-1"><tt>B</tt></font><font size="-1">?&nbsp; (Hint: There
        is no multiplication operator in HAL/S.)</font><font size="-1"><br>
      </font> </blockquote>
    <br>
    TBD<br>
    <br>
    <hr style="width: 100%; height: 2px;">
    <center><br>
      <span style="color: rgb(84, 89, 93); font-family: sans-serif;
        font-size: 11.05px; font-style: normal; font-variant: normal;
        font-weight: normal; letter-spacing: normal; line-height:
        16.575px; orphans: auto; text-align: center; text-indent: 0px;
        text-transform: none; white-space: normal; widows: 1;
        word-spacing: 0px; -webkit-text-stroke-width: 0px; display:
        inline !important; float: none; background-color: rgb(255, 255,
        255);"> This page is available under the <a
          href="https://creativecommons.org/publicdomain/zero/1.0/">
          Creative Commons No Rights Reserved License</a> </span><br>
      <i><font size="-1">Last modified by <a
            href="mailto:info@sandroid.org">Ronald Burkey</a> on
          2022-12-12<br>
          <br>
          <a href="https://www.ibiblio.org"> <img style="border: 0px
              solid ; width: 300px; height: 100px;" alt="Virtual AGC is
              hosted by ibiblio.org" src="hosted.png" width="300"
              height="100"></a><br>
        </font></i></center>
    <br>
  </body>
</html>
